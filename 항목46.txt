항목 46: 타입 변환이 바람직할 경우에는 비멤버 함수를 클래스 템플릿 안에 정의해 두자.

모든 매개변수에 대해 암시적 타입 변환이 되도록 만들기 위해서는 비멤버 함수밖에 방법이
없다는, 이번 항목과 조금 비슷한 이야기는 이전에 항목 24에서 이유까지 말씀드린 바 있습
니다. 그 당시, Rational 클래스의 operator* 함수가 예제로 나왔었죠. 이번 항목을
편하게 읽어 가시려면 일단 이 예제를 눈에 잘 넣어두는 것이 좋습니다. 항목 24에 나온 그
예제를 한 번 더 살짝 우려내고 약간의 조미료를 친 것을 잘근잘근 씹으며 이야기를 넓혀갈
생각이거든요. 어떻게 할 것인고 하니, Rational 클래스와 oprator* 함수를 템플릿으로
만들 것입니다.

template<typename T>
class Rational
{
public:
	Rational(const T& numerator = 0,	// 매개변수가 참조자로 전달되는 이유는
			const T& denominator = 1);	// 항목 20을 보면 나옵니다.
	const T numerator() const;		// 반환값 전달이 여전히 값에 의한 전달인
	const T denominator() const;	// 이유는 항목 28을 보면 나오고요.
	...							// 이들 함수가 const인 이유는 항목 3에서...
};

template<typename T>
const Rational<T> operator*(const Rationa<T>& lhs, 
							const Rationa<T>& rhs){...}

항목 24에서도 그랬듯, 혼합형(mixed-mode) 수치 연산은 여전히 필요합니다. 다음의
코드가 컴파일되어야 하는 거죠. 그런데 이미 항목 24에서 동작하는 코드를 그대로 가져
왔기 때문에, 컴파일이 안 되는 게 더 이상할 것 같습니다. 차이점이라면 Rational 및
operator* 부분이 이제는 템플릿이라는 것밖엔 없으니까요.

Rational<int> oneHalf(1, 2);		// Rational이 이제 템플릿이란 것만 빼면
									// 이 예제는 항목 24의 것과 똑같습니다.

Rational<int> result = oneHalf * 2;// 그런데 에러입니다. 컴파일이 안되요.

컴파일이 되지 않는다는 사실로 미루어 볼때, 템플릿 버전의 Rational에는 템플릿이기
전의 버전과 다른 무언가가 있지 않을까 싶은데요, 실제로 있습니다. 항목 24에서는 우
리가 호출하려고 하는 함수가 무엇인지를 컴파일러가 알고 있지만(Rational 객체 두
개를 받는 operator* 함수였죠), 지금 경우에는 어떤 함수를 호출하려 하는지에 대해
컴파일러로서는 아는 바가 전혀 없습니다. 단지, 컴파일러는 operator*라는 이름의
템플릿으로부터 인스턴스화할(다시 말해, 만들어낼) 함수를 결정하기 위해 온갖 계산을
동원할 뿐이랍니다. 이 시점에서 컴파일러가 확실히 하는 것은 Rational<T> 타입의
매개변수를 두 개 받아들이는 operator*라는 이름의 함수를 자신이 어떻게든 인스턴스
로 만들긴 해야 한다는 점입니다. 그러나 이 인스턴스화를 제대로 하려면 '대관절 T가
무었인고?'에 대한 수수께끼를 풀어야 합니다. 문제는 바로, 컴파일러 스스로는 이 수
수께끼를 풀 능력이 없다는 거죠.

T의 정체를 파악하기 위해, 컴파일러는 우선 operator* 호출 시에 넘겨진 인자의 모든
타입을 살핍니다. 지금의 경우에는 Rational<int>(oneHalf의 타입) 및 int(2의 타
입)입니다. 컴파일러는 이들을 하나씩 확인해 갑니다.

oneHalf 쪽은 의외로 확인이 쉽습니다. operator*의 첫 번째 매개변수는 Rational
<T> 타입으로 선언되어 있고, 지금 operator*에 넘겨진 첫 번째 매개변수가 마침 또
Rational<int> 타입이기 때문에, T는 int일 수밖에 없습니다. 하지만 애석하게도 두
번째 매개변수 쪽은 타입을 유추해내기가 쉽지 않습니다. operator*의 선언을
보면 두 번째 매개변수가 Rational<T> 타입으로 선언되어 있는데, 지금 operator*
에 넘겨진 두 번째 매개변수(2)는 int 타입입니다. 이때 컴파일러는 어떻게 해야 T의
정체를 알아낼 수 있을까요? Rational<int>에는 explicit로 선언되지 않은 생성자가
들어 있다는 것을 확인한 독자라면, 혹시 컴파일러가 이 생성자를 써서 2를 Rational
<int>로 변환하고 이를 통해 T가 int라고 유추할 수 있지 않을까 하고 예상할 것 같
습니다만, 컴파일러는 그렇게 동작하지 못합니다. 그 이유는, (잘 알아두세요) 템플릿
인자 추론(template argument deduction) 과정에서는 암시적 타입 변환이 고려
되지 않기 때문입니다. 절대로 안됩니다. 이런 타입 변환은 함수 호출이 진행될 때 쓰
이는 것은 맞습니다. 그렇죠. 그러나 여러분이 함수를 호출할 수 있으려면 어떤 함수가
있는지를 여러분이 미리 알고 있어야 합니다. 게다가 호출되는 상황에 맞는 함수 템플릿
에 넣어 줄 매개변수 타입을 추론하는 일도(함수를 인스턴스화해야 하니 말이죠) 여러
분이 해야 합니다. 하지만, 다시 말씀드리지만 템플릿 인자 추론이 진행되는 동안에는
생성자 호출을 통한 암시적 타입 변환 자체가 고려되지 않습니다. 사실 항목 24에서는
템플릿이 거론되지 않았기 때문에, 템플릿 인자 추론 문제가 불거지지 않은 것뿐입니다.
지금은 C++의 템플릿 부분(뭔 소린지 헷갈리시나요? 항목 1 참조)에 와 있으므로,
이것이 아주 중대한 문제입니다.

*	템플릿 인자 추론(template argument deduction) 과정에서는 암시적 타입 
	변환이 고려되지 않는다. 절대로 안됩니다.
*	템플릿 인자 추론은 함수 템플릿에만 적용되는 과정입니다.

이처럼 힘든 처지에서 템플릿 인자 추론을 해야 하는 수고로부터 컴파일러를 해방시킬
수 있는 방법이 있습니다. 클래스 템플릿 안에 프렌드 함수를 넣어 두면 함수 템플릿
으로서의 성격을 주지 않고 특정한 함수 하나를 나타낼 수 있다는 사실을 이용하는 것
입니다. 다시 말해, Rational<T> 클래스에 대해 operator*를 프렌드 함수로 선언
하는 것이 가능하다는 이야기입니다. 클래스 템플릿은 템플릿 인자 추론 과정에서 좌
우되지 않으므로, T의 정확한 정보는 Rational<T> 클래스가 인스턴스화될 당시에
바로 알 수 있습니다. 그렇기 때문에, 호출 시의 정황에 맞는 operator* 함수를 
프렌드로 선언하는 데 별 어려움이 없는 것입니다.

template<typename T>
class Rational
{
public:
	...
	// operator* 함수를 선언합니다(자세한 내용은 아래에 나와요)
	friend const Rational operator*(const Rational& lhs, 
							const Rational& rhs);
};

// operator* 함수를 정의합니다.
template<typename T>
const Rational<T> operator*(const Rational<T>& lhs, 
							const Rational<T>& rhs){...}

이제 여러분은 혼합형 operator* 호출이 컴파일되는 코드를 보고 계십니다. 
oneHalf 객체가 Rational<int> 타입으로 선언되면 Rational<int> 클래스가 
인스턴스로 만들어지고, 이때 그 과정의 일부로서 Rational<int> 타입의 매개변
수를 받는 프렌드 함수인 opertator*도 자동으로 선언되기 때문입니다. 이전과
달리 지금은 함수(Rational의 비명시 호출 생성자 등)를 적용할 수 있게 되는
것이죠. 컴파일에 성공하는 이유는 이게 전부입니다.
하지만 이 코드는 컴파일은 되지만, 링크가 안됩니다. 이 문제는 조금 있다가 
바로 잡겠습니다만, 우선 필자는 Rational 안에 operator*를 선언하는데 
사용한 문법에 대해 몇 가지 말씀 드리고 싶습니다.

클래스 템플릿 내부에서는 템플릿의 이름(<> 뗀 것)을 그 템플릿 및 매개변수의
줄임말로 쓸 수 있습니다. 그러니까 Rational<T> 안에서는 Rational이라고만
써도 Rational<T>로 먹힌다는 거죠. 위의 예제에서야 몇 자 덜 치는 정도이지만,
매개변수가 여러 개이거나 매개변수 이름이 길거라 할 경우에는 이처럼 고마운 것도
없습니다. 손가락도 덜 피곤하고 게다가 코드도 깔끔해지거든요. 위의 예제에서 이
걸 써먹어 봤습니다. operator* 함수의 선언부를 보시면 매개변수 타입과 반환
타입이 Rational<T>가 아니라 Rational로 되어 있죠. 사실 다음과 같이 선언
하더라도 똑깥은 의미입니다.

template<typename T>
class Rational
{
public:
	...
	// operator* 함수를 선언합니다(자세한 내용은 아래에 나와요)
	friend const Rational<T> operator*(const Rational<T>& lhs, 
							const Rational<T>& rhs);
	...
};

우리 마음속엔 이미 더 쓰기 쉬운(그리고 더 흔히 쓰이는) 줄임표기 형태가 살표시
자리잡고 있음을 느낄 수 있을 것입니다.

자, 다시 마음을 추스르고 링크 문제로 돌아옵시다. 지금의 혼합형 호출 코드는
컴파일까지는 잘 됩니다. 우리가 어떤 함수를 호출하려는지 컴파일러가 알 수 있게 
됐으니까요.(Rational<int> 두 개를 받아들이는 operator* 함수죠). 그런데 이 
함수는 Rational안에서 선언만 되어 있지, 거기에서 정의까지 되어 있는 것은 아
닙니다. 클래스 외부에 있는 operator* 템플릿에서 함수 정의를 제공하도록 만들
고 싶은 것이 우리들 의되였지만, 바람대로 일이 풀리지는 않았습니다. 어떤 함수
를 우리들이 직접 선언했으면(방금 Rational 템플릿 안에다가 한 일이 그거죠), 
그 함수를 정의하는 일도 우리가 직접 책임을 져야 하는 것입니다. 그런데도 함수 
정의는커녕 코빼기도 보이지 않으니, 링커가 못 찾는 게 당연하죠.

가장 간단하게 해결하려면, operator* 함수의 본문을 선언부와 붙이면 됩니다.

template<typename T>
class Rational
{
public:
	...
	// 항목 24의 그 코드 동일한 구현
	friend const Rational operator*(const Rational& lhs, 
							const Rational& rhs)
	{
		return Rational(lhs.numerator()*rhs.numerator(), 
		lhs.denominator()*rhs.denominator());
	}
};

드디어 끝까지 돌아가는 코드가 나왔습니다. operator* 함수의 혼합형 호출
코드가 이제는 컴파일도 되고, 링크도 되고, 실행도 됩니다.

이번 항목에서 필자가 보여드린 이 방법에는 재미있는 이야깃거리가 하나 숨어
있습니다. 프렌드 함수를 선언하긴 했지만, 클래스의 public 영역이 아닌 부분에
접근하는 것과 프랜드 권한은 아무런 상관이 없다는게 바로 그것입니다. 모든 인자에
대해 타입 변환이 가능하도록 만들기 위해 비멤버 함수가 필요하고(항목 24에서 이미
보신 내용입니다), 호출 시의 상황에 맞는 함수를 자동으로 인스턴스화하기 위해서는
그 비멤버 함수를 클래스 안에 선언해야 합니다. 공교롭게도, 클래스 안에 비멤버 
함수를 선언하는 유일한 방법이 '프렌드'였을 뿐입니다. 그래서 그렇게 한것이고요.
삐딱하죠? 그렇긴 합니다. 효과적이냐고요? 여부가 있겠습니까.

항목 30에서도 말씀드린 것 같은데요, 클래스 안에 정의된 함수는 암시적으로 인라인
으로 선언됩니다. 지금의 operator* 같은 프렌드 함수도 예외는 아니죠. 클래스의
바깥에서 정의된 도우미 함수만 호출하는 식으로 operator*를 구현하면 이러한 암시
적 인라인 선언의 영향을 최소화 할 수도 있습니다. 물론 이번 항목에서 보여드린 예
제에서는 그렇게 해 봤자 얻는 점수가 그다지 많진 않습니다. 이미 한 줄 함수로 구
현되어 있거든요. 하지만 꽤 복잡하게 작성된 함수 본문이 이런 식으로 끼어들어가
있다면 한번 해 봄직합니다. 이른바 "프렌드 함수는 도우미만 호출하게 만들기"
방법입니다. 잘 기억해 두세요.

Rational이 템플릿이란 사실을 놓고 살짝만 머리를 돌려보면 도무이 함수도 대개
템플릿일 것이라는 말도 됩니다. 그러고 보면, Rational을 정의하는 헤더 파일에
들어 있는 코드는 아마 다음과 같은 형태가 아닐까요?

template<typename T> class Rational;	// Rational 템플릿을 선언

// 도우미 함수 템플릿을 선언
template<typename T>
const Rational<T> doMultiply(const Rational<T>& lhs, 
							const Rational<T>& rhs);

template<typename T>
class Rational
{
public:
	...
	friend const Rational<T> operator*(const Rational<T>& lhs, 
							const Rational<T>& rhs)
	{
		// 프렌드 함수가 도우미 함수를 호출하게 만듭니다.
		return doMultiplay(lhs, rhs);								
	}
};

대다수의 컴파일러에서 템플릿 정의를 헤더 파일에 전부 넣을 것을 사실상 강제로
강요하다시파 하고 있으니, doMultiply도 헤더 파일 안에 정의해 넣어야 할 것
입니다(항목 30에서도 이야기 했지만, 이런 템플릿은 인라인일 필요가 없습니다).
아마 다음과 같은 형태이겠죠.

template<typename T>
const Rational<T> doMultiply(const Rational<T>& lhs, 
							const Rational<T>& rhs)
{
	return Rational<T>(lhs.numerator()*rhs.numerator(), 
	lhs.denominator()*rhs.denominator());
}

물론 doMultiplay는 템플릿으로서 혼합형 곱셈을 지원하지 못하겠지만, 지원할
필요가 없습니다. 이 템플릿을 상요하는 고객은 operator*밖에 없을 텐데,
operator*가 이미 혼한형 연산을 지원하고 있으니까요. operator* 함수는
자신이 받아들이는 매개변수가 제대로 곱해지도록 어떤 타입도 Rational 객체로
바꿔 주고, 이렇게 바꾼 Rational 객체 두개는 doMultiply 템플릿의 인스턴스가
받아서 실제 곱셈에 써먹는단 말씀입니다. 손발이 착착 맞지 않습니까, 아니라고요?

이것만은 잊지 말자!
*	모든 매개변수에 대해 암시적 타입 변환을 지원하는 템플릿과 관계가 있는 함수를
	제공하는 클래스 템플릿을 만들려고 한다면, 이런 함수는 클래스 템플릿 안에 프
	렌드 함수로서 정의합시다.