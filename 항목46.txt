항목 46: 타입 변환이 바람직할 경우에는 비멤버 함수를 클래스 템플릿 안에 정의해 두자.

모든 매개변수에 대해 암시적 타입 변환이 되도록 만들기 위해서는 비멤버 함수밖에 방법이
없다는, 이번 항목과 조금 비슷한 이야기는 이전에 항목 24에서 이유까지 말씀드린 바 있습
니다. 그 당시, Rational 클래스의 operator* 함수가 예제로 나왔었죠. 이번 항목을
편하게 읽어 가시려면 일단 이 예제를 눈에 잘 넣어두는 것이 좋습니다. 항목 24에 나온 그
예제를 한 번 더 살짝 우려내고 약간의 조미료를 친 것을 잘근잘근 씹으며 이야기를 넓혀갈
생각이거든요. 어떻게 할 것인고 하니, Rational 클래스와 oprator* 함수를 템플릿으로
만들 것입니다.

template<typename T>
class Rational
{
public:
	Rational(const T& numerator = 0,	// 매개변수가 참조자로 전달되는 이유는
			const T& denominator = 1);	// 항목 20을 보면 나옵니다.
	const T numerator() const;		// 반환값 전달이 여전히 값에 의한 전달인
	const T denominator() const;	// 이유는 항목 28을 보면 나오고요.
	...							// 이들 함수가 const인 이유는 항목 3에서...
};

template<typename T>
const Rational<T> operator*(const Rationa<T>& lhs, 
							const Rationa<T>& rhs){...}

항목 24에서도 그랬듯, 혼합형(mixed-mode) 수치 연산은 여전히 필요합니다. 다음의
코드가 컴파일되어야 하는 거죠. 그런데 이미 항목 24에서 동작하는 코드를 그대로 가져
왔기 때문에, 컴파일이 안 되는 게 더 이상할 것 같습니다. 차이점이라면 Rational 및
operator* 부분이 이제는 템플릿이라는 것밖엔 없으니까요.

Rational<int> oneHalf(1, 2);		// Rational이 이제 템플릿이란 것만 빼면
									// 이 예제는 항목 24의 것과 똑같습니다.

Rational<int> result = oneHalf * 2;// 그런데 에러입니다. 컴파일이 안되요.

컴파일이 되지 않는다는 사실로 미루어 볼때, 템플릿 버전의 Rational에는 템플릿이기
전의 버전과 다른 무언가가 있지 않을까 싶은데요, 실제로 있습니다. 항목 24에서는 우
리가 호출하려고 하는 함수가 무엇인지를 컴파일러가 알고 있지만(Rational 객체 두
개를 받는 operator* 함수였죠), 지금 경우에는 어떤 함수를 호출하려하는지에 대해
컴파일러로서는 아는 바가 전혀 없습니다. 단지, 컴파일러는 operator*라는 이름의
템플릿으로부터 인스턴스화할(다시 말해, 만들어낼) 함수를 결정하기 위해 온갖 계산을
동원할 뿐이랍니다. 이 시점에서 컴파일러가 확실히 하는 것은 Rational<T> 타입의
매개변수를 두 개 받아들이는 operator*라는 이름의 함수를 자신이 어떻게든 인스턴스
로 만들긴 해야 한다는 점입니다. 그러나 이 인스턴스화를 제대로 하려면 '대관절 T가
무었인고?'에 대한 수수께끼를 풀어야 합니다. 문제는 바로, 컴파일러 스스로는 이 수
수께끼를 풀 능력이 없다는 거죠.

T의 정체를 파악하기 위해, 컴파일러는 우선 operator* 호출 시에 넘겨진 인자의 모든
타입을 살핍니다. 지금의 경우에는 Rational<int>(oneHalf의 타입) 및 int(2의 타
입)입니다. 컴파일러는 이들을 하나씩 각개 격파해 갑니다.