항목 46: 타입 변환이 바람직할 경우에는 비멤버 함수를 클래스 템플릿 안에 정의해 두자.

모든 매개변수에 대해 암시적 타입 변환이 되도록 만들기 위해서는 비멤버 함수밖에 방법이
없다는, 이번 항목과 조금 비슷한 이야기는 이전에 항목 24에서 이유까지 말씀드린 바 있습
니다. 그 당시, Rational 클래스의 operator* 함수가 예제로 나왔었죠. 이번 항목을
편하게 읽어 가시려면 일단 이 예제를 눈에 잘 넣어두는 것이 좋습니다. 항목 24에 나온 그
예제를 한 번 더 살짝 우려내고 약간의 조미료를 친 것을 잘근잘근 씹으며 이야기를 넓혀갈
생각이거든요. 어떻게 할 것인고 하니, Rational 클래스와 oprator* 함수를 템플릿으로
만들 것입니다.

template<typename T>
class Rational
{
public:
	Rational(const T& numerator = 0,	// 매개변수가 참조자로 전달되는 이유는
			const T& denominator = 1);	// 항목 20을 보면 나옵니다.
	const T numerator() const;		// 반환값 전달이 여전히 값에 의한 전달인
	const T denominator() const;	// 이유는 항목 28을 보면 나오고요.
	...							// 이들 함수가 const인 이유는 항목 3에서...
};

template<typename T>
const Rational<T> operator*(const Rationa<T>& lhs, 
							const Rationa<T>& rhs){...}

항목 24에서도 그랬듯, 혼합형(mixed-mode) 수치 연산은 여전히 필요합니다. 다음의
코드가 컴파일되어야 하는 거죠. 그런데 이미 항목 24에서 동작하는 코드를 그대로 가져
왔기 때문에, 컴파일이 안 되는 게 더 이상할 것 같습니다. 차이점이라면 Rational 및
operator* 부분이 이제는 템플릿이라는 것밖엔 없으니까요.

Rational<int> oneHalf(1, 2);		// Rational이 이제 템플릿이란 것만 빼면
									// 이 예제는 항목 24의 것과 똑같습니다.

Rational<int> result = oneHalf * 2;// 그런데 에러입니다. 컴파일이 안되요.

컴파일이 되지 않는다는 사실로 미루어 볼때, 템플릿 버전의 Rational에는 템플릿이기
전의 버전과 다른 무언가가 있지 않을까 싶은데요, 실제로 있습니다. 항목 24에서는 우
리가 호출하려고 하는 함수가 무엇인지를 컴파일러가 알고 있지만(Rational 객체 두
개를 받는 operator* 함수였죠), 지금 경우에는 어떤 함수를 호출하려 하는지에 대해
컴파일러로서는 아는 바가 전혀 없습니다. 단지, 컴파일러는 operator*라는 이름의
템플릿으로부터 인스턴스화할(다시 말해, 만들어낼) 함수를 결정하기 위해 온갖 계산을
동원할 뿐이랍니다. 이 시점에서 컴파일러가 확실히 하는 것은 Rational<T> 타입의
매개변수를 두 개 받아들이는 operator*라는 이름의 함수를 자신이 어떻게든 인스턴스
로 만들긴 해야 한다는 점입니다. 그러나 이 인스턴스화를 제대로 하려면 '대관절 T가
무었인고?'에 대한 수수께끼를 풀어야 합니다. 문제는 바로, 컴파일러 스스로는 이 수
수께끼를 풀 능력이 없다는 거죠.

T의 정체를 파악하기 위해, 컴파일러는 우선 operator* 호출 시에 넘겨진 인자의 모든
타입을 살핍니다. 지금의 경우에는 Rational<int>(oneHalf의 타입) 및 int(2의 타
입)입니다. 컴파일러는 이들을 하나씩 확인해 갑니다.

oneHalf 쪽은 의외로 확인이 쉽습니다. operator*의 첫 번째 매개변수는 Rational
<T> 타입으로 선언되어 있고, 지금 operator*에 넘겨진 첫 번째 매개변수가 마침 또
Rational<int> 타입이기 때문에, T는 int일 수밖에 없습니다. 하지만 애석하게도 두
번째 매개변수 쪽은 타입을 유추해내기가 쉽지 않습니다. operator*의 선언을
보면 두 번째 매개변수가 Rational<T> 타입으로 선언되어 있는데, 지금 operator*
에 넘겨진 두 번째 매개변수(2)는 int 타입입니다. 이때 컴파일러는 어떻게 해야 T의
정체를 알아낼 수 있을까요? Rational<int>에는 explicit로 선언되지 않은 생성자가
들어 있다는 것을 확인한 독자라면, 혹시 컴파일러가 이 생성자를 써서 2를 Rational
<int>로 변환하고 이를 통해 T가 int라고 유추할 수 있지 않을까 하고 예상할 것 같
습니다만, 컴파일러는 그렇게 동작하지 못합니다. 그 이유는, (잘 알아두세요) 템플릿
인자 추론(template argument deduction) 과정에서는 암시적 타입 변환이 고려
되지 않기 때문입니다. 절대로 안됩니다. 이런 타입 변환은 함수 호출이 진행될 때 쓰
이는 것은 맞습니다. 그렇죠. 그러나 여러분이 함수를 호출할 수 있으려면 어떤 함수가
있는지를 여러분이 미리 알고 있어야 합니다. 게다가 호출되는 상황에 맞는 함수 템플릿
에 넣어 줄 매개변수 타입을 추론하는 일도(함수를 인스턴스화해야 하니 말이죠) 여러
분이 해야 합니다. 하지만, 다시 말씀드리지만 템플릿 인자 추론이 진행되는 동안에는
생성자 호출을 통한 암시적 타입 변환 자체가 고려되지 않습니다. 사실 항목 24에서는
템플릿이 거론되지 않았기 때문에, 템플릿 인자 추론 문제가 불거지지 않은 것뿐입니다.
지금은 C++의 템플릿 부분(뭔 소린지 헷갈리시나요? 항목 1 참조)에 와 있으므로,
이것이 아주 중대한 문제입니다.

*	템플릿 인자 추론(template argument deduction) 과정에서는 암시적 타입 
	변환이 고려되지 않는다. 절대로 안됩니다.
*	템플릿 인자 추론은 함수 템플릿에만 적용되는 과정입니다.

이처럼 힘든 처지에서 템플릿 인자 추론을 해야 하는 수고로부터 컴파일러를 해방시킬
수 있는 방법이 있습니다. 클래스 템플릿 안에 프렌드 함수를 넣어 두면 함수 템플릿
으로서의 성격을 주지 않고 특정한 함수 하나를 나타낼 수 있다는 사실을 이용하는 것
입니다. 다시 말해, Rational<T> 클래스에 대해 operator*를 프렌드 함수로 선언
하는 것이 가능하다는 이야기입니다. 클래스 템플릿은 템플릿 인자 추론 과정에서 좌
우되지 않으므로, T의 정확한 정보는 Rational<T> 클래스가 인스턴스화될 당시에
바로 알 수 있습니다. 그렇기 때문에, 호출 시의 정황에 맞는 operator* 함수를 
프렌드로 선언하는 데 별 어려움이 없는 것입니다.

template<typename T>
class Rational
{
public:
	...
	// operator* 함수를 선언합니다(자세한 내용은 아래에 나와요)
	friend const Rational operator*(const Rational& lhs, 
							const Rational& rhs)
};

// operator* 함수를 정의합니다.
template<typename T>
const Rational<T> operator*(const Rational<T>& lhs, 
							const Rational<T>& rhs){...}

이제 여러분은 혼합형 operator* 호출이 컴파일되는 코드를 보고 계십니다. 
oneHalf 객체가 Rational<int> 타입으로 선언되면 Rational<int> 클래스가 
인스턴스로 만들어지고, 이때 그 과정의 일부로서 Rational<int> 타입의 매개변
수를 받는 프렌드 함수인 opertator*도 자동으로 선언되기 때문입니다. 이전과
달리 지금은 함수(Rational의 비명시 호출 생성자 등)를 적용할 수 있게 되는
것이죠. 컴파일에 성공하는 이유는 이게 전부입니다.
하지만 이 코드는 컴파일은 되지만, 링크가 안됩니다. 이 문제는 조금 있다가 
바로 잡겠습니다만, 우선 필자는 Rational 안에 operator*를 선언하는데 
사용한 문법에 대해 몇 가지 말씀 드리고 싶습니다.