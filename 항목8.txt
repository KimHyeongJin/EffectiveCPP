항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

소멸자로부터 예외가 발생 한 경우 C++ 언어에서 해결해 주지는 않지만, 실제 상황을
들춰보면 확실히 우리가 해결할 수 밖에 없는 것 같습니다. 납득할 만한 명분도 있고요 아래의
예를 봅시다.

class Widget
{
public:
	...
	~Widget(){...}	// 이 함수로 부터 예외가 발생된다고 가정합니다.
};

void doSomething()
{
	std::vector<Widget> v;
	...
}		// v는 여기서 자동으로 소멸됩니다.

vector 타입의 객체 v, 다시 말해 벡터 v가 소멸될 때, 자신이 담고 있는 Widget
들 전부를 소멸시킬 책임은 바로 이 벡터에게 있겠지요. v에 들어 있는 Widget이 10개인
데, 첫 번째 것을 소멸시키는 도중에 예외가 발생되었다고 가정합시다. 나머지 9개는 여
전히 소멸되어야 하므로(그렇지 않으면 Widget이 가지고 있을지 모를 자원이 누출됩니디), 
v는 이들에 대해 소멸자를 호출해야 할 것입니다. 그런데 이 과정에서 문제가 또 터졌다고 
가정합시다. 두 번째 Widget의 소멸자에서 예외가 던져지면 어떻게 될까요? 현재
활성화된 예외가 동시에 두 개나 만들어진 상태이고, C++의 입장에서는 감당하기에 버겁습
니다. 이 두 예외가 동시에 발생한 조건이 어떤 미묘한 조건이냐에 따라 프로그램 실행이
종료되든지 아니면 정의되지 않은 동작을 보이게 될 텐데, 이 경우에는 프로그램 실행이 정의되
지 않은 동작을 보입니다. 다른 표준 라이브러리 컨테이너(이를테면 list나 set) 라든지
TR1(항목 54 참조)의 컨테이너를 쓰더라도 결과는 마찬가지이며, 심지어 배열을 써도 마찬가
지입니다. 그런데 컨테이너나 배열을 썼기 때문에 이런 말썽이 생긴 것이 이닙니다. 완전하
지 못한 프로그램 종료나 미정의 동작의 원인은 바로 예외가 터져 나오는 것을 내버려 두
는 소멸자에게 있습니다. 심지어 컨테이너나 배열을 쓰지 않아도 말이죠. C++는 예외를 내
보내는 소멸자를 좋아하지 않는단 말입니다!

방금 이야기만 이해하고 말 문제라면 이것으로도 쉽게 끝이겠지만 예외를 던지고 실패할 수
있는 코드를 소멸자에 넣어야 할 사람이 혹시 여러분이라면 어떻게 히시겠어요? 이해가 안 된
고요? 그럼, 여러분이 데이터베이스 연결을 나타내는 클래스를 쓰고 있다고 가정하고 이야
를 계속하겠습니다.

class DBConnection
{
public:
	...
	static DBConnection create();	// DBConnection 객체를 반환하는 함수,
									// 매개변수는 편의상 생략
	void close();					// 연결을 닫습니다. 이때 연결이 실패하면
									// 예외를 던집니다.
};

보다시피 사용자가 DBConnection 객체에 대해 close를 직접 호출해야 하는 설계입니
다. 사용자의 망각을 사전에 차단하는 좋은 방법이라면 DBConnection에 대한 자원 관리
클래스를 만들어서 그 클래스의 소멸자에서 close를 호출하게 만드는 것이겠지요. 이런 자
원 관리 클래스는 3장에서 충분히 다루고 있지만, 여기서는 일단 자원 관리 클래스의 소멸
자가 어떤 형태인지만 살펴보겠습니다. 아래를 보시죠.

class DBConn		// DBConnection 객체를 관리하는 클래스
{
public:
	...
	~DBConn()		// 데이터베이스 연결이 항상 닫히도록 확실히 챙겨주는 함수
	{
		db.close();
	}
private:
	DBConnection db;
};

여러 분의 감동스런 배려 덕택에 다음과 같은 프로그래멍이 가능해집니다.

{	// 블록 시작
	DBConn dbc(DBConnection::create());	// DBConnection 객체를 생성하고
										// 이것을 DBConn 객체로 넘겨서 관리
										// 를 맡깁니다.
	...	// DBConn 인터페이스를 통해 그 DBConnection 객체를 사용합니다.

}		// 블록 끝, DBConn 객체가 여기서 소멸됩니다. 따라서 DBConnection 객체에
		// 대한 close 함수의 호출이 자동으로 이루어집니다.

close 호출만 일사천리로 성공하면 아무 문제될 것이 없는 코드입니다. 그러나 close를
호출했는데 여기서 예외가 발생했다고 가정하면 어떻게 될까요? DBConn의 소멸자는 분명
히 이 예외를 전파할 것입니다. 쉽게 말해 그 소멸자에서 예외가 나가도록 내버려 둔다는
거죠. 바로 이것이 문제입니다. 예외를 던지는 소멸자는 곧 '걱정거리'를 의미하기 때문입니다.

걱정거리를 피하는 방법은 두 가지입니다. DBConn의 소멸자는 이 둘 중 하나를 선택할 수
있고요.

* close에서 예외가 발생하면 프로그램을 바로 끝냅니다. 대개 abort를 호출합니다.
DBConn::~DBConn()
{
	try{db.close();}
	catch(...)
	{
		...	//close 호출이 실패하는 로그를 작성합니다.
		std::abort();
	}
}

객체 소멸이 진행되다가 에러가 발생한 후에 프로그램 실행을 계속할 수 없는 상황이라면
꽤 괜찮은 선택입니다. 소멸자에서 생긴 예외를 그대로 흘려 내보냈다가 정의되지 않은
동작에까지 이를 수 있다면, 그런 불상사를 막는다는 의미에서 어느 정도 장점도 있습니
다. 간단히 말해, abort를 호출해서 못 볼꼴을 미리 안 보여 주겠다는 의도죠.

* close를 호출한 곳에서 일어난 예외를 삼켜 버립니다.
DBConn::~DBConn()
{
	try{db.close();}
	catch(...)
	{
		...	//close 호출이 실패하는 로그를 작성합니다.
	}
}

대부분의 경우에서 예외 삼키기는 것은 그리 좋은 발상이 아닙니다. 무엇이 잘못됬는지를 
알려 주는 중요한 정보가 묻혀 버리기 때문입니다.  하지만 때에 따라서는 불완전한
프로그램 종료 혹은 미정의 동작으로 인해 입는 위험을 감수하는 것보다 그냥 예외를 먹어
버리는 게 나을 수도 있습니다. 단, '예외 삼키기'를 선택한 것이 제대로 빛을 보려면, 발생
한 예외를 그냥 무시한 뒤라도 프로그램이 신뢰성 있게 실행을 지속할 수 있어야 합니다.

써놓긴 했지만 어느 쪽을 택하든 특별히 좋을 건 없어 보입니다. 둘 다 문제점이 있기 때문
입니다. 중요한 것은 close가 최초로 예외를 던지게 된 요인에 대해 프로그램이 어떤 조
를 취할 수 있는가인데, 이런 부분에 대한 대책이 전무한 상태이니까요.

더 좋은 전략을 고민해 보도록 하죠. DBConn 인터페이스를 잘 설계해서, 발생할 소지가
있는 문제에 대처할 기회를 사용자가 가질 수 있도록 하면 어떨까요? 이를테면, DBConn에
서 close 함수를 직접 제공하게 하면 이 함수의 실행 중에 발생하는 예외를 사용자가 직
접 처리할 수 있을 것입니다. DBConnection이 닫혔는지의 여부를 유지했다가, 닫히지
않았으면 DBConn의 소멸자에서 닫을 수도 있을 것이고요. 이렇게 하면 데이터베이스 연결
이 누출되지 않습니다. 하지만 소멸자에서 호출하는 close 마저 실패한다면(그래서 예외가
일어나면),'끝내거나 혹은 삼켜 버리거나' 모드로 다시 돌아올 수밖에 없지요.

class DBConn
{
public:
	...
	void close()	// 사용자 호출을 배려(?)해서 새로 만든 함수
	{
		db.close();
		closed = true;
	}

	~DBConn()		// 데이터베이스 연결이 항상 닫히도록 확실히 챙겨주는 함수
	{
		if(!closed)
		{
			try{ db.close(); }	// 사용자가 연결을 안 닫았으면 여기서 닫는다.
		}
		catch(...)	// 연결을 닫다가 실패하면, 실패를 알린 후에 실행을 끝내거라
		{			// 예외를 삼킵니다.
			// close 호출이 실패했다는 로그를 작성
			...
		}
	}
private:
	DBConnection db;
	bool closed;
};

close 호출의 책임을 DBConn의 소멸자에서 DBConn의 사용자로 떠넘기는(DBConn의 소
멸자엔 '확인사살' 코드를 두고) 이런 아이디어는 자칫 무책임한 책임 전가로 보일 수도 있습니
다. 항목 18을 미리 읽은 독자는 "제대로 쓰기에 쉬운 인터페이스를 만들라"라는 조언을 어
긴 것 같다고 느낄지도 모르고요. 이쯤 되면 오해를 풀어드려야 하겠죠? 어느 쪽도 아닙니
다. 어떤 동작이 예외를 일으키면서 실패할 가능성이 있고 또 그 예외를 처리해야 할 필요
가 있다면, 그 예외는 소멸자가 아닌 다른 함수에서 비롯된 것이어야 한다는 것이 포인트입니다.
이유는 이번 항목에서 말씀드렸죠? 예외를 일으키는 소멸자는 시한폭탄이나 마찬가지라서
프로그램의 불완전 종료 혹은 미정의 동작의 위험을 내포하고 있기 때문입니다. 위의 예제
코드를 다시 한 번 보세요. 사용자가 호출할 수 있는 close 함수를 두긴 했지만 부담을
떠넘기는 모양새가 아닙니다. 사용자에게 에러를 처리할 수 있는 기회를 주는 것이죠. 이것
마저 없다면 사용자는 예외에 대처할 기회를 못 잡게 됩니다. 물론, 굴러 들어온 기회를 사
용자 쪽에서 오버헤드킥으로 받아넘길 수도 있어요(잘못될 리가 없다고 철석 같이 믿는 사용자
도 있잖아요) 그냥 무시해도 됩니다. 그래도 DBConn의 소멸자에서 어떻게든 마무리해 줄
거라는 믿는 구석이 있으니까요. 구체적으로는 close를 호출해 줄 것입니다. 이제 그 부분
에서 뭔가 잘못되었다고 하면(즉, 소멸자에서 호출된 close에서 예외를 던진다면) DBConn 이
예외를 삼켜 버리든 프로그램을 갑작스럽게 끝내든 사용자 쪽은 불평할 자격이 없게 됩니다.
어찌 되었든 문제 해결의 칼자루를 먼저 쥔 쪽은 사용자이고, 칼을 뽑지 않기로 결정한 쪽
역시 사용자이니까요.

이것만은 잊지 말자!
*	소멸자에서는 예외가 빠져나가면 안 됩니다. 만약 소멸자 안에서 호출된 함수가 예외를
	던질 가능성이 있다면, 어떤 예외이든지 소멸지에서 모두 밭아낸 후에 심켜 버리든지 프로그
	램을 끝내든지 해야 합니다.
*	어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면,
	해당 연산을 제공하는 함수는 반드시 보통의 함수(즉, 소멸자가 아닌 함수)이어야 합니다. 