항목 14: 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자

항목 13, 잘 읽으셨나요? 자원 관리 클래스의 주축을 이루는 아이디어인 자원 획득 즉, 초기화 (RAII) 기법을 공부했고, 
힙 기반 자원에 대해 이 아이디어를 명쾌하게 적용한 auto_ptr 및 tr1::shared_ptr 클래스와 즐겁게 인사도 나누셨을 겁니다. 
그런데 이것만 해서 모든 문제가 끝났으면 얼마나 좋겠습니까만, 세상의 자원이 모두 힙에서 생기지는 않는다는 현실이 다시금 
우리네 마음을 메마르게 합니다. 사실, 힙에 생기지 않는 자원은 auto_ptr 혹은 tr1::shared_ptr 등의 스마트 포인터로 처리해 
주기엔 맞지 않다는 것이 일반적인 견해이죠. 항상 그런 것은 아니지만, 자원 관리 클래스를 여러분 스스로 만들어야 할 필요를 
느끼는 경우가 바로 이런 경우입니다.

예를 하나 들어 보죠. Mutex 타입의 뮤텍스 객체를 조작하는 C API를 여러분이 사용하는 중이라고 가정합시다. 이 C API에서 
제공하는 함수 중엔 lock 및 unlock이 있고요.

void lock(Mutex *pm); // pm이 가리키는 뮤텍스에 잠금을 겁니다.
void unlock(Mutex *pm) ; // pm이 가리키는 해당 뮤텍스의 잠금을 풉니다.

그런데 뮤텍스 잠금을 관리히는 클래스를 하나 만들고 싶습니다. 이전에 걸어 놓은 뮤텍스 잠금을 잊지 않고 풀어 줄 목적인 거죠. 
이런 용도의 클래스는 기본적으로 RAII 법칙을 따라 구성합니다. 즉, 생성시에 자원을 획득하고 소멸시에 그 자원을 해제하는 것입니다.

class Lock
{
	public : 
	explicit Lock(Mutex *pm) : mutexPtr(pm) 
	{
		lock(mutexPtr); // 자원을 획득합니다.
	} 
	~Lock() { unlock(mutexPtr); } // 자원을 해제합니다.	
	private: 
	Mutex *mutexPtr; 
}

사용자는 Lock을 사용할 때 RAII 방식에 맞추어 쓰면 됩니다.

Mutex m; // 여러분이 쓰고 싶은 뮤텍스를 정의합니다.
...
{					// 임계 영역을 정하기 위해 블록을 만둡니다. 
	Lock m1(&m);	// 뮤텍스에 잠금을 겁니다.
	...				// 입계 영역에서 할 연산을 수행합니다. 
}					// 블록의 끝입니다. 뮤텍스에 걸렸던 잠금이 자동으로 풀립니다.

여기까지만 보면 앞으로도 잘 될 것 같습니다. 그런데 Lock 객체가 복사된다면 어떻게 해야 할까요?

Lock m11(&m);	// m에 잠금을 겁니다.
Lock m12(ml1);	// m11을 m12로 복사합니다. 어떻게 되어야 맞을까요?
  
사실 이 질문은 약간 더 일반화해서 이렇게 정리할 수 있습니다. RAII 클래스를 만들어 본 사람이면 한 번쯤 고민 꽤나 했을 그런 질문이기도 하죠 바로. 
"RAII 객체가 복사될 때 어떤 동작이 이루어져야 할까요?"입니다. 아마도 열에 아흡은 다음의 선택지 중 하나를 골라 잡고 싶을 겁니다.

*복사를 금지합니다. 
실제로, RAII 객체가 복사되도록 놔두는 것 자체가 말이 안되는 경우가 꽤 많습니다. 위의 Lock 같은 클래스도 이런 부류에 속할 것 같습니다. 
어떤 스레드 동기화 객체에 대한 '사본'이라는 게 실제로 거의 의미가 없으니까요. 복사하면 안되는 RAII 클래스에 대해서는 반드시 복사가 되지 않도록 막아야 합니다. 
복사를 막는 방법은 항목 6을 참고하시면 되는데요 골자만 말씀드리면 복사 연산(함수)을 private 멤버로 만드는 것입니다. 자, 그럼 Lock 클래스에 
복사 방지를 걸어 보도록 합시다. 다음의 표를 봐 주세요.

class Lock : private Uncopyable // 복사를 금지합니다. 참고로 항목 6을 보시기 바랍니다. 
{
	public:
	...							// 이전과 같습니다. 
};

*관리하고 있는 자원에 대해 참조 카운팅을 수행합나다. 
지원을 사용하고 있는 마지막 객체가 소멸될 때까지 그 자원을 저 세상으로 안 보내는 게 바람직할 경우도 종종 있습니다. 이럴 경우에는, 
해당 자원을 참조하는 객체의 개수에 대한 카운트를 증가시키는 식으로 RAII 객체의 복사 동작을 만들어야 합니다. 참고로, 이런 방식은 현재 tr1::shared_ptr이 
사용하고 있습니다. 지금 좋은 생각이 떠오른 분이 있을 것 같네요. 자신의 RAII 클래스에 참조 카운팅 방식의 복사 통작을 넣고 싶을 때 tr1::shared_ptr을 
데이터 멤버로 넣으면, 간단히 해결되겠죠? 그러니까 Lock이 참조 카운팅 방식으로 돌아가면 좋을것 같다고 생각했다면, mutexPtr의 타입을 Mutex*에서 
tr1::shared_ptr<Mutex>로 바꾸라는 것입니다. 단, 아쉽게도 tr1::shared_ptr은 참조 키운트가 0이 될 때 자신이 가리키고 있던 대상을 삭제해 버리도록 
기본 동작이 만들어져 있어서, 우리의 바람과는 다소 어긋납니다. Mutex를 다 썼을 때 이것에 대해 잠금 해제만 하면 되지, 삭제까지 하고 싶진 않거든요.

참으로 다행스러운 것은 tr1::shared_ptr이 '삭제자(deleter)' 지정을 허용한다는 사실입니다. 여기서 삭제자란, tr1::shared_ptr이 유지하는 참조 카운트가 0이 되 었을 때 
호출되는 함수 혹은 함수 객체를 일컫습니다(반면, auto_ptr에는 이 기능이 없어서, auto_ptr은 포인터를 바로 삭제해 버립니다). 삭제자는 tr1::shared_ptr 생성자의 
두 번째 매개변수로 선택적으로 넣어 줄 수 있습니다. 자, 이제 이것을 활용해서 바꾼 코드를 보시겠습니다.

class Lock
{
	public : 
	explicit Lock(Mutex *pm) : mutexPtr(pm, unlock)//shared_ptr을 초기화 하는데, 가리킬 포인터로 Mutex 객체의 포인터를 사용하고 삭제자로 unlock 함수를 사용합니다.
	{
		lock(mutexPtr.get()); // "get"의 이야기는 항목 15에서 확익하세요.
	}
	private: 
											//소멸자가 없다?
	std::tr1::shared_ptr<Mutex> mutexPtr;	//원시 포인터 대신에 shared_ptr을 사용합니다.
}

이 예제에서 눈 부릅뜨고 보실 부분은 Lock 클래스가 이제는 소멸자를 선언하지 않는 다는 점입니다. 이유는 간단합니다 필요 없으니까요. 
항목 5를 읽으신 분은 알겠지만 클래스의 소멸자(컴파일러가 만들었든 사용자가 정의했든)는 비정적 데이터 멤버의 소멸자를 자동으로 호출하게 되어 있습니다. 
이 '비정적 데이터 멤버'에 해당하는 것이 mutexPtr입니다. 자, 그런데 mutexPtr의 소멸자는 뮤텍스의 참조 카운트가 0이 될 때 tr1::shared_ptr의 삭제자(현재의 경우엔 
unlock이죠)를 자동으로 호출할 거라 이겁니다(이런 코드에는 주석문으로 "객체 소멸 과정을 잊은 게 아니라 컴파일러가 생성한 소멸자를 통해 동작한다" 정도의 설명을 
달아두시면 다른 사람들이 참 행복해 할 겁니다).

*관리하고 있는 자원을 진짜로 복사합니다. 
때에 따라서는 자원을 원하는 대로 복사할 수도 있습니다. 이때는 '자원을 다 썼을 때 각각의 사본을 확실히 해제하는 것'이 자원 관리 클래스가 필요한 유일한 명분이 되는 것이죠. 
자원 관리 객체를 복사하면 그 객체가 둘러싸고 있는 자원까지 복사되어야 합니다. 즉, '깊은 복사(deep copy)'를 수행해야 한다는 이야기입니다.
몇몇 구현환경에서 표준 string 타입을 구현해 놓은 모습을 보면, 문자열을 구성하는 원소들을 힙 메모리에 저장해 놓고 이 메모리에 대한 포인터를 데이터 멤버로 갖고 있는 
경우를 종종 보게 됩니다. 이렇게 설계된 string 타입으로 생성한 객체는 결국 힙 메모리를 포인터로 물고 있는 형태가 되지요. 이때 이 객체를 복사하면, 사본은 포인터 및 
그 포인터가 가리키는 (새로운) 힙 메모리를 갖게 됩니다. 깊은 복사를 보여주는 한 예라 할 수 있습니다.

*관리하고 있는 자원의 소유권을 옮깁니다. 
그리 흔한 경우는 아니지만, 어떤 특정한 자원에 대해 그 자원을 실제로 참조하는 RAII 객체는 딱 하나만 존재하도록 만들고 싶어서, 그 RAII 객체가 복사될 때 그 자원의 
소유권을 사본 쪽으로 아예 옮겨야 할 경우도 살다 보면 생깁니다. 이런 스타일의 복사는 이미 항목 13에서 보신 바 있습니다. 바로 auto_ptr의 '복사' 동작이죠.

객체 복사 함수(복사 생성자 및 복사 대입 연산)는 컴파일러에 의해 생성될 여지가 있기 때문에, 컴파일러가 생성한 버전의 동작이 여러분이 원한 바와 맞지 않으면(어떻게 
동작하는지는 항목 5에서 확인하세요), 여러분이 객체 복사 함수를 직접 만들 수밖에 없습니다. 또 경우에 따라서는 이들 함수의 일반화 버전도 지원하고 싶을 수도 있는데, 
어떤 버전인지는 항목 45에 잘 설명해 두었으니 참고하도록 하십시오.

이것만은 잊지 말자!
* RAII 객체의 복사는 그 객체가 관리하는 자원의 복사 문제를 안고 가기 때문에, 그 자원을 어떻게 복사하느냐에 따라 RAII 객체의 복사 동작이 결정됩니다.
* RAII 클래스에 구현하는 일반적인 복사 동작은 복사를 금지하거나 참조 카운팅을 해주는 선으로 마무리하는 것입니다. 하지만 이 외의 방법들도 가능하니 참고해 둡시다.