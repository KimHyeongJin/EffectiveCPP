항목 29: 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자!

예외 안전성(exception safety)을 확보하는 것은 매우 힘든 작업입니다.

예쁜 배경그림을 깔고 나오는 GUI 메뉴를 구현하기 위해 클래스를 하나 만든다고 가정합시
다. 이 클래스는 스레딩 환경에서 동작할 수 있도록 설계되었기 때문에, 병행성 제어를 위해
뮤텍스(mutex)를 갖고 있습니다. 자 일단 보시죠.class PrettyMenu{public:	...	void changeBackground(std::istream& imgSrc);// 배경그림을 바꾸는 멤버 함수	...private:	Mutex mutex;	// 이 객체 하나를 위한 뮤텍스	Image* bgImage;	// 현재의 배경그림	int imageChange;	// 배경그림이 바뀐 횟수};여기서 PrettyMenu의 changeBackground 함수가 디음과 같이 구현되었다고 생각해
보세요.

void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	lock(&mutex);	// 뮤텍스를 획득합니다(항목 14와 같아요).
	delete bgImage;	// 이전의 배경그림을 없앱니다.
	++imageChange;	// 그림 변경 횟수를 갱신합니다.
	bgImage = new Image(imgSrc);	// 새 배경그림을 깔아 놓습니다.
	unlock(&mutex);	// 뮤텍스를 해제합니다.
}

예외 안전성이라는 측면에서 볼 때 이 함수는 "이보다 더 나뿔 수는 없다"고 말하고 싶네
요. 일반적으로 예외 안전성을 확보하려면 두 가지의 요구사항을 맞추어야 히는데, 이 함수
는 어느 요구사항에도 맞지 않는, 위험천만의 함수입니다.

예외 안전성을 가진 함수라면 예외가 발생할 때 이렇게 동작해야 합니다.

*	자원이 새도록 만들지 않습나다. 
	그런데 위의 코드는 자원이 샙니다. 왜냐하면 "new Image(imgSrc)" 표현식
	에서 예외를 던지면 unlock 함수가 실행되지 않게 되어	뮤텍스가 계속 잡힌 상태로 
	남기 때문입니다.

*	자료구조가 더럽혀지는 것을 허용하지 않습니다. 
	그런데 위의 코드에서 "new Image(imgSrc)"가 예외를 던지면 bgImage가 가리키는 
	객체는 이미 삭제된 후입니다. 그뿐인가요? 새 그림 이 제대로 깔린 게 아닌데도 
	imageChanges 변수는 이미 증가되었을 것이고요(이전의 그림이 없어진 것은 확실하기 
	때문에, 그림이 '바뀐'건 맞지 않느냐며 쌍심지를 세우는 분들도 충분히 감안한 
	발언입니다).

자원 누출 문제는 맞서 싸우기가 그렇게 까다로운 것은 아닙니다. 객체를 써서 자원 관리를
전담케 하는 방법을 항목 13에서 읽으시고, 항목 13의 아이디어를 살려 뮤텍스를 적절한 시
점에 해제하는 방법을 구현한 Lock 클래스를 항목 14에서 접하셨으면, 그대로 따라하시는
것으로 바로 마무리되니까요.

void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	Lock m1(&mutex);	// 항목 14에서 가져왔습니다: 뮤텍스를 대신 획득하고
						// 이것이 필요 없어질 시점에 바로 해제해 주는 객체입니다.
	delete bgImage;
	++imageChange;
	bgImage = new Image(imgSrc);
}

Lock 등의 자원관리 전담 클래스를 쓰면 가장 좋은 점 중 하나는 함수의 코드 길이가 짧
아진다는 것입니다. 보세요. 지금은 unlock을 호출할 필요가 없죠? 늘 그런 건 아니겠지
만, 대개 코드는 적을수록 좋잖아요. 어긋날 일도 적어질 것이고? 뭔가를 바꿨을 때 잘못 이
해할 것도 적어질 테니까요.

이렇게 해서 일단 자원 누출 문제는 꼬리를 내렸습니다. 이제 다음 판에서 만날 상대자는
자료구조 오염 문제입니다. 여기서는 선택을 좀 해야 하는데요, 일단 그전에 우리가 고를 수
있는 이 무엇 인지를 제대로 파악하기 위해 용어 공부가 좀 필요할 것 같습니다.

예외 안전성을 갖춘 함수는 아래의 세 가지 보장(guarantee) 중 하나를 제공합니다.

*	기본적인 보장(basic guarantee) 함수 동작 중에 예외가 발생하면, 실행 중인 
	프로그램에 관련된 모든 것들을 유효한 상태로 유지하겠다는 보장입니다. 어떤 객체나 
	자료구조도 더럽혀지지 않으며, 모든 객체의 상태는 내부적으로 일관성을 유지하고 
	있습니다(즉, 모든 클래스 불변속성이 만족된 상태입니다). 하지만 프로그램의 상태가 
	정확히 어떠한지는 예측이 안 될 수도 있습니다. 예를 들어, changeBackground 
	함수가 동작하다가 예외가 발생했을 때 PrettyMenu 객체는 바로 이전의 배경그림을 
	그대로 계속 그릴 수도 있고, 아니면 처음부터 마련해 둔 기본 배경그림을 사용할 
	수도 있을 것입니다. 이 부분은 전적으로 함수를 만든 사람에 달려 있지요. 하지만 
	사용자 쪽에서는 어떻게 될지 예측할 수 없습니다(알아내려면, 현재의 배경그림이 무엇인
	지를 알려 주는 다른 맴버 함수를 호출하든지 해야겠지요).

*	강력한 보장(strong guarantee) 함수 동작 중에 예외가 발생하면, 프로그램의 
	상태를 절대로 변경하지 않겠다는 보장입니다. 이런 함수를 호출하는 것은 원자적인(a-
	tomic) 동작이라고 할 수 있습니다. 호출이 성공하면(예외가 발생하지 않으면) 마무리
	까지 완벽하게 성공하고, 호출이 실패하면 함수 호출이 없었던 것처럼 프로그램의 상태가 
	되돌아간 다는 면에서 말이죠.

	'쓰기 편한가'의 측면에서 보면 강력한 보장을 제공하는 함수가 기본 보장을 제공히는
	함수보다 더 쉽습니다. 예측할 수 있는 프로그램의 상태가 두 개밖에 안 되기 때문입니
	다. 그러니까 함수가 성공적으로 실행을 마친 후의 상태, 아니면 함수가 호출될 때의
	상태만이 존재하는 거죠. 이와 대조적으로 함수가 기본 보장을 제공할 경우에는, 예외
	발생 시에 프로그램이 있을 수 있는 상태가 그냥 유효하기만 하면 어떤 상태도 될 수
	있습니다.

*	예외불가 보장(nothrow guarantee) 예외를 절대로 던지지 않겠다는 보장입니다. 
	약속한 동작은 언제나 끝까지 완수하는 함수라는 뜻이죠. 기본제공 타입(int , 포인터 
	등)에 대한 모든 연산은 예외를 던지지 않게 되어 있습니다(즉, 예외불가 보장이 제공
	됩니다). 예외에 안전한 코드를 만들기 위한 가장 기본적이며 핵심적인 요소가 아닐까 
	싶네요.

	어떤 예외도 던지지 않게끔 예외 지정이 된 함수는 예외불가 보장을 제공한다고 생각
	해도 일견 맞을 것 같지만, 잘못 생각하신 겁니다 아래의 예를 보세요.

	int doSomething() throw();	// 비어 있는 예외 지정

	위의 함수 선언이 전하는 메시지는 doSomething이 절대로 예외를 던지지 않겠다는 
	말이 아닙니다. 만약 doSomething에서 예외가 발생되면 매우 심각한 에러가 생긴 
	것으로 판단되므로, 지정되지 않은 예외가 발생했을 경우에 실행되는 처리자인 
	unexpected 함수가 호출되어야 한다는 뜻입니다.+4) 사실 doSomething은 어떤 예외 
	안전성 보장도 제공하지 않을 수도 있습니다. 함수 선언문에는(예외 지정이 붙어 있으면 
	이것도 포함됩나다) 해당 함수가 맞는지, 이식성이 있는지, 아니면 효율적인지 알려 주는 
	기능 같은 것이 없습니다. 예외 안전성 보장을 제공하는지도 당연히 알려 주지 않습니다. 
	함수가 어떤 특성을 갖느냐 하는 부분은 '구현'이 결정하는 것입니다. '선언'은 그냥 
	선거공약 같은 거라고요.

앞에서 말했지만, 예외 안전성을 갖춘 함수는 위의 세 가지 보장 중 하나를 반드시 제공해
야 합니다. 아무 보장도 제공하지 않으면 예외에 안전한 함수가 아닙니다. 따라서 여러분이
'선택'해야 하는 것은 '아떤 보장을 제공할 것인가'이겠습니다. 예외 안전성이 없는 재래식
(legacy) 코드를 사용해서 작업할 때를 제외하면(이 부분에 대한 이야기는 이번 항목의 
뒷부분에서 따로 하겠습니다), 예외 안전성을 제공하지 않는 쪽으로 선택해도 되는 경우는 
제 정신으론 일하기 힘든 요구사항 분석담당팀에서 여러분의 제품을 돌려보면서 자원을 
누출시키며 자료구조를 오염시킬 수 있도록 달라고 요청해 올 때 말고는 없습니다.

위의 세 가지 보장 중에 하나를 고르라면 아무래도 실용성이 있는 강력한 보장이 괜찮아 보
일 것입니다. 예외 안전성의 관점에서 보면 예외불가 보장이 가장 훌륭하겠지만, 예외를 던
지는 함수를 호출하지 않고 C++의 C 부분으로부터 벗어나오기란 힘들거든요. 일단 동적
할당 메모리를 시용하는 쪽(STL 컨테이너가 실제로 그렇습니다)만 보아도, 요청에 맞는 메모리
를 확보할 수 없으면 bad_alloc 예외를 던지 도록 구현되어 있지 않습니까(항목 49 참조).
뭐 할 수 있으면 예외불가 보장을 제공하세요. 하지만 현실적으로는 대부분의 함수에 있어
서 기본적인 보장과 강력한 보장 중 히나를 고르게 됩니다.

changeBackground 함수를 다시 들여다보도록 하죠. 이 함수의 경우엔 강력한 보장을
거의 제공하는 것은 그다지 어렵지 않습니다. 우선 첫째로, PrettyMenu의 bgImage 데
이터 멤버의 타입을 기본제공 포인터 타입인 Image*에서 자원관리 전담용 포인터(항목 13
에서 봤었죠)로 바꿉니다. 정말이지 자원 누출을 막는 대책으로 본다면 이렇게 가는 게 딱
맞습니다. 사용자에게 강력한 예외 안전성 보장을 제공할 수 있게 만든 것뿐인데 '객체(스마
트 포인터 등)를 써서 자원을 관리하는 것이 좋은 설계의 첫걸음'이라고 울부짖은 바 있는
항목 13의 내용을 다시금 확인하는 셈이 되었지요. 뒤에서 보실 코드에서 필자는 자원관리
용 객체로 tr1::shared_ptr을 쓸 겁니다. auto_ptr도 있긴 하지만, 복사될 때의 동
작이 더 직관적이라 사용하기가 더 좋거든요.

+	unexpected 함수에 대한 자세한 사항을 알고자 하는 분들은 즐겨 사용하시는 검색 
	엔진을 이용하거나 C++를 진반적으로 다룬 참고서를 읽어 보시기 바랍니다(운이 좋으신 
	분은 이 함수를 찾아보다가 set_unexpected 함수도 발견할지 모르겠습니다. 이 함수	는 unexpected 함수로 사용할 실제 함수를 설정하는 용도로 쓰입니다).4)	"MEC++"의 항목 14를 참고하거나 "TC++PL"의 14장을 참고하자-옮긴이