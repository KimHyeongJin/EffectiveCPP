항목 29: 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자!

예외 안전성(exception safety)을 확보하는 것은 매우 힘든 작업입니다.

예쁜 배경그림을 깔고 나오는 GUI 메뉴를 구현하기 위해 클래스를 하나 만든다고 가정합시
다. 이 클래스는 스레딩 환경에서 동작할 수 있도록 설계되었기 때문에, 병행성 제어를 위해
뮤텍스(mutex)를 갖고 있습니다. 자 일단 보시죠.

class PrettyMenu
{
public:
	...
	void changeBackground(std::istream& imgSrc);// 배경그림을 바꾸는 멤버 함수
	...
private:
	Mutex mutex;	// 이 객체 하나를 위한 뮤텍스
	Image* bgImage;	// 현재의 배경그림
	int imageChange;	// 배경그림이 바뀐 횟수
};

여기서 PrettyMenu의 changeBackground 함수가 디음과 같이 구현되었다고 생각해
보세요.

void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	lock(&mutex);	// 뮤텍스를 획득합니다(항목 14와 같아요).
	delete bgImage;	// 이전의 배경그림을 없앱니다.
	++imageChange;	// 그림 변경 횟수를 갱신합니다.
	bgImage = new Image(imgSrc);	// 새 배경그림을 깔아 놓습니다.
	unlock(&mutex);	// 뮤텍스를 해제합니다.
}

예외 안전성이라는 측면에서 볼 때 이 함수는 "이보다 더 나뿔 수는 없다"고 말하고 싶네
요. 일반적으로 예외 안전성을 확보하려면 두 가지의 요구사항을 맞추어야 히는데, 이 함수
는 어느 요구사항에도 맞지 않는, 위험천만의 함수입니다.

예외 안전성을 가진 함수라면 예외가 발생할 때 이렇게 동작해야 합니다.

*	자원이 새도록 만들지 않습나다. 
	그런데 위의 코드는 자원이 샙니다. 왜냐하면 "new Image(imgSrc)" 표현식
	에서 예외를 던지면 unlock 함수가 실행되지 않게 되어	뮤텍스가 계속 잡힌 상태로 
	남기 때문입니다.

*	자료구조가 더럽혀지는 것을 허용하지 않습니다. 
	그런데 위의 코드에서 "new Image(imgSrc)"가 예외를 던지면 bgImage가 가리키는 
	객체는 이미 삭제된 후입니다. 그뿐인가요? 새 그림 이 제대로 깔린 게 아닌데도 
	imageChanges 변수는 이미 증가되었을 것이고요(이전의 그림이 없어진 것은 확실하기 
	때문에, 그림이 '바뀐'건 맞지 않느냐며 쌍심지를 세우는 분들도 충분히 감안한 
	발언입니다).

자원 누출 문제는 맞서 싸우기가 그렇게 까다로운 것은 아닙니다. 객체를 써서 자원 관리를
전담케 하는 방법을 항목 13에서 읽으시고, 항목 13의 아이디어를 살려 뮤텍스를 적절한 시
점에 해제하는 방법을 구현한 Lock 클래스를 항목 14에서 접하셨으면, 그대로 따라하시는
것으로 바로 마무리되니까요.

void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	Lock m1(&mutex);	// 항목 14에서 가져왔습니다: 뮤텍스를 대신 획득하고
						// 이것이 필요 없어질 시점에 바로 해제해 주는 객체입니다.
	delete bgImage;
	++imageChange;
	bgImage = new Image(imgSrc);
}

Lock 등의 자원관리 전담 클래스를 쓰면 가장 좋은 점 중 하나는 함수의 코드 길이가 짧
아진다는 것입니다. 보세요. 지금은 unlock을 호출할 필요가 없죠? 늘 그런 건 아니겠지
만, 대개 코드는 적을수록 좋잖아요. 어긋날 일도 적어질 것이고? 뭔가를 바꿨을 때 잘못 이
해할 것도 적어질 테니까요.

이렇게 해서 일단 자원 누출 문제는 꼬리를 내렸습니다. 이제 다음 판에서 만날 상대자는
자료구조 오염 문제입니다. 여기서는 선택을 좀 해야 하는데요, 일단 그전에 우리가 고를 수
있는 이 무엇 인지를 제대로 파악하기 위해 용어 공부가 좀 필요할 것 같습니다.

예외 안전성을 갖춘 함수는 아래의 세 가지 보장(guarantee) 중 하나를 제공합니다.

*	기본적인 보장(basic guarantee) 함수 동작 중에 예외가 발생하면, 실행 중인 
	프로그램에 관련된 모든 것들을 유효한 상태로 유지하겠다는 보장입니다. 어떤 객체나 
	자료구조도 더럽혀지지 않으며, 모든 객체의 상태는 내부적으로 일관성을 유지하고 
	있습니다(즉, 모든 클래스 불변속성이 만족된 상태입니다). 하지만 프로그램의 상태가 
	정확히 어떠한지는 예측이 안 될 수도 있습니다. 예를 들어, changeBackground 
	함수가 동작하다가 예외가 발생했을 때 PrettyMenu 객체는 바로 이전의 배경그림을 
	그대로 계속 그릴 수도 있고, 아니면 처음부터 마련해 둔 기본 배경그림을 사용할 
	수도 있을 것입니다. 이 부분은 전적으로 함수를 만든 사람에 달려 있지요. 하지만 
	사용자 쪽에서는 어떻게 될지 예측할 수 없습니다(알아내려면, 현재의 배경그림이 무엇인
	지를 알려 주는 다른 맴버 함수를 호출하든지 해야겠지요).

*	강력한 보장(strong guarantee) 함수 동작 중에 예외가 발생하면, 프로그램의 
	상태를 절대로 변경하지 않겠다는 보장입니다. 이런 함수를 호출하는 것은 원자적인(a-
	tomic) 동작이라고 할 수 있습니다. 호출이 성공하면(예외가 발생하지 않으면) 마무리
	까지 완벽하게 성공하고, 호출이 실패하면 함수 호출이 없었던 것처럼 프로그램의 상태가 
	되돌아간 다는 면에서 말이죠.

	'쓰기 편한가'의 측면에서 보면 강력한 보장을 제공하는 함수가 기본 보장을 제공히는
	함수보다 더 쉽습니다. 예측할 수 있는 프로그램의 상태가 두 개밖에 안 되기 때문입니
	다. 그러니까 함수가 성공적으로 실행을 마친 후의 상태, 아니면 함수가 호출될 때의
	상태만이 존재하는 거죠. 이와 대조적으로 함수가 기본 보장을 제공할 경우에는, 예외
	발생 시에 프로그램이 있을 수 있는 상태가 그냥 유효하기만 하면 어떤 상태도 될 수
	있습니다.

*	예외불가 보장(nothrow guarantee) 예외를 절대로 던지지 않겠다는 보장입니다. 
	약속한 동작은 언제나 끝까지 완수하는 함수라는 뜻이죠. 기본제공 타입(int , 포인터 
	등)에 대한 모든 연산은 예외를 던지지 않게 되어 있습니다(즉, 예외불가 보장이 제공
	됩니다). 예외에 안전한 코드를 만들기 위한 가장 기본적이며 핵심적인 요소가 아닐까 
	싶네요.

	어떤 예외도 던지지 않게끔 예외 지정이 된 함수는 예외불가 보장을 제공한다고 생각
	해도 일견 맞을 것 같지만, 잘못 생각하신 겁니다 아래의 예를 보세요.

	int doSomething() throw();	// 비어 있는 예외 지정

	위의 함수 선언이 전하는 메시지는 doSomething이 절대로 예외를 던지지 않겠다는 
	말이 아닙니다. 만약 doSomething에서 예외가 발생되면 매우 심각한 에러가 생긴 
	것으로 판단되므로, 지정되지 않은 예외가 발생했을 경우에 실행되는 처리자인 
	unexpected 함수가 호출되어야 한다는 뜻입니다.+4) 사실 doSomething은 어떤 예외 
	안전성 보장도 제공하지 않을 수도 있습니다. 함수 선언문에는(예외 지정이 붙어 있으면 
	이것도 포함됩나다) 해당 함수가 맞는지, 이식성이 있는지, 아니면 효율적인지 알려 주는 
	기능 같은 것이 없습니다. 예외 안전성 보장을 제공하는지도 당연히 알려 주지 않습니다. 
	함수가 어떤 특성을 갖느냐 하는 부분은 '구현'이 결정하는 것입니다. '선언'은 그냥 
	선거공약 같은 거라고요.

앞에서 말했지만, 예외 안전성을 갖춘 함수는 위의 세 가지 보장 중 하나를 반드시 제공해
야 합니다. 아무 보장도 제공하지 않으면 예외에 안전한 함수가 아닙니다. 따라서 여러분이
'선택'해야 하는 것은 '아떤 보장을 제공할 것인가'이겠습니다. 예외 안전성이 없는 재래식
(legacy) 코드를 사용해서 작업할 때를 제외하면(이 부분에 대한 이야기는 이번 항목의 
뒷부분에서 따로 하겠습니다), 예외 안전성을 제공하지 않는 쪽으로 선택해도 되는 경우는 
제 정신으론 일하기 힘든 요구사항 분석담당팀에서 여러분의 제품을 돌려보면서 자원을 
누출시키며 자료구조를 오염시킬 수 있도록 달라고 요청해 올 때 말고는 없습니다.

위의 세 가지 보장 중에 하나를 고르라면 아무래도 실용성이 있는 강력한 보장이 괜찮아 보
일 것입니다. 예외 안전성의 관점에서 보면 예외불가 보장이 가장 훌륭하겠지만, 예외를 던
지는 함수를 호출하지 않고 C++의 C 부분으로부터 벗어나오기란 힘들거든요. 일단 동적
할당 메모리를 시용하는 쪽(STL 컨테이너가 실제로 그렇습니다)만 보아도, 요청에 맞는 메모리
를 확보할 수 없으면 bad_alloc 예외를 던지 도록 구현되어 있지 않습니까(항목 49 참조).
뭐 할 수 있으면 예외불가 보장을 제공하세요. 하지만 현실적으로는 대부분의 함수에 있어
서 기본적인 보장과 강력한 보장 중 히나를 고르게 됩니다.

changeBackground 함수를 다시 들여다보도록 하죠. 이 함수의 경우엔 강력한 보장을
거의 제공하는 것은 그다지 어렵지 않습니다. 우선 첫째로, PrettyMenu의 bgImage 데
이터 멤버의 타입을 기본제공 포인터 타입인 Image*에서 자원관리 전담용 포인터(항목 13
에서 봤었죠)로 바꿉니다. 정말이지 자원 누출을 막는 대책으로 본다면 이렇게 가는 게 딱
맞습니다. 사용자에게 강력한 예외 안전성 보장을 제공할 수 있게 만든 것뿐인데 '객체(스마
트 포인터 등)를 써서 자원을 관리하는 것이 좋은 설계의 첫걸음'이라고 울부짖은 바 있는
항목 13의 내용을 다시금 확인하는 셈이 되었지요. 뒤에서 보실 코드에서 필자는 자원관리
용 객체로 tr1::shared_ptr을 쓸 겁니다. auto_ptr도 있긴 하지만, 복사될 때의 동
작이 더 직관적이라 사용하기가 더 좋거든요.

+	unexpected 함수에 대한 자세한 사항을 알고자 하는 분들은 즐겨 사용하시는 검색 
	엔진을 이용하거나 C++를 진반적으로 다룬 참고서를 읽어 보시기 바랍니다(운이 좋으신 
	분은 이 함수를 찾아보다가 set_unexpected 함수도 발견할지 모르겠습니다. 이 함수
	는 unexpected 함수로 사용할 실제 함수를 설정하는 용도로 쓰입니다).

4)	"MEC++"의 항목 14를 참고하거나 "TC++PL"의 14장을 참고하자-옮긴이

둘째로, changeBackground 함수 내의 문장을 재배치해서 배경그림이 진짜로 바뀌기 전
에는 imageChanges를 증가시키지 않도록 만듭니다. 어떤 동작이 일어났는지를 나타내는
객체를 프로그램 내에서 쓰는 경우에는 해당 동작이 실제로 일어날 때까지 그 객체의 상태
를 바꾸지 않는 편이 일반적으로 좋다고 하지요.

이제 실제로 손을 댄 코드를 보시죠.

class PrettyMenu
{
...
std::tr1::shared_ptr<Image> bgImage;
...
};

void PrettyMenu::changeBackground(std::isteam&& imgSrc)
{
	Lock m1(&mutex);
	bgImage.reset(new Image(imgSrc));	// bgImage의 내부 포인터를
										// "new Image" 표현식의 실행
										// 결과로 바꿔치기 합니다.
	++imageChange;
}

자, 보세요. 이제는 이전의 배경그림(Image 객체)을 프로그래머가 직접 삭제할 필요가 없게
되었습니다. 지금은 배경그림이 스마트 포인터의 손에서 관리되고 있기 때문입니다. 게다가,
새로운 배경그림이 제대로 만들어졌을 때만 이전 배경그림의 삭제 작업이 이루어지도록 바
뀐 점도 눈에 들어옵니다. 다시 말해, 이제는 tr1::shared_ptr::reset 함수가 호출
되려면 이 함수의 매개변수("new Image(imgSrc)"의 결과)가 제대로 생성되어야 한다는
것입니다. delete 연산자는 reset 함수 안에 들어 있기 때문에, reset이 호출되지 않
는 한 delete도 쓰일 일이 없을 것입니다. 또 있습니다, 객체(tr1::shared_ptr)를 써
서 자원(동적 할당된 Image 객체)을 관리하게 하니까 changeBackground 함수의 길이까
지 줄어들었군요.

그렇습니다. changeBackground 함수에서 강력한 예외 안전성 보장을 제공하려면 앞에
서 말한 대로 두 가지만 바꾸면 거의 충분합니다. '거의'라 뭔가 '옥의 티'가 있는 것 같죠?
바로 매개변수인 imgSrc입니다. Image 클래스의 생성자가 실행되다가 예외를 일으킬 때,
그 시점에 입력 스트림의 읽기 표시자가 이동한 채로 남아 있을 가능성 이 충분히 있을 테고
요. 이 표시자의 이동이 전체 프로그램의 나머지에 영향을 미칠 수 있는 어떤 변화로 작용
할 수도 있을 것입니다. 따라서 엄밀히 말하면 changeBackground가 제공하는 예외 안
전성 보장은 기본적인 보장입니다. 이 문제까지 해소될 때까지는 말입니다.

어쨌든 이 문제는 접어 두죠. changeBackground 함수가 강력한 보장을 제공한다고 가
정하고 갈 길 계속 갑시다(여러분 능력이라면 해결 방법을 충분히 생각해낼 수 있을 것입니다. 
매개변수 타입으로 istream을 쓰지 말고, 배경그림 파일의 이름을 나타내는 타입 같은 것으로 
바꿔보세요). 이번에는 예외에 속수무책인 함수를 탈바꿈시켜 강력한 예외 안전성 보장을 제공
하는 함수로 거듭나게 만드는 일반적인 설계 전략을 하나 알아보도록 하죠. 이 전략은 '복사-
후-바꾸기(copy-and-swap)'라는 이름으로 알려져 있는데, 원리 적으로 무척 간단합니다. 
어떤 객체를 수정하고 싶으면 그 객체의 사본을 하나 만들어 놓고 그 사본을 수정하는 것입니
다. 이렇게 하면 수정 동작 중에 실행되는 연산에서 예외가 던져지더라도 원본 객체는 바뀌지
않은 채로 남는 거죠. 필요한 동작이 전부 성공적으로 완료되고 나면 수정된 객체를 원본
객체와 맞바꾸는데, 이 작업을 '예외를 던지지 않는' 연산 내부에서 수행합니다.

이 전략은 대개 '진짜 객체의 모든 데이터를 별도의 구현(implementation) 객체에 넣어두고,
그 구현 객체를 가리키는 포인터를 진짜 객체가 물고 있게 하는 식으로 구현합니다. 많은
분들께서 'pimpl 관용구'라고들 부르는 이 구현 방법은 항목 31에서 자세히 다루고 있으니
참고하세요. 어쨌든 이 방법을 PrettyMenu에 적용하면, 다음과 같은 형태의 코드가 나올
것입니다.

struct PMImpl		// PMImpl = "PrettyMenu.pImpl"; PMImpl이 struct로
{					// 선언된 데에는 이유가 있습니다. 밑에서 확인하세요.
	std::tr1::shared_ptr<Image> bgImage;
	int imageChange;
};

class PrettyMenu
{
...
private:
	Mutex mutex;
	std::tr1::shared_ptr<PMImpl> pImpl;
};

void PrettyMenu::changeBackground(std::istream& imgSrc)
{
	using std::swap;	// 항목 21를 보세요.
	Lock m1(&mutex);	// 뮤텍스를 잡고 들어갑니다.
	// 객체의 데이터 부분을 복사합니다.
	std::tr1::shared_ptr<PMImpl> pNew(new PMImpl(*pImpl));

	pNew->bgImage.reset(new Image(imgSrc)); // 사본을 수정합니다.
	++pNew->imageChange;
	swap(pImpl, pNew);	// 새 데이터로 바꿔 넣어 진짜로 배경그림을 바꿉니다.
}						// 뮤텍스를 놓습니다.

PMImpl이 클래스가 아니라 구조체로 만들어져 있는게 보이실 텐데요. 제가 그렇게 정한
것입니다. PrettyMenu 클래스에서 pImpl이 private 멤버로 되어 있어서 구현 객체
의 데이터가 바로 캡슐화되기 때문이죠. 사실 클래스로 만들어 놓았어도 그다지 니뿔 건 없습
니다. 조금 불편해진다는 점만 빼면 말이죠(참, 객체 지향에 목숨 건 분들은 이 부분을 보시변 
학을 떼실 겁니다). 취향에 따라서는 PMImpl을 PrettyMenu 안에 중첩 시킬 수도 있지만, 
이 부분은 코드의 예외 안전성 문제와 하등 상관이 없는 패키징 문제이므로 여기서는 넘어갑시다.

'복사-후-맞바꾸기' 전략은 객체의 상태를 '전부 바꾸거나 혹은 안 바꾸거나(all-or-nothing)'
방식으로 유지하려는 경우에 아주 그만입니다. 그러나 함수 전체가 강력한 예외 안전성을
갖도록 보장하지는 않는다는 것이 일반적인 정설입니다. 왜 그럴까요? changeBackground
함수의 전체 흐름을 추상화해 놓은 someFunc()를 한번 살펴봅시다. '복사-후-맞비꾸기'
수법을 쓰되, f1 및 f2라는 다른 함수의 호출문이 들어 있는 형태로 말이죠. 다음과 같은
로 나올 겁니다.

void someFunc()
{
	...			// 이 함수의 현재 상태에 대해 사본을 만들어 놓습니다.
	f1();
	f2();
	...			// 변경된 상태를 바꾸어 놓습니다.
}

이제 뚜렷이 보이십니까? f1 혹은 f2에서 보장하는 예외 안전성이 '강력'하지 못하면, 위의
구조로는 someFunc 함수 역시 강력한 예외 안전성을 보장하기 힘들어집니다. 예를 들어
f1이 기본적인 보장만 제공한다고 가정해 봅시다. someFunc 함수에서 강력한 보장을 제
공하게 만들려면 (1) f1을 호출하기 전에 프로그램 전체의 상태를 결정하고 (2) f1에서 발
생하는 모든 예외를 잡아낸 후에 (3) 원래의 상태로 되돌리는 코드를 작성해야 합니다.

f1 및 f2 모두가 강력한 예외 안전성을 보장한다고 해도 사실 별로 나아지는 것은 없습니
다. 예를 들어 어차피 f1이 끝까지 실행되고 나면 프로그램 상태는 f1에 의해 어떻게든 변
해 있을 것이고, 그 디음에 f2가 실행되다가 예외를 던지면 그 프로그램의 상태는
someFunc가 호출될 때의 상태와 아예 달라져 있을 것이니까요. f2에서 아무것도 바꾸지
않았더라도 말입니다.

눈치 채셨겠지만 여기서 불거지는 문제가 바로 함수의 부수효과(side effect) 입니다. 자기 
자신에만 국한된 것들의 상태를 바꾸며 동작하는 함수의 경우(예를 들어 someFunc는 이 함수
의 내부에서만 사용하는 객체의 상태에만 영향을 주고 있죠)에는 강력한 보장을 제공하기가 비교
적 수월합니다. 그렇지만 비지역 데이터에 대해 부수효과를 주는 함수는 이렇게 하기가 무
척 까다롭습니다. 예를 들어 f1을 호출하고 나서 생기는 부수효과로서 데이터베이스가 변경
되기라도 해보세요. someFunc 쪽에서 어떻게 손을 쓸 수가 없지 않겠습니까? 특이한 경우
가 아닌 한, 이미 확정(commit) 되어 버린 데이터베이스 변경사항을 되돌릴 수 있는 방법은
없습니다. 그 데이터베이스의 다른 사용자가 변경사항을 벌써 봤을 수 있으니까요.

강력한 예외 안전성 보장을 제공하게 하고 싶어서 아무리 열을 내더라도 이런 문제 때문에
발목을 잡힐 수 있다는 사실을 알고 계셨으면 좋겠습니다. 참, 효율 문제도 무시할 수 없습
니다. '복사-후-맞바꾸기' 방법의 요체는 객체의 데이터에 대해 사본을 만들어 놓고 그 사
본을 변경한 후에, 사본과 원본의 바꿔치기 작업을 예외를 던지지 않는 함수 내부에서 하자
는 아이디어입니다. 때문에 수정하고 싶은 객체를 복사해 둘 공간과 복사에 걸리는 시간을
감수해야 하겠지요. 이런 부분에 여유가 없거나 웬지 꺼림칙한 분이 분명히 있을 것입니다.
어쨌든 예외 안전성 보장 중에는 강력한 보장이 가장 좋습니다. 실용성이 확보되는 경우라
면 반드시 제공하는 게 맞고요. 그러나 언제나 실용적인 것은 아니랍니다.

강력한 보장을 제공할 수 없다면 기본적인 보장 쪽으로 눈을 돌릴 수밖에 없을 것입니다.
실제로 현업을 뛰다 보면 어떤 함수들은 강력한 보장을 제공할 수 있지만 그 외의 많은 함
수들에 대해서는 효율 혹은 복잡성에서 생기는 비용 때문에 눈물을 머금고 강력한 보장을
접어야 하는 경우를 경험하게 됩니다. 앞에서 말씀드린 대로 실용성이 확보될 때만 강력한
보장을 제공하는 데 힘쓰십시오. 이렇게만 하면, 여러분이 기본적인 보장만 제공한다고 할
때 뭐라고 할 사람 이무도 없을 것입니다. 대다수의 함수에 있어서 무리 없는 선택을 한다
면 뭐니 뭐니 해도 기본적인 보장이 우선입니다.

예외 안전성 보장을 아예 제공하지 않는 함수를 만든다고 하면 생각을 좀 다르게 하셔야 합
니다. 무죄라고 알려지기 전엔 그냥 죄를 옴팡 뒤집어쓰겠다는 이야기거든요. 이런 함수를
만들 땐 일단 예외에 안전한 코드를 써야 하는 것은 기본이지만, 어쩔 수 없이 방어막을 많
이 세워야 합니다. someFunc가 어떻게 구현되어 있는지 다시 떠올려 보세요. f1과 f2를
호출하고 있죠? 여기서 f2가 예외 안전성 보장을 전혀 제공하지 않는다고 가정합시다. f2
는 기본적인 보장조차 해 주지 않습니다. 무슨 뜻인고 하니, f2에서 예외가 터지면 f2 안
에서 자원이 누출될 수 있다는 뜻입니다. 그러니까, f2 때문에 프로그램의 자료구조가 망가
질 수 있다는 말도 되는 거고요. 정렬되어 있던 배열이 헝클어질지도 모르고 어떤 자료구조
에서 다른 자료구조로 전송되던 객체가 날아가 버릴지도 모른다는 거라고요. 이런 문제가
터진다 해도 someFunc 차원에서는 손을 쓸 방법이 없습니다. someFunc가 호출하는 함
수가 예외 안전성 보장을 전혀 제공하지 않으면, someFunc 역시 어떤 보장도 제공할 수
없게 됩니다.

이제는 '아이 갖기' 이야기로 돌아와도 될 것 같습니다. 아시겠지만 여자는 아이를 가졌거나
아니거나 둘 중 하나입니다. 애가 반만 생긴다는 이야기 못 들으셨죠? 소프트웨어 시스템도
마찬가지라서, 예외에 안전하거나 예외에 뚫려 있거나 둘 중 하나입니다. 일부만 예외 안전
성을 갖춘 스템 같은 것은 없다는 말입니다. 예외 안전성이 없는 함수가 한 개라도 쓰이
고 있으면 그 시스템은 전부가 예외에 안전하지 않은 시스템입니다. 호출 시 자원이 누출
되고 자료구조가 더러워질 테니까요. 이런 이야기를 꺼내어 좀 우울하긴 하지만, C++로 작
성된 상당수의 재래식 코드가 예외 안전성 자체를 고려하지 않고 만들어진 것이 사실입니다.
그래서 요즘에 나오는 시스템에서도 예외 안전성 확보 여부에서 자유롭지 않은 경우를 많이
볼 수 있는 것이고요. 예외에 안전하지 않은 방법으로 작성된 코드를 사용하고 있으니 당연
하겠지요.

요즘에도 그렇다고 계속 그렇게 놔둘 이유는 없습니다. 앞으로는 새로운 함수를 만들거나
기존의 코드를 고칠 때 '어떻게 하면 예외에 안전한 코드를 만들까'를 진지하게 고민하는 
버릇을 들이십시오. 자원 관리가 필요할 때 자원 관리용 객체를 사용하는 것부터가 시작입니
다(뭘 부끄러워하세요? 항목 13 빨리 펴보세요). 우선 자원 누출만큼은 확실히 막아 줄 것
입니다. 그리고 이번 항목에서 공부한 예외 안전성 보장 세 가지 중에 여러분이 만드는 함
수에서 실용적으로 제공할 수 있는 보장은 어떤 것일지를 결정하십시오. 정말 어쩔 수 없이 
재래식 코드를 호출해야 할 경우에만 '예외 안전성 무보장'에 주저앉는 겁니다. 여러분이 
내린 결정은 반드시 문서로 남겨서, 여러분이 만든 함수의 사용자 및 나중의 인수인계자가 
파악 할 수 있도록 하세요. 예외 안전성 보장은 함수의 인터페이스에서 외부에 노출되는 
아주 중요한 부분이므로, 함수 인터페이스의 다른 부분을 결정할 때와 같은 마음으로 신중
하게 결정해야 합니다.

40년 전에는 코드에 goto 문으로 도배하는 것이 아주 좋은 프로그래밍 방법이라고들 했습
니다. 그런 시절도 있었어요. 요즘은 제어 흐름을 구조화하는 데 모든 프로그래머들이 혈안
이 되어 있죠. 전역적으로 접근할 수 있는 데이터를 두는 것이 완벽한 프로그래멍 방법이라 
고 생각되던 때가 20년 전밖에 안 됩니다. 요즘은 데이터 캡슐화에 목숨을 거는 시대입니다.
예외의 영향을 생각하지 말고 함수를 만드는 것이 최고라는 이야기는 불과 10년 전에 유행
했었습니다. 지금 우리는 이번 항목에서 코드의 예외 안전성을 위해 힘차게 씨우자는 이야
를 하고 있죠.

시간은 계속 흐릅니다. 우리는 안 죽었고요. 계속 배워가는 겁니다.

이것만은 잊지 말자!

*	예외 안전성을 갖춘 합수는 실행 중 예외가 발생되더라도 자원을 누출시키지 않으며 
	자료구조를 더럽힌 채로 내버려 두지 않습니다. 이런 함수들이 제공할 수 있는 예외 
	안전성 보장은 기본적인 보장, 강력한 보장, 예외 금지 보장이 있습니다.

*	강력한 예외 안전성 보장은 '복사-후-맞바꾸기' 방법을 써서 구현할 수 있지만, 모든
	함수에 대해 강력한 보장이 실용적인 것은 아닙니다.

*	어떤 함수가 제공하는 예외 안전성 보장의 강도는, 그 함수가 내부적으로 호출하는 
	함수들이 제공하는 가장 약한 보장을 넘지 않습니다.