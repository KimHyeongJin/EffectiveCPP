항목 7: 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자

시간 기록을 유지하는 방법은 활용에 따라 무궁무진합니다. 그래서인지 TimeKeeper 정도
의 이름을 가진 클래스를 기본 클래스로 만들어 놓은 후에 적절한 용도에 따라 이것을 파생
시키도록 설계하면 딱 알맞을 것 같습니다.

class TimeKeeper
{
public:
	TimeKeeper();
	~TimeKeeper();
	...
};

class AtomicClock: public TimeKeeper {...};
class WaterClock: public TimeKeeper {...};
class WristWatch: public TimeKeeper {...};

이 클래스의 혜택을 받는 사용자들은 시간 정보에 접근하고 싶어 합니다. 시간 계산이 어떻
게 되는지에 대해서는 신경 쓰고 싶지 않고요. 사정이 이렇기 때문에, 어떤 시간기록 객체에
대한 포인터를 손에 넣는 용도로 팩토리 함수(factory function, 새로 생성된 파생 클래스 객체
에 대한 기본 클래스 포인터를 반환하는 함수)를 만들어 두면 딱 좋을 것 같습니다.

TimeKeeper* getTimeKeeper();	// TimeKeeper에서 파생된 클래스를 통해 동적으로
								// 할당된 객체의 포인터를 반환합니다.

팩토리 함수의 기존 규약을 그대로 따라간다면 getTimeKeeper 함수에서 반환되는 객체
는 힙에 있게 되므로, 결국 메모리 및 기타 자원의 누출을 막기 위해 해당 객체를 적절히
삭제(delete) 해야 합니다.

TimeKeeper* ptk = getTimeKeeper();	// TimeKeeper 클래스 계통으로부터
									// 동적으로 할당된 객체를 얻습니다.
...					// 이 객체를 사용합니다.

delete ptk;			// 자원 누출을 막기 위해 해제(삭제)합니다.

항목 13을 보시면 객체 삭제를 사용자에게 전가하는 것은 에러 발생에 노출될 소지가 있다
는 이야기가 있고, 또 항목 18에서는 팩토리 함수의 인터페이스를 수정하면 흔히 발생할 수
있는 사용자 에러를 방지할수 있다는 이야기도 나오지만, 어쨌든 그런 이야기는 여기선 접어 
둡시다. 이번 항목에선 위의 코드에 숨어 있는 더 근본적인 약점을 다루고 또 해결
할 거니까요. 사용자가 아무리 제대로 한다고 해도, 프로그램이 어떻게 동작할지는 알 방법
이 없잖습니까.

문제는 getTimeKeeper가 반환하는 포인터가 파생(그러니까 AtomicClock)
객체에 대한 포인터라는 점과 이 포인터가 가리키는 객체가 삭제될 때는 기본 클래스 포인
터(즉, TimeKeeper* 포인터)를 통해 삭제된다는 점, 그리고 결정적으로 기본 클래스
(TimeKeeper)에 들어 있는 소멸자가 비가상 소멸자(non-virtual destructor)라는 점입니다.
실로 어처구니없는 상황입니다. 

C++의 규정에 의하면, 기본 클래스 포인터를 통해 파생 클래스 객체가 삭제될 때 그 기본 
클래스에 비가상 소멸자가 들어 있으면 프로그램 동작은 미정의 사항이라고 되어 있습니다.

대개 그 객체의 파생 클래스 부분이 소멸되지 않게 되지요. 정리하면, getTimeKeeper
함수에서 포인터를 통해 날아오는 AtomicClock 객체는 기본 클래스 포인터를 통해 삭제
될 때 AtomicClock 부분(그러니까 AtomicClock 클래스에서 정의된 데이터 멤버들)이 
삭제되지 못할 뿐만 아니라 AtomicClock의 소멸자도 실행되지 않습니다. 그러나 기본 클래스 
부분(즉, TimeKeeper 부분)은 소멸 과정이 제대로 끝나므로 결국 반쪽짜리 '부분 소멸
(partially destroyed)' 객체의 신세로 전락하는 거죠. 당연히 여러분의 소중한 자원이
누출 될 것이고, 자료구조가 오염되는 것은 물론이요, 다시 무한 짜증의 디버깅 모드에 
돌입 해야 할지도 모릅니다.

이 문제를 없애는 방법이요? 지극히 간단합니다. 사랑하는 기본 클래스에게 가상 소멸자를
선물하세요. 이젠 파생 클래스 객체를 기본 클래스 포인터로 삭제할 때 여러분이 원하는 쪽
으로 동작하게 될 것입니다. 기본 클래스의 소멸자 앞에 virtual 하나 붙여 줬을 뿐인데
객체 전부가 소멸됩니다. 파생 클래스 부분까지 몽땅 말이죠.

class TimeKeeper
{
public:
	TimeKeeper();
	virtual ~TimeKeeper();
	...
};

TimeKeeper* ptk = getTimeKeeper();
...
delete ptk;			// 이제 제대로 동작합니다.

TimeKeeper 비슷한 기본 클래스에는 대개 소멸자 외에도 가상 멤버 함수들이 더러 들어
있게 마련입니다. 파생 클래스를 구현할 때 해당 함수를 역할에 따라 맞추는 작업을 허용한
다는 의미이겠지요(항목 34 참조) 예를 들어, TimeKeeper 클래스는 현재 시각을 알려 주
는 getCurrentTime 함수를 가상 함수로 가질 수 있습니다. 이 함수는 여러 파생 클래
스에서 다른 의미로 구현되겠지요. 사정이야 어쨌든, 가상 함수를 하나라도 가진 클래스는
가상 소멸자를 가져야 하는 게 대부분 맞습니다.

가상 소멸자를 갖고 있지 않은 클래스를 만나면 이렇게 생각하면 됩니다. '아, 저 클래스는
기본 클래스로 쓰일 의지를 상실한 것이구나'라고요. 입장을 바꾸어 보아도 마찬가지인데, 기
본 클래스로 의도하지 않은 클래스에 대해 소멸자를 가상으로 선언하는 것은 좋지 않은 정신
자세입니다. 한 예로, 2차원 공간에 있는 한 점을 나타내는 클래스를 보도록 하죠.

class Point
{
public:
	Point(int xCoord, int yCoord);
	~Point();
private:
	int x, y;
};

int가 32비트를 차지한다고 가정하면, 이 Point 객체는 64비트 레지스터에 딱 맞게 들어
갈 수 있겠지요. 그리고 C나 포트란(FORTRAN) 등의 다른 언어로 작성된 함수에 넘길 일이
생길 때도 64비트 크기의 자료로 넘어갈 것입니다. 그런데 Point 클래스의 소멸자가 가상
소멸자로 만들어지는 순간, 사정이 변하기 시작합니다.

가장 함수를 C++에서 구현하려면 클래스에 별도의 구조가 하나 들어가야 합니다. 이
자료구조는 프로그램 실행 중에 주어진 객체에 대해 어떤 가상 함수를 호출해야 하는지를
결정하는 데 쓰이는 정보인 데, 실제로는 포인터의 형태를 취하는 것이 대부분이고, 대개
vptr['가상 함수 테이블 포인터(virtual table Pointer)'란 뜻입니다]이라는 이름으로 불립니다.
vptr은 가상 함수의 주소, 즉 포인터들의 배열을 가리키고 있으며 가상 함수 테이블 포인
터의 배열은 vtbl['가상 함수 테이블(virtual table)']이라고 불립니다. 가상 함수를 하나라도 갖
고 있는 클래스는 반드시 그와 관련된 vtbl을 갖고 있습니다. 어떤 객체에 대해 어떤 가상
함수가 호출되려고 하면, 호출되는 실제 힘수는 그 객체의 vptr이 가리키는 vtbl에 따라
결정됩니다. vtbl에 있는 함수 포인터들 중 적절한 것이 결되는 것이죠.

가상 함수 호출이 어떻게 구현되는지에 관해서는 사실 파고들지 않아도 됩니다. 정말 중요한 
것은 Point 클래스에 가상 함수가 들어가게 되면 Point 타입 객체의 크기가 커진다는 사실입니다.
프로그램 실행환경이 32비트 아키텍처라면, 크기가 64비트(int 두 개)에서 96비트(int 두 
개에 vptr 하나)로 커집니다. 64비트 아키텍처에서는 64비트에서 128비트로 커질 수 있습니다.2) 
64비트 시스템에서 포인터 크기는 64비트이거든요. Point 객체는 가상 함수 테이블 포인터가 
하나 추가됐을 뿐인데 크기가 무려 50%에서 100%까지 커져 버립니다. 이젠 64비트 레지스터에 
들어가긴 글렀습니다. 게다가 C 등의 다른 언어로 선언된 동일한 자료구조와도 호환성이 없어집니다. 
왜냐하면 다른 언어로 Point와 겉보기가 똑 같은 데이터 배치를 써서 선언했다고 해도 vptr만은 
어떻게 만들 수 없기 때문이죠. 결국, 다른 언어로 작성된 함수에 Point 객제를 전달하고 또 
그 함수로부터 전달받을 수있게 하려면 vptr 부분을 어떻게든 보충해 주어야 하는데, 이 
부분부터는 구현환경에 따라 세부사항이 달라지는 문제이기 때문에 이식성에 대한 기대는 접는 것이 
좋습니다.

자, 정리하고 출발선부터 잡읍시다. 어느 경우를 막론하고 소멸자를 전부 virtual로 선언하는
일은 virtual로 절대 선언하지 않는 것만큼이나 편찮은 마인드입니다. 가상 소멸자를 선언하
는 것은 그 에 가상 함수가 하나라도 들어 있는 경우에만 한정하세요. 실제로 많은
프로그래머들이 이런 식으로 머리 속에 정리해 놓고 제시더라고요.

가상 함수가 전혀 없는데도 비가상 소멸자 때문에 뒤통수를 맞는 경우도 있습니다. 한 예가 표
준 string 타입입니다. 이 타입은 가상 함수를 갖고 있지 않지만, 전후 사정 무시하고 이 타
입을 기본 클래스로 잡아버리는 일부 몰지각한 프로그래머들이 가끔 있습니다. 이렇게 말이죠.

class SpecialString : public std::string // 말도 안되는 아이디어 입니다.
{									// std::string은 가상 소멸자가 없단 말입니다.
...
};

::2) LLP64(혹은 P64)의 데이터 모델을 채택한 64비트 아키텍쳐의 경우만 한정한다. 
참고로 LLP64는 int 및 long은 그대로 32비트로 남고 포인터만 64비트로 확장되는 모델로서, 
64비트 Window(Win64)에서 채택하였다. 유닉스(UNIX)는 LP64 모델을 쓰고 있는데, 이는 
int는 32비트로 남고 long 및 포인터가 64비트로 확장되는 모델이다. - 옮긴이

그냥 보기엔 티 없이 맑고 순수해 보이지만, 이것을 사용한 응용프로그램 어딘가에서 Special-
String의 포인터를 string의 포인터로 어떻게든 변환한 후에 그 string 포인터에
delete를 적용하면 그 순간부터 여러분은 '미정의 동작'행 급행열차로 갈아타시게 됩니다.

SpecialString *pss = new SpecialString("Impending Doom");
std::string *ps;
...
ps = pss;		// SpecialString* -> std::string* 
...
delete ps;		// 정의되지 않은 동작이 발생합니다!
				// 실질적으로 *ps의 SpecialString 부분에 있는 자원이 누출되는데,
				// 그 이유는 SpecialString의 소멸자가 호출되지 않기 때문입니다.

이 현상은 가상 소멸자가 없는 클래스이면 어떤 것에든 전부 적용됩니다. 그런데 가상 소멸자
가 없는 클래스는 우리 주변에 이주 가까이 있습니다. STL 컨테이너 타입[예를 들면 vector,
list, set, tr1::unordered_map(항목 54 참조) 등] 전부가 바로 여기에 속하거든요. 행
여나 비가상 소멸자를 가진 표준 컨테이너 등의 클래스를 써서 쓸모 있는 나만의 클래스를 만
들고 싶었던 분들은 자제하세요(자바의 final 클래스라든지 C# 의 sealed 클래스 같은 파
생 방지 메커니즘이 있었으면 참 좋으련만 C++에는 그런 기능이 없다는 사실이 아쉽습니다).

경우에 따라서는 순수(pure) 가상 소멸자를 두면 편리하게 쓸 수도 있습니다. 아시겠지만 순수
가상 힘수는 해당 클래스를 추상 클래스(abstract class) - 그 자체로는 인스턴스를 못 만드는
(그 타입의 객체를 생성할 수 없는) 클래스 - 로 만들지요. 하지만 어떤 클래스가 추상 클래스였으면
좋겠는데 마땅히 넣을 만한 순수 가상 힘수가 없을 때도 종종 생기게 마련입니다. 이럴 때 대
체 어떻게 할까요? 찬찬히 봅시다. 추상 클래스는 본래 기본 클래스로 쓰일 목적으로 만들어진
것이고, 기본 클래스로 쓰이려는 클래스는 가상 소멸자를 가져야 합니다. 한편 순수 가상 함수
가 있으면 바로 추상 클래스가 되지요. 종합하면 답이 간단하게 나오죠? 추상 클래스로 만들고
싶은 클래스에 순수 가상 소멸자를 선언하는 것입니다. 다음 예제에서 확인하십시오.

class AWOV	// AWOV = "Abstract w/o Virtuals""
{
public:
	virtual ~AWOV()=0;		// 순수 가상 소멸자를 선언합니다.
};

AWOV 클래스는 순수 가상 함수를 갖고 있으므로, 우선 추상 클래스입니다. 동시에 이 순수
가상 함수가 가상 소멸자이므로, 앞에서 말한 소멸자 호출 문제로 고민할 필요가 없습니다.
그런데 예상외의 복병이 하나 있으니, 이 순수 가장 소멸자의 정의를 두지 않으면 안 된다
는 것입니다.

AWOV::~AWOV(){}		// 순수 가상 소멸자의 정의

소멸자가 동작하는 순서는 이렇습니다. 상속 계통 구조에서 가장 말단에 있는 파생 클래스
의 소멸자가 먼저 호출되는 것을 시작으로, 기본 클래스 쪽으로 거쳐 올라가면서 각 기본
스의 소멸자가 하나씩 호출됩니다. 컴파일러는 ~AWOV의 호출 코드를 만들기 위해 파생
클래스의 소멸자를 사용할 것이므로, 잊지 말고 이 함수의 본문을 준비해 두어야 하는 이
죠. 만약 이 부분을 잊으면 링커 에러가 발생합니다.

참, 기본 클래스의 손에 가상 소멸자를 쥐어 주자는 규칙은 다형성(polymorphic)을 가진 기
본 클래스, 그러니까 기본 클래스 인터페이스를 통해 파생 클래스 타입의 조작을 허용하도
록 설계된 기본 클래스에만 적용된다는 사실을 알려드리고자 합니다. 이번 항목에서 보신
TimeKeeper가 바로 이것에 속합니다. AtomicClock 및 WaterClock 객체를 보면
TimeKeeper 포인터만 가지고도 이것들을 조작할 수 있을 거라는 생각을 갖게 하니까요.

모든 기본 클래스가 다형성을 갖도록 설계된 것은 아닙니다. 앞에서 살짝 언급했듯이 표준
string 타입도 그렇고, STL 컨테이너 타입은 기본 클래스는커녕 다형성의 흔적조차 볼 수
없습니다. 한편, 기본 클래스로는 쓰일 수 있지만 다형성은 갖지 않도록 설계된 클래스도 있는
데, 이런 클래스를[예를 들면 항목 6의 Uncopyable과 표준 라이브러리의 input_iterator_tag
(항목 47 참조)가 있겠습니다]는 기본 클래스의 인터페이스를 통한 파생 클래스 객체의 조작이
허용되지 않습니다. 이들에게서 가상 소멸자를 볼 수 없는 것은 로 이런 이유 때문입니다.

이것만은 잊지 말자!
*	다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 합니다. 즉, 어떤 클래스가
	가상 합수를 하나라도 갖고 있으면 이 클래스의 소멸자도 기상 소멸자이어야 합니다.
*	기본 클래스로 설계되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자
	를 선언하지 말아야 합니다.