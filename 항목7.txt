항목 7: 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자

시간 기록을 유지하는 방법은 활용에 따라 무궁무진합니다. 그래서인지 TimeKeeper 정도
의 이름을 가진 클래스를 기본 클래스로 만들어 놓은 후에 적절한 용도에 따라 이것을 파생
시키도록 설계하면 딱 알맞을 것 같습니다.

class TimeKeeper
{
public:
	TimeKeeper();
	~TimeKeeper();
	...
};

class AtomicClock: public TimeKeeper {...};
class WaterClock: public TimeKeeper {...};
class WristWatch: public TimeKeeper {...};

이 클래스의 혜택을 받는 사용자들은 시간 정보에 접근하고 싶어 합니다. 시간 계산이 어떻
게 되는지에 대해서는 신경 쓰고 싶지 않고요. 사정이 이렇기 때문에, 어떤 시간기록 객체에
대한 포인터를 손에 넣는 용도로 팩토리 함수(factory function, 새로 생성된 파생 클래스 객체
에 대한 기본 클래스 포인터를 반환하는 함수)를 만들어 두면 딱 좋을 것 같습니다.

TimeKeeper* getTimeKeeper();	// TimeKeeper에서 파생된 클래스를 통해 동적으로
								// 할당된 객체의 포인터를 반환합니다.

팩토리 함수의 기존 규약을 그대로 따라간다면 getTimeKeeper 함수에서 반환되는 객체
는 힙에 있게 되므로, 결국 메모리 및 기타 자원의 누출을 막기 위해 해당 객체를 적절히
삭제(delete) 해야 합니다.

TimeKeeper* ptk = getTimeKeeper();	// TimeKeeper 클래스 계통으로부터
									// 동적으로 할당된 객체를 얻습니다.
...					// 이 객체를 사용합니다.

delete ptk;			// 자원 누출을 막기 위해 해제(삭제)합니다.

항목 13을 보시면 객체 삭제를 사용자에게 전가하는 것은 에러 발생에 노출될 소지가 있다
는 이야기가 있고, 또 항목 18에서는 팩토리 함수의 인터페이스를 수정하면 흔히 발생할 수
있는 사용자 에러를 방지할수 있다는 이야기도 나오지만, 어쨌든 그런 이야기는 여기선 접어 
둡시다. 이번 항목에선 위의 코드에 숨어 있는 더 근본적인 약점을 다루고 또 해결
할 거니까요. 사용자가 아무리 제대로 한다고 해도, 프로그램이 어떻게 동작할지는 알 방법
이 없잖습니까.

문제는 getTimeKeeper가 반환하는 포인터가 파생(그러니까 AtomicClock)
객체에 대한 포인터라는 점과 이 포인터가 가리키는 객체가 삭제될 때는 기본 클래스 포인
터(즉, TimeKeeper* 포인터)를 통해 삭제된다는 점, 그리고 결정적으로 기본 클래스
(TimeKeeper)에 들어 있는 소멸자가 비가상 소멸자(non-virtual destructor)라는 점입니다.
실로 어처구니없는 상황입니다. 

C++의 규정에 의하면, 기본 클래스 포인터를 통해 파생 클래스 객체가 삭제될 때 그 기본 
클래스에 비가상 소멸자가 들어 있으면 프로그램 동작은 미정의 사항이라고 되어 있습니다.

대개 그 객체의 파생 클래스 부분이 소멸되지 않게 되지요. 정리하면, getTimeKeeper
함수에서 포인터를 통해 날아오는 AtomicClock 객체는 기본 클래스 포인터를 통해 삭제
될 때 AtomicClock 부분(그러니까 AtomicClock 클래스에서 정의된 데이터 멤버들)이 
삭제되지 못할 뿐만 아니라 AtomicClock의 소멸자도 실행되지 않습니다. 그러나 기본 클래스 
부분(즉, TimeKeeper 부분)은 소멸 과정이 제대로 끝나므로 결국 반쪽짜리 '부분 소멸
(partially destroyed)' 객체의 신세로 전락하는 거죠. 당연히 여러분의 소중한 자원이
누출 될 것이고, 자료구조가 오염되는 것은 물론이요, 다시 무한 짜증의 디버깅 모드에 
돌입 해야 할지도 모릅니다.

이 문제를 없애는 방법이요? 지극히 간단합니다. 사랑하는 기본 클래스에게 가상 소멸자를
선물하세요. 이젠 파생 클래스 객체를 기본 클래스 포인터로 삭제할 때 여러분이 원하는 쪽
으로 동작하게 될 것입니다. 기본 클래스의 소멸자 앞에 virtual 하나 붙여 줬을 뿐인데
객체 전부가 소멸됩니다. 파생 클래스 부분까지 몽땅 말이죠.

class TimeKeeper
{
public:
	TimeKeeper();
	virtual ~TimeKeeper();
	...
};

TimeKeeper* ptk = getTimeKeeper();
...
delete ptk;			// 이제 제대로 동작합니다.

TimeKeeper 비슷한 기본 클래스에는 대개 소멸자 외에도 가상 멤버 함수들이 더러 들어
있게 마련입니다. 파생 클래스를 구현할 때 해당 함수를 역할에 따라 맞추는 작업을 허용한
다는 의미이겠지요(항목 34 참조) 예를 들어, TimeKeeper 클래스는 현재 시각을 알려 주
는 getCurrentTime 함수를 가상 함수로 가질 수 있습니다. 이 함수는 여러 파생 클래
스에서 다른 의미로 구현되겠지요. 사정이야 어쨌든, 가상 함수를 하나라도 가진 클래스는
가상 소멸자를 가져야 하는 게 대부분 맞습니다.

가상 소멸자를 갖고 있지 않은 클래스를 만나면 이렇게 생각하면 됩니다. '아, 저 클래스는
기본 클래스로 쓰일 의지를 상실한 것이구나'라고요. 입장을 바꾸어 보아도 마찬가지인데, 기
본 클래스로 의도하지 않은 클래스에 대해 소멸자를 가상으로 선언하는 것은 좋지 않은 정신
자세입니다. 한 예로, 2차원 공간에 있는 한 점을 나타내는 클래스를 보도록 하죠.

class Point
{
public:
	Point(int xCoord, int yCoord);
	~Point();
private:
	int x, y;
};

int가 32비트를 차지한다고 가정하면, 이 Point 객체는 64비트 레지스터에 딱 맞게 들어
갈 수 있겠지요. 그리고 C나 포트란(FORTRAN) 등의 다른 언어로 작성된 함수에 넘길 일이
생길 때도 64비트 크기의 자료로 넘어갈 것입니다. 그런데 Point 클래스의 소멸자가 가상
소멸자로 만들어지는 순간, 사정이 변하기 시작합니다.

가장 함수를 C++에서 구현하려면 클래스에 별도의 구조가 하나 들어가야 합니다. 이
자료구조는 프로그램 실행 중에 주어진 객체에 대해 어떤 가상 함수를 호출해야 하는지를
결정하는 데 쓰이는 정보인 데, 실제로는 포인터의 형태를 취하는 것이 대부분이고, 대개
vptr['가상 함수 테이블 포인터(virtual table Pointer)'란 뜻입니다]이라는 이름으로 불립니다.
vptr은 가상 함수의 주소, 즉 포인터들의 배열을 가리키고 있으며 가상 함수 테이블 포인
터의 배열은 vtbl['가상 함수 테이블(virtual table)']이라고 불립니다. 가상 함수를 하나라도 갖
고 있는 클래스는 반드시 그와 관련된 vtbl을 갖고 있습니다. 어떤 객체에 대해 어떤 가상
함수가 호출되려고 하면, 호출되는 실제 힘수는 그 객체의 vptr이 가리키는 vtbl에 따라
결정됩니다. vtbl에 있는 함수 포인터들 중 적절한 것이 결되는 것이죠.

가상 함수 호출이 어떻게 구현되는지에 관해서는 사실 파고들지 않아도 됩니다. 정말 중요한 
것은 Point 클래스에 가상 함수가 들어가게 되면 Point 타입 객체의 크기가 커진다는 사실입니다.
프로그램 실행환경이 32비트 아키텍처라면, 크기가 64비트(int 두 개)에서 96비트(int 두 
개에 vptr 하나)로 커집니다. 64비트 아키텍처에서는 64비트에서 128비트로 커질 수 있습니다.2) 
64비트 시스템에서 포인터 크기는 64비트이거든요. Point 객체는 가상 함수 테이블 포인터가 
하나 추가됐을 뿐인데 크기가 무려 50%에서 100%까지 커져 버립니다. 이젠 64비트 레지스터에 
들어가긴 글렀습니다. 게다가 C 등의 다른 언어로 선언된 동일한 자료구조와도 호환성이 없어집니다. 
왜냐하면 다른 언어로 Point와 겉보기가 똑 같은 데이터 배치를 써서 선언했다고 해도 vptr만은 
어떻게 만들 수 없기 때문이죠. 결국, 다른 언어로 작성된 함수에 Point 객제를 전달하고 또 
그 함수로부터 전달받을 수있게 하려면 vptr 부분을 어떻게든 보충해 주어야 하는데, 이 
부분부터는 구현환경에 따라 세부사항이 달라지는 문제이기 때문에 이식성에 대한 기대는 접는 것이 
좋습니다.

자, 정리하고 출발선부터 잡읍시다. 어느 경우를 막론하고 소멸자를 전부 virtual로 선언하는
일은 virtual로 절대 선언하지 않는 것만큼이나 편찮은 마인드입니다. 가상 소멸자를 선언하
는 것은 그 에 가상 함수가 하나라도 들어 있는 경우에만 한정하세요. 실제로 많은
프로그래머들이 이런 식으로 머리 속에 정리해 놓고 제시더라고요.

가상 함수가 전혀 없는데도 비가상 소멸자 때문에 뒤통수를 맞는 경우도 있습니다. 한 예가 표
준 string 타입입니다. 이 타입은 가상 함수를 갖고 있지 않지만, 전후 사정 무시하고 이 타
입을 기본 클래스로 잡아버리는 일부 몰지각한 프로그래머들이 가끔 있습니다. 이렇게 말이죠.class SpecialString: public std::string // 말도 안되는 아이디어 입니다.{									// std::string은 가상 소멸자가 없단 말입니다....};::2) LLP64(혹은 P64)의 데이터 모델을 채택한 64비트 아키텍쳐의 경우만 한정한다. 참고로 LLP64는 int 및 long은 그대로 32비트로 남고 포인터만 64비트로 확장되는 모델로서, 64비트 Window(Win64)에서 채택하였다. 유닉스(UNIX)는 LP64 모델을 쓰고 있는데, 이는 int는 32비트로 남고 long 및 포인터가 64비트로 확장되는 모델이다. - 옮긴이