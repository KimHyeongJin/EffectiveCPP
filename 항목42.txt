항목 42: typename의 두 가지 의미를 제대로 파악하자

질문: 아래의 두 템플릿 선언문에 쓰인 class와 typename의 차이점이 무엇일까요?

template<class T> class Widget;		// "class"를 사용합니다.
template<typename T> class Wdiget;	// "typename"을 사용합니다.

답변: 차이가 없습니다. 템플릿의 타입 매개변수를 선언할 때는 class 와 typename의 뜻이 완전히 똑같습니다.
어떤 프로그래머 중엔 class만 고집하는 분들이 있습니다. 단지 타 이펑하기가 편하다는 이유로 좋아하더군요. 
그와 반대로 typename을 좋아하는 분들(저도 여기에 속한답니다)도 있습니다. 매개변수가 클래스 타입일 필요가 
없다고 외치는 것 같은 강단 있는 모습이 마음에 든다나요. 많지는 않지만, 어떠한 타입도 허용되는 부분에는 
typename을 쓰고 사용자 정의 타입만 쓰이는 부분에 class를 신주단지 모시듯 쓰는 프 로그래머도 몇 분 있더군요. 
하지만 어쨌든 c++의 관점에서 보면, 템플릿 매개변수를 선언히는 경우의 class 및 typename은 다시 말씀드리지만 
완전히 같은 의미를 지닙니다. 

그렇다고 언제까지나 class와 typename이 c++ 앞에서 동등한 것만은 아닙니다. typename을 쓰지 않으면 안 되는 
때가 분명히 있습니다. 이때가 언제인지를 제대로 알아 보려면, 일단 템플릿 안에서 여러분이 참조할 수 있는 이름의 
종류가 두 가지라는 것부터 이야기를 해야 할 것 같아요.

함수 템플릿이 하나 있다고 가정합시다. 이 템플릿은 STL과 호환되는 컨테이너를 받아들이 도록 만들어졌고, 이 컨
테이너에 담기는 객체논 int에 대입할 수 있습니다. 이 템플릿이 하는 일은 컨테이너에 담긴 원소들 중 두 번째 것
의 값을 출력하는 것뿐입니다. 함수 자체도 참 한심하고 만드는 방법도 존재감 부족이 이만저만 아닐 것입니다. 곧 
아래에서 보여드리 겠지만, 심지어 컴파일도 안 될 겁니다. 하지만 이런저런 부분은 일단 전부 넘어가 주세요. 제정
선이 아닌 건 맞지만 다 이유가 있는 거니까요.

//컨테이더에 들어 있는 두 번째 원소를 출력합니다. 도저히 제 정신으로 짠 코드가 아닙니다.
template< typename C >
void print2nd( const C& container )
{
	if( container.size() >=2 )
	{
		C::const_iterator iter( container.begin() ); //첫째 원소에 대한 반복자를 얻습니다. 
		
		++iter;						// iter를 두 번째 원소로 옮깁니다.
		int value = *iter;			// 이 원소를 다른 int로 복사합니다.
		std::cout<<value;			// 이 int를 출력합니다.
	}
}

필지는 이 함수 안에서 쓰이고 있는 지역변수 두 개에 강조 표시를 해 두었습니다. 하나는 iter, 또 하나는 value입니다. 
iter의 타입은 보시다시피 C::const_iterator인데, 템플릿 매개변수인 C에 따라 달라지는 타입입니다. 템플릿 내의 이름 
중에 이렇게 템플릿 매개변수에 종속된 것을 가리켜 의존 이름(dependent name)이라고 합니다. 의존 이름이 어떤 클래스 안
에 중첩되어 있는 경우가 있는데, 필자는 이 경우의 이름을 중첩 의존 이름(nested dependent name)이라고 부릅니다. 위의 
코드에서 C::const_iterator는 중첩 의존 이름입니다 사실, 정확히 하자면 중접 의존 타입 이름(nested dependent 
type name)이라고 말해야 맞습니다. 타입을 참조하는 중첩 의존 이름이란 뜻이지요.

print2nd 함수에서 쓰이는 또 하나의 지역 변수, value는 int 타입입니다. int는 템플릿 매개변수가 어떻든 상관없는 
타입 이름입니다. 이러한 이름은 비의존 이름(non-dependent name)이라고 합니다[어째서 독립 이름(independent 
name)이라고 하지 않느냐고 말씀하신다면 필자도 별로 드릴 말씀이 없습니다. 혹시나 여러분도 필자처럼 '비의존'이란 
용어가 상당히 '비호감'으로 보인다면 필자와 정신적 파장이 같은 것이니 반갑긴 합니다만, 이 바닥에서 원래 쓰여 온 용어가 
'비 의존'이니, 뭐 어쩌겠어요? 입맛 좀 몇 번 다시고 팔자이겠거니 하고 받아들이는 수밖에요].

코드 안에 중첩 의존 이름이 있으면 골치 아픈 일이 생길 수 있습니다. 바로 컴파일러가 구문분석을 할 때 애로사항이 
활짝 꽃핀다는 겁니다. 예를 들어, print2nd 함수를 이런식 으로 시작해서 바보스러움이 더욱 물씬 묻어나게 만들었다고 가정합시다.

template< typename C >
void print2nd( const C& container )
{
	C::const_iterator *x;
	...
}

언뜻 보면 C::const_iterator에 대한 포인터인 지역 변수로서 x를 선언하고 있는 것 같습니다. 하지만 주의히실 게 있습니다. 
우리 눈에 그렇게 보이는 것은 C::const_iterator가 타입이라는 사실을 "인간인 우리가 알고 있을 때만" 그렇다는 말입니다. 
그런데 C::const_iterator가 타입이 아니라면 어떻게 하죠? 우연히 const_iterator 라는 이름을 가진 정적 데이터 멤버
가 C에 들어 있다고도 볼 수 있죠. 그리고 x가 다른 전역 변수의 이름이라면 어떤 사태가 발생하는지 아세요? 이런 경우라면 
위의 코드는 지역 변수를 선언한 것이 아닙니다. 그냥 C::const_iterator와 x를 피연산자로 한 곱셈 연산 이란 말입니다! 
저 스콧 아저씨 이제 제대로 맛이 갔군, 그렇게 보이는 게 당연하겠죠. 하지만 얼마든지 가능한 일입니다. C++ 구문분석기를 
작성히는 개빌차는 가능한 모든 입력에 대해 온 촉각을 곤두세워야 합니다. 이런 돼먹지 않은 입력도 포함해서 말이죠. 