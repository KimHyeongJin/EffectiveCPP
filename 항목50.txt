항목 50: new 및 delete를 언제 바꿔야 좋은 소리를 들을지를 파악해 두자.

많고 많은 것들 중에 왜 하필 컴파일러가 열심히 장만해 준 operator new와
operator delete를 바꾸고 싶은 걸까요? 
다음과 같이 세 가지의 이유가 있습니다.

1. 잘못된 힙 사용을 탐지하기 위해
new한 메모리에 delete를 하는 것을 잊어버리면 메모리 누수가 발생합니다.
한 번 new한 메모리를 두 번 이상 delete하면 미정의 동작이 발생하고 말지요.
만일 할당된 메모리 주소의 목록을 operator new가 유지해 두고 operator
delete가 그 목록으로부터 주소를 하나씩 제거해 주게 만들어져 있다면, 이런
식의 실수는 쉽게 잡아낼 수 있을 것입니다. 또한 프로그래밍을 하다가 이런저런
실수를 하다 보면 데이터 오버런(overrun, 할당된 메모리 블록의 끝을 넘어 
뒤에 기록하는 것)이 발생할 수 있습니다. 이런 경우에 대비하여 사용자 정의
operator new를 활용한다면, 요구된 크기보다 약간 더 메모리를 할당한 후에
사용자가 실제로 사용할 메모리의 앞과 뒤에 overrun/underrun 탐지용 
바이트 패턴[일명 "경계표지(signature)"]을 적어두도록 만들 수 있을 것입니다.
operator delete는 누군가가 이 경계표지에 손을 댓는지 점검하도록 만들고
말이죠. 만일 이 경계표지 부분에 원래와 다른 정보가 적혀 있다면 할당된 메모리
블록을 사용하는 도중에 overrun이나 underrun이 발생한 것이므로, operator
delete는 이 사실을 로그로 기록함으로써 문제를 일으킨 포인터 값을 남겨
놓을 수 있겠지요.

2. 효율을 향상시기기 위해
컴파일러가 제공하는 기본 버전의 operator new 및 operator delete
함수는 대체적으로 일반적인 쓰임새에 맞추어 설계된 것입니다. 실행 기간이
짧지 않은 프로그램(예를 들면 웹서버 같은)에서 잘 돌아가야 하며, 1초
안에 끝나는 프로그램에서도 별 문제가 없어야 합니다. 큰 블록만 할당하든
작은 블록만 할당하든, 아니면 크고 작은 블록이 섞여서 할당되든 간에, 이렇게
저렇게 계속되는 메모리 할당 요청을 무난하게 처리해야 합니다. 프로그램 실
행 내내 사용하는 블록 몇 개를 동적 할당하는 작업부터 수명이 짧은 객체를
아주 많이 할당했다가 해제했다가 하는 작업까지, 여러 가지 할당 유형도 소
화할 수 있어야 합니다. 힙 단편화(fagmentation)에 대한 대처 방안도
없으면 안 됩니다. 단편화를 방치했다가 이리저리 흩어진 작은 메모리 블록들
사이에 낀 짜투리 공간을 모으면 충분한 크기가 되는데 불구하고 메모리 블록
할당에 실패할 수도 있으니 말입니다.

