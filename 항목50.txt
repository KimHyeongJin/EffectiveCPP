항목 50: new 및 delete를 언제 바꿔야 좋은 소리를 들을지를 파악해 두자.

많고 많은 것들 중에 왜 하필 컴파일러가 열심히 장만해 준 operator new와
operator delete를 바꾸고 싶은 걸까요? 
다음과 같이 세 가지의 이유가 있습니다.

1. 잘못된 힙 사용을 탐지하기 위해
new한 메모리에 delete를 하는 것을 잊어버리면 메모리 누수가 발생합니다.
한 번 new한 메모리를 두 번 이상 delete하면 미정의 동작이 발생하고 말지요.
만일 할당된 메모리 주소의 목록을 operator new가 유지해 두고 operator
delete가 그 목록으로부터 주소를 하나씩 제거해 주게 만들어져 있다면, 이런
식의 실수는 쉽게 잡아낼 수 있을 것입니다. 또한 프로그래밍을 하다가 이런저런
실수를 하다 보면 데이터 오버런(overrun, 할당된 메모리 블록의 끝을 넘어 
뒤에 기록하는 것)이 발생할 수 있습니다. 이런 경우에 대비하여 사용자 정의
operator new를 활용한다면, 요구된 크기보다 약간 더 메모리를 할당한 후에
사용자가 실제로 사용할 메모리의 앞과 뒤에 overrun/underrun 탐지용 
바이트 패턴[일명 "경계표지(signature)"]을 적어두도록 만들 수 있을 것입니다.
operator delete는 누군가가 이 경계표지에 손을 댓는지 점검하도록 만들고
말이죠. 만일 이 경계표지 부분에 원래와 다른 정보가 적혀 있다면 할당된 메모리
블록을 사용하는 도중에 overrun이나 underrun이 발생한 것이므로, operator
delete는 이 사실을 로그로 기록함으로써 문제를 일으킨 포인터 값을 남겨
놓을 수 있겠지요.

2. 효율을 향상시기기 위해
컴파일러가 제공하는 기본 버전의 operator new 및 operator delete
함수는 대체적으로 일반적인 쓰임새에 맞추어 설계된 것입니다. 실행 기간이
짧지 않은 프로그램(예를 들면 웹서버 같은)에서 잘 돌아가야 하며, 1초
안에 끝나는 프로그램에서도 별 문제가 없어야 합니다. 큰 블록만 할당하든
작은 블록만 할당하든, 아니면 크고 작은 블록이 섞여서 할당되든 간에, 이렇게
저렇게 계속되는 메모리 할당 요청을 무난하게 처리해야 합니다. 프로그램 실
행 내내 사용하는 블록 몇 개를 동적 할당하는 작업부터 수명이 짧은 객체를
아주 많이 할당했다가 해제했다가 하는 작업까지, 여러 가지 할당 유형도 소
화할 수 있어야 합니다. 힙 단편화(fagmentation)에 대한 대처 방안도
없으면 안 됩니다. 단편화를 방치했다가 이리저리 흩어진 작은 메모리 블록들
사이에 낀 짜투리 공간을 모으면 충분한 크기가 되는데 불구하고 메모리 블록
할당에 실패할 수도 있으니 말입니다.

이렇듯 메모리 관리자에 대한 요구사항은 정말 가지각색입니다. 컴파일러가 기본
적으로 제공하는 operator new 함수와 operator delete 함수가 지극히 대중
적이고 온건지향 스타일의 전략을 취한 것도 놀랄 만한 일은 아니라는 이야기죠.
결국 이들은 모든 사용자들로부터 욕먹지 않게끔 적당히 무난하게 동작하지만,
어느 누구에게도 칭찬을 듣지는 못합니다. 그렇기 때문에, 만일 개발자가 자신의
프로그램이 동적 메모리를 어떤 성향으로 사용하는지를 제대로 이해하고 있다면,
사용자 정의 operator new와 operator delete를 자신이 만들어 쓰는 편이
기본제공 버전을 썼을 때보다 더 우수한 성능을 낼 확률이 높습니다. 여기서
"우수한 성능"이란, 실행 속도가 빠르고(간혹 10의 몇 제곱 배 단위로 빠를 
때도 있습니다) 메모리도 적게 차지한다는(최고 50%나 덜 차지할 때도 있고요)
뜻입니다. 응용프로그램에 따라서는(모든 분야를 놓고 말하는 것은 절대 아닙니
다만) new와 delete를 사용자 정의 버전으로 바꾸는 것만으로 아주 쉽게 괄목
할 만한 성능 향상을 뽑아내기도 합니다.

3. 동적 할당 메모리의 실제 사용에 관한 통계 정보를 수집하기 위해
입맛에 맞게 동작하는 new 및 delete를 무작정 작성해 보겠다고 맨땅에 헤딩부터
하는 것보다는, 여러분이 만드는 소프트웨어가 동적 메모리를 어떻게 사용하는지에
관한 정보를 수집하는 세심한 자세가 여러모로 좋겠지요. 할당된 메모리 블록의
크기는 어떤 분포를 보이나요? 각각의 사용 기잔은 또 어떤 분포를 보이나요? 
메모리가 할당되고 해제되는 순서가 FIFO["선입선출(first in, first out)"]
인가요, LIFO["후입선출(Last in, first out)"]인가요, 아니면 마구잡이 순서
에 가깝나요? 시간 경과에 따라 사용 패턴이 바뀌나요? 다시 말해서, 각 실행 단계
마다 여러분의 소프트웨어가 보이는 메모리 할당/해제 패턴이 확연한 차이를 보이
나요? 한 번에 실제로 쓰이는 동적 할당 메모리의 최대량[다른 말로 "최고수 위선
(high water mark)"]은 어떤가요? 사용자 정의 operator new 및 operator
delete를 사용하면 이런 정보를 아주 쉽게 수집할 수 있습니다.

개념적으로 보면 operator new를 여러분이 직접 만드는 작업은 사실 별로 어려운
것이 아닙니다. 한 예로, 버퍼 오버런 및 언더런을 탐지하기 쉬운 형태로 만들어
주는 전역 operator new를 후다닥 만들어 봤습니다. 자잘한 부분에서 틀린게 좀
많긴 하지만, 걱정은 조금 뒤에서 늘어놓도록 하죠.

static const int singnature = 0xDEADBEEF;
typedef unsigned char Byte;

// 이 코드는 고쳐야 할 부분이 몇 개 있습니다. 아래를 읽어 주세요.
void* operator new(std::size_t size) throw(std::bad_alloc)
{
	using namespace std;

	// 경계표지 2개를 앞뒤에 붙일 수 있을 만큼만 메모리 크기를 늘립니다.
	size_t realSize = size + 2*sizeof(int);			

	// malloc을 호출하여 실제 메모리를 얻어 냅니다.
	void* pMem = malloc(realSize);
	if(!pMem)throw bad_alloc();

	// 메모리 블록의 시작 및 끝부분에 경계표지를 기록합니다.
	*(static_cast<int*>(pMem)) = signature;
	*(reinterpret_cast<int*>(static_cast<Byte*>(pMem)+realSize-
	sizeof(int))) = signature;

	// 앞쪽 경계표지 바로 다음의 메모리를 가리키는 포인터를 반환합니다.
	return static_cast<Byte*>(pMem) + sizeof(int);
}

