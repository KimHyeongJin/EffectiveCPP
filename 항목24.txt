항목 24: 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 선언하자

 "클래스에서 암시적 타입 변환을 지원하는 것은 일반적으로 못된 생각이다"라는 필자의 이야기를 
 아직도 기억하고 계실지도 무르겠습니다. 물론 이 규칙에도 예외가 있는데, 가장 흔한 예외 중 
 하나가 숫자 타입을 만들 때입니다. 예를 들어 유리수를 나타내는 클래스를 만들고 있다면, 정수 
 에서 유리수로의 암시적 변환은 허용하자고 판단하더라도 크게 어이없거나 하진 않을 것입니다. 
 C++가 기본으로 제공하는 int->double 변환과 별반 다르지 않잖아요. 지금부터 보실 코드는 
 이런 결정에 따라 만들기 시작한 Rational 클래스입니다.

 class Rational
 {
 public:
	// int 에서 Rational 로의 암시적 변환을 허용하기 위해 생성자에 일부러 explicit
	// 를 붙이지 않았다.
	Rational(int numerator = 0, int denominator = 1);
	int numerator() const;// 분자 및 분모에 대한 접근용 함수
	int denominator() const;// 자세한 내용은 항목 22에 확인하세요.
private:
	...
 };

 유리수를 나타내는 클래스이니 덧셈이나 곱셈 등의 수치 연산은 기본으로 지원하고 싶겠죠. 그런
 데  이들을 어떤 식으로 지원해야 할지에 대해선 아직도 머리 속이 흔란스럽습니다. 멤버 함수가 
 나을 까요? 비멤버 함수가 좋을까요? 아니면 비멤버 프렌드 함수가 좋을까요? 핏줄 곳곳에 객체 
 지향의  맥박이 요동치는 여러분의 유전자는 이렇게 외치고 있겠지요. "막히면 객체 지향 파워로 
 돌파다!"라고요 물론 확실한 부분이 없는 것은 아닙니다. 이를테면 유리수의 곱셈은 Rational 
 클래스 자 체와 관련이 있으니까, operator*는 Rational 클래스 안에 구현해 넣는게 자연스러
 울 것 같습니다. 직감적인 예상과 달리, 어떤 클래스와 관련된 함수를 그 클래스의 멤버로 두는 
 것은 (실질 적인) 객체 지향 원칙에 맞장을 뜨는 것과 같을 수 있다며 열심히 떠들어댄 항목 23
 이 좀 신경  쓰이지만, 일단 그 이야기는 옆으로 제쳐두고 operator*를 Rational의 멤버 함수
 로 만드는 데 만 집중해 봅시다.

class Rational 
{ 
public:
	...
	const Rational operator*(const Rational& rhs) const;
};

[이 함수가 어째서 저런 식으로 선언되었는지에 대해(상수를 값으로 반환하고, 상수에 대한 참조자를
인자로 받아들이도록) 느낌이 안 오시는 분은 항목 3, 20, 21을 일고 와 주세요]

이렇게 설계해 두면 유리수 곱셈을 아주 쉽게 할 수 있게 됩니다.

Rational oneEighth(l , 8); 
Rational oneHalf(l, 2); 
Rational result = oneHalf * oneEighth; // 좋습니다.
result = result * oneEighth; // 좋아요.


그러나 아직도 성에 안차는 부분이 있습니다. 여러분은 혼합형(mixed-mode) 수치 연산도 가 능했
으면 좋겠다고 생각합니다. 바꿔 말해서 Rational을 int 같은 것과도 곱하고 싶다는 것입니다. 
어쨌든 두 숫자를 함께 '곱한다는 것'만큼 자연스러운 것은 없잖아요. 어쩌다 다른 종류의 숫자일지
라도 말이죠.

하지만 여러분이 원했던 그 혼합형 수치 연산을 해 보려고 들었더니, 이게 반쪽짜리 연산이라는 사
실을 곧알게 됩니다.

result = oneHalf * 2; // 좋군! 
result = 2 * oneHalf; // 에러!

웬지 우울한 일이 생길 것 같은 예감입니다. 곱셈은 기본적으로 교환볍칙이 성립해야 하잖아요. 수
학시간에 한 번이라도 졸지 않은 분이라면 아실 겁니다.

이 문제의 원인은 위의 두 예제를 함수 형태로 바꾸어 써보면 바모 드러납니다. 
result = oneHalf.operator*(2); // 좋군! 
result = 2.operator*(oneHalf); // 에러!

첫 번째 줄에서 oneHalf 객체는 operator* 함수를 멤버로 갖고 있는 클래스의 인스턴스이므로, 
컴파일러는 이 함수를 호출합니다. 하지만 두 번째 줄에서 정수 2에는 클래스 같은 것이 연관되어 
있지 않기때문에, operator* 멤버 함수도 있을리가 없습니다. 컴파일러는 아래처럼 호출할 수있는 
비멤버 버전의 operator*(네임스페이스 혹은 전역 유효범 위에 있는 operator*)도 찾아봅니다.

result = operator*(2 , oneHalf); // 에러! 

그러나 작금의 예제에서는 int와 Rational을 취하는 비멤버 버전의 operator*가 없으므로 탐색
은 실패하고 컴파일 에러가 나게 됩니다.

자 그럼 위에서 제대로 성공한 함수 호출문을 다시 들여디봅시다. 두 번째 매개변수가 정수 2 인데, 
Rational::operator*의 선언문을 보면 인자로 Rational 객체를 받도록 되어 있습니다. 이게 
대체 무슨 조화일까요? 2가 어디에선 먹히고 어디에선 안 먹히는 이유가 무엇 일까요?

조화는 바로 암시적 타입 변환(implicit type conversion)에 있습니다. 컴파일러는 여러분이 이 
함수에 int를 넘겼으며 함수 쪽에선 Rational을 요구한다는 사실을 알고 있으나, 이 int를 Rati
onal 클래스의 생성자에 넘겨 호출하면 Rational로 둔갑시킬 수 있다는 사실도 알고 있습니다. 그
래서 컴파일러는 자기가 알고 있는 대로 한것입니다. 다시 말해, 마치 아래와 같이 작성된 코드인 
것처럼 처리한 거죠.

const Rational temp(2); // 2로부터 임시 Rational 객체를 생성합니다. 
result = oneHalf * temp; // oneHalf. operator*(temp); 와 같습니다. 

물론 컴파일러가 이렇게 동작한 것은 명시호출(explicit)로 선언되지 않은 생성자가 있기 때문입니다.
Rational 생성자가 만약 명시호출 생성자였으면 다음의 코드 중 어느 쪽도 컴파일되지 않습니다.

result = oneHalf * 2; // 에러!(명시호출 생성자에 의해) 2를 Rational로 바꿀 수 없습니다. 
result = 2 * oneHalf; // 역시 에러입니다. 문제도 같습니다.

이렇게 하면 혼합형 수치 연산에 대한 지원은 수포로 돌아가지만, 최소한 두 문장의 동작은 일관되게 
유지되겠지요.

하지만 여기서 끝이 아니죠. 동작도 일관되게 유지하고 흔합형 수치 연산도 제대로 지원 하자는 것이 
목적이잖아요. 다시 말해 앞에서 본 두 개의 문장이 전부 컴파일되는 설계를 해야 합니다. 힘드시겠
지만 다시 그 문장으로 되돌아와서, Rational 생성자가 명시호출이 아닐 때도 어째서 첫 번째 문장
은 컴파일되는데 두 번째 문장은 안 되는지 고민해 보도록 합시다.

result = oneHalf * 2; // 컴파일됩니다(비명시호출 생성자와 함께 ) 
result = 2 * oneHalf; // 안 됩니다(비명시호출 생성자와 함께 했는데도)

이로써 알 수 있는 사실은, 암시적 타입 변환에 대해 매개변수가 먹혀들려면 매개변수 리스트에 들어 
있어야만 한다는 것입니다. 그러니까 호출되는 멤버 함수를 갖고 있는(쉽게 말해 this가 가리키는) 
객체에 해당하는 암시적 매개변수에는 암시적 변환이 먹히지 않습니다. 첫 번째 문장이 컴파일되고 두 
번째 문장이 컴파일되지 않는 이유도 바로 이것입니다. 전자의 경우는 매개변수 리스트에 있는 매개변
수가 쓰이고 있지만, 후자의 경우는 그렇지 않죠.

하지만 여러분은 여전히 혼합형 수치 연산을 지원하고 싶어 죽겠습니다. 그리고 어떻게 해야 할지도 
이제는 확실해진 것 같고요. 바로 operator*를 비멤버 함수로 만들어서, 컴파일러 쪽에서 모든 
인자에 대해 암시적 타입 변환을 수행하도록 내버려 두는 것입니다.

class Rational
{
	...		// operator*가 없습니다.
};

const Rational operator*(const Rational& lhs,	// 이제는 비멤버 함수입니다.
						const Rational& rhs)
{
	return Rational(lhs.numerator()*rhs.numerator(), 
					lhs.deominator()*rhs.denominator());
}

Rational oneFourth(1, 4);
Rational result;

result = oneFourth * 2;	// 이건 원래 됐었죠.
result = 2 * oneFourth;	// 이것도 됩니다.

확실히 해피엔딩이긴 한 것 같은데요. 그럼에도 불구하고 걱정거리 하나가 있습니다. 진정 
operator* 함수는 Rational 클래스의 프렌드 함수로 두어도 될까요?

지금의 예제에서는 '아니오'라고 답해야 옳습니다. operator*는 완전히 Rational의 public 인터
페이스만을 써서 구현할 수 있기 때문입니다. 그리고 그렇게 하는 방법들 중 하나를 위의 코드에서 
보신 거고요. 그러고 보니 여기서 한 가지 중요한 결론을 뽑을 수 있게 되었습니다. "멤버 함수의 반
대는 프렌드 함수가 아니라 비멤버 함수이다"라는 것입니다. 어떤 클래스와 연관 관계를 맺어 놓고는 
싶은데 멤버 함수이면 안 되는(모든 인자에 대해 타입 변환이 필요하다든가 하는 이유로) 함수에 대해, 
이런 것들은 프렌드로 만들어 버리면 다 해결된다고 가정하는 안타까운 c++ 프로그래머를 주변에서 너
무도 많이 봅니다. 이번 항목에서 보신 예제는 그런 생각이 잘못됐음을 입증하는 예제로도 큰 의미를 
갖고 있습니다. 프렌드 힘수는 피할 수 있으면 피하도록 하십시오. 사실 '프렌드(親뽕)'들 때문에 고
마워할 일 보다 골치 썩을 일이 많아지는 것은 c++나 우리네 인간살이나 매한가지랍니다. 아, 물론 
어떤 상황에서는 프렌드 관계를 꼭 맺을 펼요도 있습니다. 그러나 '멤버 함수이변 안되니까'가 반드시 
'프렌드 함수이어야 해'를 뜻하진 않는다는 사실만은 불변입니다. 

이번 항목에서 여러분은 진실과 '진실일 수밖에 없는' 진실을 보셨습니다만, 이것이 전부는 아니랍
니다. 객체 지향 C++에서 템플릿 C++(무슨 소린지 모르시는 분은 항목 1을 보세요)로 눈을 돌려 
Rational을 클래스가 아닌 클래스 템플릿으로 만들다 보면, 고민해야 할 문제 점이 지금 것과 다르고 
이것을 해결하는 방법도 또 다르며 여러분의 머리뚜껑을 몇 번은 열 었다 닫았다 할 설계 관련 사항
들도 완전히 다릅니다. 이들 문제점, 해결방법, 관련 사항들 은 항목 46에서 만나보실 수 있습니다.

이것만은 잊지 말자!
* 어떤 함수에 들어가는 모든 매개변수(this 포인터가 가리키는 객체도 포함해서)에 대해 타입 
변환을해 줄 필요가 있다면 그 힘수는 비멤버여야 합니다. 