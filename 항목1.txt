1 C++에 왔으면 C++의 법을 따릅시다.
여러분이 어떤 프로그래밍 언어를 어떻게 써 왔는지는 상관없습니다. 어쨌든 중요한 건 C++
는 익숙해지는 데 살짝 시간이 펼요해 보인다는 겁니다. 제공하는 기능의 범위만 해도 어마
어마한데다가 강력함까지 지고 있는 C++이지만, 이 언어에서 뿜어져 나오는 힘을 자유자
재로 휘두르면서 기능을 효과적으로 활용하기 위해서는 여러분의 행동방식과 사고방식을
C++ 스타일로 만들 필요가 있습니다. 이 책 전체가 그 방법에 대한 내용이지만, 다른 것들
보다 좀더 우선적이고 근본적인 것들이 몇 가지 있는 것은 사실이고, 그 중 '가장' 큰본적인
것들을 다루고 있는 단원이 제1장입니다.

항목 1: C++ 언어들의 연합체로 바라보는 안목은 필수

초창기의 C++는 단순히 C 언어에 객체 지향 기능 몇 가지가 결합된 형태였습니다. 오죽하
면 C++의 처음 이름조차도 이 점을 드러내려는 듯 "클래스를 쓰는 C(C with Classes)"였겠
습니까.

아시다시피 C++는 그 후 꾸준한 성장을 거쳤습니다. 단지 '클래스를 쓰는 C'라고는 말할
수 없을 만큼 아이디어, 기능, 프로그래밍 전략들을 취해 자기 것으로 만드는 데 있어 점점
대담하고 과감한 행보를 보였습니다. 예외는 함수 구성방식의 헤게모니를 크게 바꾸었습니다.
(항목 29 참조). 템플릿은 프로그램 설계에 대한 새로운 사고방식을 우리에게 선사했으며(항목
41 참조), STL은 거의 어느 누구도 본 적 없을 듯한 '확장성'에 대한 지평을 열었습니다.

이렇게 발전한 오늘날의 C++는 다중패러다임 프로그래밍 언어(multiparadigm programming
language)고 불립니다. 절차적(procedural) 프로그래밍을 기본으로 하여 객체지향(object-
oriented), 함수식(functional), 일반화(generic) 프로그래밍을 포함하며 메타프로그래밍(metapro-
gramming) 개념까지 지원하고 있습니다. 이런 엄청난 표현력과 유연성 덕택에 C++는 소프
트웨어 개발에 있어 대체할 만한 것이 없는 도구가 되었지만, 혹자에게는 어느 정도 혼동을
줄 여지가 있는 것도 사실입니다. 지원하는 프로그래밍 마다 '적절한 사용' 규칙이 있다
해도 예외가 없는 경우는 못 본 것 같고요. 어지럽습니다. 그렇다면 C++는 대체 어떻게 이
해해야 잘했다고 소문이 날까요?

가장 쉬우면서 정확한 방법을 알려드리죠. 
* C++를 단일 언어로 바라보는 눈을 넓혀, 상관관계가 있는 여러 언어들의 연합체(federation)
로 보십시오. 그러고 나서 각 언어에 관한 규칙을 각개 격파하는 거죠. 이렇게 해 가면 시각이 
단순해지고 명확해지며, 기억하기도 편해집니다. 

물론, 규칙은 언어마다 정도의 차이는 있겠으나 다를 수 있습니다. C++를 제대로
따라잡으려면, 이 언어가 여러 개의 하위 언어(sublanguage)를 제공한다는 점을 새기고 있어
야 합니다. 뭐 그렇다고 한숨 나올 일은 아닙니다. 하위 언어는 아래의 네 가지뿐이니까요.

* C
C++를 처음 배우는 사람조차도 알고 있는 불변의 사실이 이겁니다. C++는 여전히
를 기본으로 하고 있습니다. 블록, 문장, 선행 처리자, 기본제공 데이터타입, 배열, 포
인터 등 모든 것이 C에서 왔습니다. 뭐, C에 대응되며 그보다 월등한 C++만의 것들이
상당히 많이 제공되고 있긴 하지만[예를 들어 항목 2(선행 처리자 대신 쓸 수 있는 것들)
및 항목 13(자윈을 관리하는 데 객체를 사용하는 방법) 참조], 어쨌든 C만 쏙 뽑아 써도 됩
니다. 이렇게 하다 보면 효과적인 프로그래밍을 위한 규칙을 C에 적용할 수 있는 범위
가 아주 좁아지겠지요. 템플릿도 없고, 예외도 없고, 오버 로딩도 없고, 등등 말입니다.

* 객체 지향 개념의 C++ 
이 부분에 '클래스를 쓰는 C'에 관한 것이 모두 해당됩니다.
그러니까 클래스(생성자와 소멸자 개념까지), 캡슐화, 상속, 다형성, 가상 함수(동적 바인딩)
등이지요. 우리가 학교에서 웠던 객체 지향 설계의 규칙들 대부분이 그대로 들어맞는
부분이라고 보변 되겠습니다.

* 템플릿 C++ 
C++의 일반화 프로그래밍 부분으로, 많은 프로그래머들이 경험해 보지
않은 영역 중 하나이지요. 오늘날 이 템플릿이 C++에 끼치는 영향은 가히 전방위적이
기 때문에, 어지간히 괜찮다고들 하는 프로그래밍 규칙에서는 저마다의 용도에 맞춘
템플릿 구문 하나쯤은 흔히 발견할 수 있습니다(항목 46 만 보아도 타입 변환 기능을 제공
하기 위해 템플릿 함수를 사용하는 예를 볼 수 있지요). 그뿐 아니라 템플릿의 주체 못할
강력함이 너무나도 크고 훌륭하다 보니 완전히 새로운 프로그래멍 패러다임이 파생되
기까지 했습니다. 이름하여 템플릿 메타프로그래밍(template metaprogramming : TMP)이
란 것이죠. TMP에 대한 이야기는 항목 48에서 전반적으로 다루긴 했지만, 독자 여러분
이 골수 템플릿 중독자가 아닌 한 미리 겁을 먹고 걱정할 것까지는 없습니다. TMP의
세계는 주류 C++ 프로그래밍과 맞닿아 돌아가지 않는 조금 다른 세계이니까요.

* STL 
STL은 이름에서 알 수 있듯이 템플릿 라이브러리입니다. 하지만 대단히 특별한
템플릿 라이브러리라고 말할 수 있습니다. STL의 세계는 컨테이너(container), 반복자
(iterator), 알고리즘(algorithm)과 함수 객체(function object)가 만수산 드렁칡처럼 얽혀
돌아가는 것을 규약으로 삼고 있으나, 템폴릿과 라이브러리는 얼마든지 다른 아이디어
를 중심으로 만들어질 수 있습니다. 또한 STL은 나름대로 독특한 사용규칙이 있어서,
STL을 써서 프로그래밍하려면 그 규약을 따르면 됩니다.

자, 이렇게 네 가지의 하위 언어들이 C++를 이루고 있다는 점을 마음에 새기십시오. 그리
고 이제는 효과적인 프로그램 개발을 위해 한 하위 언어에서 다른 하위 언어로 옮겨 가면서
대응 전략을 빠규어야 하는 상황이 오더라도 당황하지 말아야 합니다. 예를 들어, C 스타일
로만 쓰고 있으면 기본제공(즉, C의 그것과 비슷한) 타입에 대해서는 "값 전달이 참조 전달보
다 대개 효율이 더 좋다"라는 규칙이 통하지만, C++의 C 부분만 쓰다가 객체 지향 C++로
옮겨 가면 사용자 정의 생성자/소멸자 개념이 생기면서 상수 객체 참조자에 의한 전달
(pass-by-reference-to-const) 방식이 더 좋은 효율을 보입니다. 이런 현상은 템플릿 C++를
쓰게 될 때 특히 두드러지는데, 왜냐하면 템플릿 C++의 세계에서는 여러분이 손에 들고 있
는 객체의 타입조차 알 수 없기 때문입니다. 그러나 STL 쪽으로 넘어오면 전세가 또 바뀝
니다. STL을 배우다 보면 반복자와 함수 객체가 C의 포인터를 본떠 만든 것이란 점을 알게
되고, 그렇기 때문에 STL의 반복자 및 함수 객체에 대해서는 값 전달에 대한 규칙이 다시
재 힘을 발휘하게 됩니다(매개변수 전달 방법 중 무엇을 선택할지에 대한 자세한 사항은 항목 20
에서 살펴보도록 합시다).

C++는 한 가지 프로그래밍 규칙 아래 똘똘 뭉친 통합 언어(unified language)가 아니라 네
가지 하위 언어의 연합체입니다. 각각의 하위 언어가 자신만의 규칙을 갖고 있지요. "하위
언어들로 구성되어 있다"라는 점을 꼭 새겨 두도록 하세요. 일단 이렇게만 하면 C++ 이해
의 관문에 들어서기가 대단히 쉬워질 것입니다.

이것만은 잊지 말자!
* C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라집니다. 그 경우란, 바로
C++의 어떤 부분을 사용하느냐입니다.