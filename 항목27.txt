항목 27: 캐스팅은 절약, 또 절약! 잊지 말자

"어떤 일이 있어도 타입 에러가 생기지 않도록 보장한다." C++의 동작 규칙은 바로 이 철
학을 바탕으로 설계되어 있습니다. 즉, 이론적으로 C++ 프로그램은 일단 컴파일만 깔끔하
게 끝나면 그 이후엔 어떤 객체에 대해서도 불안전한 연산이나 말도 안되는 연산을 수행하
려 들지 않는다는 것입니다. 내일까지 짜내라는 팀장의 압박만큼 존재감 있는 보장입니다.
아마 가볍게 지나치기에도 힘들 거예요.

그런데 공교롭게도 C++에는 이 타입 시스템을 가볍게 배대뒤치기할 수 있는 괴물이 있으니, 
바로 캐스트(Cast)라고 불리는 녀석입니다. 캐스트는 온갖 골칫거리를 다 몰고 다니는 풍
운아이자, C++ 코드의 겉모습을 늙게 만드는 피부노화의 원흉이라 할 수 있겠습니다. 이
녀석이 만드는 골칫거리 중 어떤 것은 간단히 찾을 수도 있지만, 또 어떤 것은 찾아내기 
어려운 것도 있답니다. C나 자바 아니면 C#을 쓰다가 C++로 오신 독자 분들은 다시 빨간 
펜 쥐실 준비를하십시오. 그분들이 쓰시던 언어에서는 캐스팅이 필요한 경우가 진짜로 
있기도 하고 또 위험성도 적었을 거예요. 하지만 C++는 C가 아닙니다. 자바도 아니고요. 
C# 과도 다릅니다. C++에서 캐스팅은 정말로 조심해서 써야 히는 기능입니다.

일단 몸을 푸는 기분으로 캐스팅 문법부터 정리하고 들어갑시다. 똑같은 캐스트인데 쓰는
방법이 세 가지나 있거든요 우선, C 스타일의 캐스트입니다.

(T) 표현식	// 표현식 부분을 T 타입으로 캐스팅합니다.

다음은 함수 방식 캐스트입니다. 문법이 함수호출문 같지요.

T(표현식)		// 표현식 부분을 T 타입으로 캐스팅합니다.

어떻게 쓰든 이들이 가진 의미는 똑같습니다. 단지 괄호를 어디에 썼느냐만 디를 뿐이죠. 
필자는 이 두 형태를 통틀어 '구형 스타일의 캐스트'라고 부르겠습니다.

C++는 네 가지로 이루어진 새로운 형태의 캐스트 연산자를 독자적으로 공합니다(신형 스
타일의 캐스트 혹은 C++ 스타일의 채스트라고 부르죠).

const_cast<T>(표현식)
dynamic_cast<T>(표현식)
reinterpret_cast<T>(표현식)
static_cast<T>(표현식)

각 연산자는 나름대로의 목적이 있습니다.

*	const_cast
	객체의 상수성(constness)을 없애는 용도1)로 사용됩니다. 이런 기능을 가진 C++ 
	스타일의 캐스트는 이것밖에 없습니다.

*	dynamic_cast
	이른바 '안전한 다운캐스팅(safe downcasting)'을 할 때 사용하는 연산자입니다. 
	즉, 주어진 객체가 어떤 클래스 상속 계통에 속한 특정 타입인지 아닌지를 결정하는 
	작업에 쓰입니다. 구형 스타일의 캐스트 문볍으로는 흉내조차도 낼 수 없는 유일한 
	캐스트이기도 합니다. 덤으로, 신경 쓰일 정도로 런타임 비용이 높은 캐스트 연산자
	로도 유일하고요(이 부분에 대한 이야기는 조금 뒤에서 자세히 하겠습니다).

*	reinterpret_cast
	포인터를 int로 바꾸는 등의 하부 수준 캐스팅을 위해 만들어진 연산자로서, 이것의 
	적용 결과는 구현환경에 의존적입니다(이식성이 없다는 뜻이죠). 이런 캐스트는 하부 
	수준 코드 외에는 거의 없어야 합니다. 필자 역시 이 책에서 이 캐스트를 딱 한 번 
	썼는데, 그것도 원시 메모리용 디버깅 할당자를 작성히는 방법에 대해 의견을 제시할 
	때뿐이었습니다(항목 50 참조).

*	static_cast 
	암시적 변환[비상수 객체를 상수 객체로 바꾸거나(항목 3처럼), int를	double로 
	바꾸는 등의 변환]을 강제로 진행할 때 사용합니다. 흔히들 이루어지는 타입	변환을 
	거꾸로 수행하는 용도(void*를 일반 타입의 포인터로 바꾸거나, 기본 클래스의 포
	인터를 파생 클래스의 포인터로 바꾸는 등)로도 쓰입니다. 물론 상수를 비상수 객체
	로 캐스팅히는 데 이것을 쓸 수는 없습니다(위에서 말했지만 const_cast 연산자밖에
	안됩니다).

1) 혹은 휘발성(volatileness)을 제거하는 용도로 쓰인다.-옮긴이

구형 스타일의 캐스트는 요즘도 여전히 적법하게 쓰일 수 있지만, 그보다는 C++ 스타일의
캐스트를 쓰는 것이 바람직합니다. 우선, 코드를 읽을 때 알아보기 쉽기 때문에(사람 눈에도
그렇고 grep 동의 검색도구에도 그렇고요), 소스 코드의 어디에서 C++의 타입 시스템이 망가
졌는지를 보는 작업이 편해집니다. 둘째, 캐스트를 사용한 목적을 더 좁혀서 지정하기
때문에 컴파일러 쪽에서 사용 에러를 진단할 수 있습니다. 무슨 말인고 하니, 상수성을 없애
려고 한 부분에다가 const_cast 대신에 다른 신형 스타일의 캐스트를 실수로 썼다면 코
드 자체가 컴파일되지 않으므로 좋다는 것입니다.

개인적으로 제가 구형 스타일의 캐스트를 쓰는 경우는 딱 한 군데 같아요. 객체를 인자로
받는 함수에 객체를 넘기기 위해 명시호출 생성자를 호출하고 싶을 경우인데, 간단히 실명
을 드리면 이런 겁니다.

class Widget
{
public:
	explicit widget(int size);
	...
};

void doSomeWork(const Widget& w);

doSomeWork(Widget(15));	// 함수 방식 캐스트 문법으로 int로부터 Widget을 생성

doSomeWork(static_cast<Widget>(15)); // C++ 방식 캐스트를 서서 int로부터
									// Widget을 생성

아무래도 제 딴에는 객체를 생성한다고 하면 어쩐지 캐스팅과는 다른 느낌이 듭니다. 그래
서 이런 경우에 아마도 static_cast 대신에 함수 방식 캐스트를 쓸 것도 같거든요. 
다시 강조하는데요, 코어 덤프(core dump)2)가 곧잘 나는 코드는 여러분이 작성하고 나서 봤을
때 '오, 그럴 듯한데?'라는 느낌이 나는 경우가 많습니다. 그러니까 이런 느낌에 넘어가지 
마시고 언제든지 신형 스타일의 캐스트를 쓰도록 하세요. 속 편하고 훨씬 나을 것입니다.

캐스팅은 그냥 어떤 타입을 다른 타입으로 처리하라고 컴파일러에게 알려 주는 것밖에 더 
있느냐고 생각하는 프로그래머가 의외로 많더군요. 크나큰 오해입니다. 어떻게 쓰더라도(캐스
팅으로 명시적으로 비꾸거나 컴파일러가 암시적으로 바꾸거나) 일단 타입 변환이 있으면 이로 
말미암아 런타임에 실행되는 코드가 만들어지는 경우가 정말 적지 않습나다. 
다음의 코드를 봐 주세요.

int x, y;
...
double d = static_cast<double>(x)/y;	// x를 y로 나눕니다. 그러나 이때
										// 부동소수점 나눗셈을 사용합니다.

int 타입의 x를 double 타입으로 캐스팅한 부분에서 코드가 만들어집니다. 그것도 거의
항상 그렇습니다. 왜냐하면 대부분의 컴퓨터 아키텍처에서 int의 표현구조와 double의
표현구조가 아예 다르기 때문입니다. 여기까지는 그리 놀라는 사람이 없을 것 같은데, 아래 
예를 보시면 눈이 살짝 뒤집어질지도 모르겠어요.

class Base {...};

class Derived: public Base {...};

Derived d;

Base* pb = &d;		// Derived* -> Base*의 암시적 변환이 이루어짐.

보다시피 파생 클래스 객체에 대한 기본 클래스 포인터를 만드는(초기화하는), 지극히 흔하디
흔한 코드입니다. 그런데 두 포인터의 값이 같지 않을 때도 가끔 있다는 사실, 아십니까???
이런 경우가 되면, 포인터의 변위(offset)를 Derived* 포인터에 적용하여 실제의 Base* 
포인터 값을 구하는 동작이 바로 런타임(runtime)에 이루어집니다.

객체 하나(이를테면 Derived 타입의 객체)가 가질 수 있는 주소가 오직 한 개가 아니라 그
이상이 될 수 있음을(Base* 포인터로 가리킬 때의 주소, Derived* 포인터로 가리킬 때의 주
소) 보여주는 사례가 이렇게 우리 가까이에 있다니 놀랍습니다. 이런 일은 C에서는 결코 생
길 수 없습니다. 자바는 물론이고 C# 에서도 마찬가지이 고요. 하지만 C++에서는 생깁니다.
사실 C++에서는 다중 상속이 사용되면 이런 현상이 항상 생기지만, 심지어 단일 상속인데도 
이렇게 되는 경우가 있습니다. 이 점이 우리에게 시사하는 바는 가히 메가톤급입니다.
C++를 쓸 때는 데이터가 어떤 식으로 메모리에 박혀 있을 거라는 섣부른 가정을 피해야
하며, 더욱이 이런 가정에 기반한 캐스팅이 통하지 않는다는 뜻이 아니고 뭐겠습니까? 
이를테면, 어떤 객체의 주소를 char* 포인터로 바꿔서 포인터 산술 연산을 적
용하는 등의 코드는 거의 항상 미정의 동작을 낳을 수 있다는 이야기입니다.

하지만 포인터 변위를 써야 하는 때가 '가끔'이라고 말한 부분에도 빨간 줄 세 개 그으셔야
합니다. 객체의 메모리 배치구조를 결정하는 방법과 객체의 주소를 계산하는 방법은 컴파일
러마다 천차만별입니다. 그러니까, 어떤 플랫폼에서 '메모리 배치를 다 꿰고 있어서' 캐스팅
을 했을 때 문제가 없었을지라도 다른 플랫폼에서 그게 또 통하지는 않는다는 이야기죠. 주
변을 보면 산전, 수전, 공중전에 우주전까지 겪고 나서야 비로소 이 뼈아픈 교훈을 체험하
는 프로그래머가 많습니다.

다음은 캐스팅에 관한 웃지 못 할 이야기를 하나 해 보도록 하죠. 캐스팅이 들어가면, 보기
엔 맞는 것 같지만(아마 다른 언어에선 진짜 맞을지도 모르고요) 실제로는 틀린 코드를 쓰고도
모르는 경우가 많아집니다. 이를테면 말이죠, 주변에서 많이들 쓰이는 응용프로그램 프레임
워크(application framework)를 하나 살펴보면, 가상 함수를 파생 클래스에서 재정의해서 
구현할 때 기본 클래스의 버전을 호출하는 문장을 가장 먼저 넣어달라는 요구사항을 보게 됩
니다. 어떤 프레임워크에 Window 기본 클래스가 있고 SpecialWindow 파생 클래스가
있다고 가정해 보죠. 이들 클래스는 onResize라는 이름의 가상 함수를 모두 정의 하고 있
습니다. 그리고 SpecialWindow의 onReslze를 구현하려면 Window의 onResize를
호출해야 합니다. 어디서 많이 본 것 같잖아요? 그래서 하라는 대로 구현해 보았습니다. 
'보기엔 맞는 것 같지만 실제로는 틀린' 바로 그 코드입니다. 보시죠.

class Window		// 기본 클래스
{
public:
	virtual void onResize() {...}	// 기본 클래스의 onResize 구현 결과
	...
};

class SpecialWindow: public Window		// 파생 클래스
{
public:
	virtual void onResize()						// 파생 클래스의 onResize
	{											// 구현 결과 *this를 Window로
		static_cast<Window>(*this).onResize();	// 캐스팅하고 그것에 대해 onResize를
												// 호출합니다. 동작이 안됨...
		...					// SpecialWindow에서만 필요한 작업을 여기서 수행합니다.
	}
	...
};

위의 코드에서 캐스트 부분을 강조했습니다(신형 스타일의 캐스트를 썼는데, 그렇다고 구형 스타
일 캐스트를 쓰더라도 바뀔 건 아무것도 없어요). 여러분이 예상하신 대로 this를 Window
로 캐스팅하는 코드입니다. 이에 따라 호출되는 onResize 함수는 Window::onResize
가 됩니다. 그런데 이제부터 어처구니가 없어집니다. 함수 호출이 이루어지는 객체가 글쌔,
현재의 객체가 아니란 말입니다!!! 어찌된 노릇일까요? 이 코드에서는 캐스팅이 일어나면서
*this의 기본 클래스 부분에 대한 사본이 임시적으로 만들어지게 되어 있는데, 지금의
onResize는 바로 이 임시 객체에서 호출된 거라고요!! 결국, 위의 코드는 현재의 객체에 대
해 Window::onResize를 호출하지 않고 지나갑니다. 그러고 나서 SpecialWindow
전용의 동작은 또 현재의 객체에 해서 수행한다니까요. 다시 말해, SpecialWindow
만의 동작을 현재 객체에 대해 수행하기도 전에 기본 클래스 부분의 사본에 대고 Window::
onResize를 호출하는 것입니다. 이때 Window::onResize가 객체를 수정하도록 만들
어졌기라도 하면(사실 그럴 가능성이 꽤 적지 않습니다. onResize가 비상수 멤버 함수로 되어
있거든요), 현재 객체는 실제로 그 수정 이 반영되지 않을 것입니다. 오히려 수정이 반영되는
쪽은 현재 객체의 사본입니다. 하지만 SpecialWindow::onResize에서 객체를 수정하
면 진짜 현재 객체가 수정될게 분명하고요. 느낌 이 이상합니다. 현재 객체가 제 상태로 남
아 있을 것 같지가 않죠? 기본 클래스에서 들어가는 수정은 반영되지 않고 파생 클래스에서
들어가는 수정만 반영 될 테니 말입니다.

이 문제를 풀려면 일단 캐스팅을 빼버려야 합니다. 여러분이 진짜로 원하는 바를 쓰셔야지
요. 이번에는 컴파일러에게 *this를 기본 클래스 객체로 취급하도록 하는 꼼수 같은 것은
생각하지 맙시다. 그냥 현재 객체에 대고 onResize의 기본 클래스 번전을 호출하도록 만
들면 되는 것입니다. 이렇게 말이죠.

class SpecialWindow: public Window
{
public:
	virtual void onResize()
	{
		Window::onResize();	// *this에서 Window::onResize를 호출합니다.
		...
	}
	...
};

지금까지 보신 예제는 "캐스트 연산자가 필요한 상황이라면 뭔가 꼬여가는 징조다"라
는 실을 보여주는 예제라고도 할 수 있겠습니다. 특히 지금 꼭 썼으면 좋을 것 같은 연산
자가 dynamic_cast인 경우라면 더욱 그렇습니다.

dynamic_cast... 그 설계부터 말도 많고 탈도 많은 연산자입니다. 이 부분
을 잘 알아두면 꽤 유익하긴 겠습니다만, 지금은 상당수의 구현환경에서 이 연산자가 정
말 느리게 구현되어 있다는 문제만 짚는 정도로 충분할 것 같습니다. 굳이 이름은 밝히지
않겠으나 많이들 쓰고 계시는 어떤 구현환경의 경우3), 클래스 이름에 대한 문자열 비교 
연산에 기반을 두어 dynamic_cast가 만들어져 있습니다. 예를들어, 깊이가 4인 단일 
상속 계통에 속한 어떤 객체에 대해 이 연산자를 적용할 때, 방금 말씀드린 그 구현환경에서
는 클래스 이름을 비교하기 위해 strcmp가 최대 네 번까지 불릴 수 있다는 이야기가 되
지요. 상속 깊이가 더 깊거나 심지어 다중 상속이라도 쓰게 되면 그 비용이 더 커질 것이고
요. 어떤 구현환경은 어쩔 수 없이 이렇게 동작해야 하는 이유가 있긴 합니다(동적 링크 지원
을 동반해야 하기 때문에 그렇다고 합니다). 어쨌든, 일상생활에서 캐스트 연산자에 대해 경계
의 끈을 놓지 않는 자세는 기본일 것 같은데요, 수행 성능에 사활이 걸린 코드라면 특히
dynamic_cast에 주의를 놓지 말아야 할 것입니다.

3) 대표적으로는 Metrowerks CodeWarrior의 C++ 컴파일러가 strcmp()를 쓰는 것으로 
알려져 있다 - 옮긴이

dynamic_cast 연산자가 쓰고 싶어지는 때가 있긴 합니다. 파생 클래스 객체임이 분명한
녀석이 있어서 이에 대해 파생 클래스의 함수를 호출하고 싶은데, 그 객체를 조작할 수 있
는 수단으로 기본 클래의 포인터(혹은 참조자)밖에 없을 경우는 적지 않게 생기거든요. 이
런 문제를 피해 가는 일반적인 방법으로는 두 가지를 들 수 있습니다.

첫 번째 방법은, 파생 클래스 객체에 대한 포인터(혹은 스마트 포인터 항목 13 참조)를 컨테이너
에 담아둠으로써 각 객체를 기본 클래스 인터페이스를 통해 조작할 필요를 아예 없애 버리는
것입니다. 이를테면 지금까지 봐 왔던 Window 및 SpecialWindow 상속 에서 깜박
거리기(blink) 기능을 SpecialWindow 객체만 지원하게 되어 있다면, 아래처럼 하지 말고 

class Window {...};

class SpecialWindow:public Window
{
public:
	void blink();
	...
};

// tr1::shared_ptr에 대한 이야기는 항목 13에서 확인
typedef	std::vector<std::tr1::shared_ptr<Window>> VPW;

VPW winPtrs;
...
for(VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter)
{
	if(SpecialWindow* psw = dynmic_cast<SpecialWindow*>(iter->get()))
	{
		psw->blink();
	}
}

다음과 같이 해 보시라는 거죠.

typedef	std::vector<std::tr1::shared_ptr<SpecialWindow>> VPSW;

VPSW winPtrs;
...

// 더 괜찮은 코드
for(VPSW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter)
{
	(*iter)->blink();	// dynamic_cast가 없습니다.
}

이 방법으로는 Window에서 파생될 수 있는 모든 녀석들에 대한 포인터를 똑같은 컨테이너
에 저장할 수는 없습니다. 맞습니다. 다른 타입의 포인터를 담으려면 타입 안전성을 갖춘 컨
테이너 여러 개가 필요할 것입니다.

두 번째 방법...
한편, Window에서 뻗어 나온 자손들을 전부 기본 클래스 인터페이스를 통해 조작할 수 있
는 다른 방법이 없는 것은 아닙니다. 여러분이 원하는 조작을 가상 함수 집합으로 정리해서
기본 클래스에 넣어두면 됩니다. 예를 들어, 지금은 blink 함수가 SpecialWindow에서
만 가능하지만, 그렇다고 기본 클래스에 못 넣어 둘 만한 것도 아니죠. 그러니까, 아무것도
안 하는 기본 blink를 구현해서 가상 함수로 제공하는 것입니다. 아래처럼요.

class Window
{
public:
	virtual void blink();	// 기본 구현은 '아무 동작 안하기' 입니다.
	...						// 참고로, 항목 34를 보시면 어째서 가상 함수의 기본
};							// 구현이 좋지 않은 아이디어인지 확인할 수 있습니다.

class SpecialWindow: public Window
{
public:
	virtual void blink(){...};	// 이 클래스에서는 blink 함수가 특정한 동작을 
	...							// 수행합니다.
};

typedef std::vector<std::tr1::shared_ptr<Window>> VPW;
VPW winPtrs;		// 이 컨테이너는 Window에서 파생된 모든 타입의 객체
					//(에 대한 포인터)들을 담습니다.
...
for(VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter)
{
	(*iter)->blink();	//잘 보세요. dynamic_cast가 없습니다.
}

말씀드린 두 가지 방법 중 어떤 것도(타입 안전성을 갖춘 컨테이너를 쓰든지 가상 함수를 기본
스 쪽으로 올려두든지) 모든 상황에 다 적용하기란 불가능하지만, 상당히 많은 상황에서
dynamic_cast를 쓰는 방법 대신에 꽤 잘 쓸 수 있습니다. 이 정도면 둘 가치는 충
분하겠지요.

정말 피해야 하는 설계가 하나 있습니다. 바로 '폭포식(cascading) dynamic_cast'라고 불
리는 구조인데, 이름이 낯설지만 코드를 보면 바로 알 수 있습니다.
	
class Window{...};
...		// 파생 클래스가 여기서 정의됩니다.
typedef std::vector<std::tr1::shared_ptr<Window> VPW;
VPW winPtrs;
...
for(VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter)
{
	if(SpecialWindow1* psw1 = dynamic_cast<SpecialWindow1*>(iter->get())){...}
	else if(SpecialWindow2* psw2 = dynamic_cast<SpecialWindow2*>(iter->get())){...}
	else if(SpecialWindow3* psw3 = dynamic_cast<SpecialWindow3*>(iter->get())){...}
	...
}

이런 C++ 코드 때문에 C++가 욕을 먹는 것입니다. 크기만 하고 아름답지 않으며, 속도도
둔한데다가 망가지기 쉬운 코드가 만들어지거든요. Window 클래스 계통이 바뀌었다는 소
식이라도 들렸다 치면 항상 이런 코드는 '또 뭐 넣고 뺄 거 없나?' 하는 검토 대상이 되니까
말이에요(파생 클래스가 하나 추가되었다고 가정하죠. 그러면 위의 폭포식 코드에 속해서 조건
분기문을 우겨 어야 합니다). 이런 형태의 코드를 보시면 넘어가지 마세요. 가상 함수 호출
에 기반을 둔 어떤 방법이든 써서 바꿔 놓아야 합니다.

정말 잘 작성된 C++ 코드는 캐스팅을 거의 쓰지 않습니다. 하지만 캐스팅을 발본색원한다
는 것도 어찌 보면 현장 사정을 무시한 생각일 수 있습니다. 앞에서 보신 int를 double
로 바꾸는 경우는 터무니없는 캐스팅은 아닙니다. 엄밀히 따지면 꼭 필요한가에 대한 의문
이 남긴 하지만요(차라리 x의 값으로 초기화한 double 타입의 변수를 새로 선언하는 식으로 코
드를 다시 만드는 게 나을 것 같아요). 캐스팅 역시, 그냥 막 쓰기에는 꺼림칙한 문법 기능을
써야 할 때 흔히 쓰이는 수단을 활용해서 처리히는 것이 좋습니다. 쉽게 말해 최대한 격리
시키라는 것입니다. 캐스팅을 해야 하는 코드를 내부 함수 속에 몰아 놓고, 그 안에서 일어
는 '천한' 일들은 이 함수를 호출하는 외부에서 알 수 없도록 인터페이스로 막아두는 식으
로 해결하면 됩니다.

이것만은 잊지 말자!
*	다른 방법이 가능하다면 캐스팅은 피하십시오. 특히 수행 성능에 민감한 코드에서
	dynamic_cast는 몇 번이고 다시 생각하십시오. 설계 중에 캐스팅이 필요해졌다면,
	캐스팅을 쓰지 않는 다른 방법을 시도해 보십시오.
*	캐스팅이 어찔 수 없이 필요하다면, 함수 안에 숨길 수 있도록 해 보십시오. 이렇게 하면
	최소한 사용자는 자신의 코드에 캐스팅을 넣지 않고 이 함수를 호출할 수 있게 됩니다.
*	구형 스타일의 캐스트를 쓰려거든 C++ 스타일의 캐스트를 선호하십시오. 발견하기도 쉽고
	설계자가 어떤 역할을 의도했는지가 더 자세하게 드러납니다. 