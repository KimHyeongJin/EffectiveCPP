항목 27: 캐스팅은 절약, 또 절약! 잊지 말자

"어떤 일이 있어도 타입 에러가 생기지 않도록 보장한다." C++의 동작 규칙은 바로 이 철
학을 바탕으로 설계되어 있습니다. 즉, 이론적으로 C++ 프로그램은 일단 컴파일만 깔끔하
게 끝나면 그 이후엔 어떤 객체에 대해서도 불안전한 연산이나 말도 안되는 연산을 수행하
려 들지 않는다는 것입니다. 내일까지 짜내라는 팀장의 압박만큼 존재감 있는 보장입니다.
아마 가볍게 지나치기에도 힘들 거예요.

그런데 공교롭게도 C++에는 이 타입 시스템을 가볍게 배대뒤치기할 수 있는 괴물이 있으니, 
바로 캐스트(Cast)라고 불리는 녀석입니다. 캐스트는 온갖 골칫거리를 다 몰고 다니는 풍
운아이자, C++ 코드의 겉모습을 늙게 만드는 피부노화의 원흉이라 할 수 있겠습니다. 이
녀석이 만드는 골칫거리 중 어떤 것은 간단히 찾을 수도 있지만, 또 어떤 것은 찾아내기 
어려운 것도 있답니다. C나 자바 아니면 C#을 쓰다가 C++로 오신 독자 분들은 다시 빨간 
펜 쥐실 준비를하십시오. 그분들이 쓰시던 언어에서는 캐스팅이 필요한 경우가 진짜로 
있기도 하고 또 위험성도 적었을 거예요. 하지만 C++는 C가 아닙니다. 자바도 아니고요. 
C# 과도 다릅니다. C++에서 캐스팅은 정말로 조심해서 써야 히는 기능입니다.

일단 몸을 푸는 기분으로 캐스팅 문법부터 정리하고 들어갑시다. 똑같은 캐스트인데 쓰는
방법이 세 가지나 있거든요 우선, C 스타일의 캐스트입니다.

(T) 표현식	// 표현식 부분을 T 타입으로 캐스팅합니다.

다음은 함수 방식 캐스트입니다. 문법이 함수호출문 같지요.

T(표현식)		// 표현식 부분을 T 타입으로 캐스팅합니다.

어떻게 쓰든 이들이 가진 의미는 똑같습니다. 단지 괄호를 어디에 썼느냐만 디를 뿐이죠. 
필자는 이 두 형태를 통틀어 '구형 스타일의 캐스트'라고 부르겠습니다.

C++는 네 가지로 이루어진 새로운 형태의 캐스트 연산자를 독자적으로 공합니다(신형 스
타일의 캐스트 혹은 C++ 스타일의 채스트라고 부르죠).

const_cast<T>(표현식)
dynamic_cast<T>(표현식)
reinterpret_cast<T>(표현식)
static_cast<T>(표현식)

각 연산자는 나름대로의 목적이 있습니다.

*	const_cast
	객체의 상수성(constness)을 없애는 용도1)로 사용됩니다. 이런 기능을 가진 C++ 
	스타일의 캐스트는 이것밖에 없습니다.

*	dynamic_cast
	이른바 '안전한 다운캐스팅(safe downcasting)'을 할 때 사용하는 연산자입니다. 
	즉, 주어진 객체가 어떤 클래스 상속 계통에 속한 특정 타입인지 아닌지를 결정하는 
	작업에 쓰입니다. 구형 스타일의 캐스트 문볍으로는 흉내조차도 낼 수 없는 유일한 
	캐스트이기도 합니다. 덤으로, 신경 쓰일 정도로 런타임 비용이 높은 캐스트 연산자
	로도 유일하고요(이 부분에 대한 이야기는 조금 뒤에서 자세히 하겠습니다).

*	reinterpret_cast
	포인터를 int로 바꾸는 등의 하부 수준 캐스팅을 위해 만들어진 연산자로서, 이것의 
	적용 결과는 구현환경에 의존적입니다(이식성이 없다는 뜻이죠). 이런 캐스트는 하부 
	수준 코드 외에는 거의 없어야 합니다. 필자 역시 이 책에서 이 캐스트를 딱 한 번 
	썼는데, 그것도 원시 메모리용 디버깅 할당자를 작성히는 방법에 대해 의견을 제시할 
	때뿐이었습니다(항목 50 참조).

*	static_cast 
	암시적 변환[비상수 객체를 상수 객체로 바꾸거나(항목 3처럼), int를	double로 
	바꾸는 등의 변환]을 강제로 진행할 때 사용합니다. 흔히들 이루어지는 타입	변환을 
	거꾸로 수행하는 용도(void*를 일반 타입의 포인터로 바꾸거나, 기본 클래스의 포
	인터를 파생 클래스의 포인터로 바꾸는 등)로도 쓰입니다. 물론 상수를 비상수 객체
	로 캐스팅히는 데 이것을 쓸 수는 없습니다(위에서 말했지만 const_cast 연산자밖에
	안됩니다).

1) 혹은 휘발성(volatileness)을 제거하는 용도로 쓰인다.-옮긴이

구형 스타일의 캐스트는 요즘도 여전히 적법하게 쓰일 수 있지만, 그보다는 C++ 스타일의
캐스트를 쓰는 것이 바람직합니다. 우선, 코드를 읽을 때 알아보기 쉽기 때문에(사람 눈에도
그렇고 grep 동의 검색도구에도 그렇고요), 소스 코드의 어디에서 C++의 타입 시스템이 망가
졌는지를 보는 작업이 편해집니다. 둘째, 캐스트를 사용한 목적을 더 좁혀서 지정하기
때문에 컴파일러 쪽에서 사용 에러를 진단할 수 있습니다. 무슨 말인고 하니, 상수성을 없애
려고 한 부분에다가 const_cast 대신에 다른 신형 스타일의 캐스트를 실수로 썼다면 코
드 자체가 컴파일되지 않으므로 좋다는 것입니다.

개인적으로 제가 구형 스타일의 캐스트를 쓰는 경우는 딱 한 군데 같아요. 객체를 인자로
받는 함수에 객체를 넘기기 위해 명시호출 생성자를 호출하고 싶을 경우인데, 간단히 실명
을 드리면 이런 겁니다.

class Widget
{
public:
	explicit widget(int size);
	...
};

void doSomeWork(const Widget& w);

doSomeWork(Widget(15));	// 함수 방식 캐스트 문법으로 int로부터 Widget을 생성

doSomeWork(static_cast<Widget>(15)); // C++ 방식 캐스트를 서서 int로부터
									// Widget을 생성

아무래도 제 딴에는 객체를 생성한다고 하면 어쩐지 캐스팅과는 다른 느낌이 듭니다. 그래
서 이런 경우에 아마도 static_cast 대신에 함수 방식 캐스트를 쓸 것도 같거든요. 
다시 강조하는데요, 코어 덤프(core dump)2)가 곧잘 나는 코드는 여러분이 작성하고 나서 봤을
때 '오, 그럴 듯한데?'라는 느낌이 나는 경우가 많습니다. 그러니까 이런 느낌에 넘어가지 
마시고 언제든지 신형 스타일의 캐스트를 쓰도록 하세요. 속 편하고 훨씬 나을 것입니다.

캐스팅은 그냥 어떤 타입을 다른 타입으로 처리하라고 컴파일러에게 알려 주는 것밖에 더 
있느냐고 생각하는 프로그래머가 의외로 많더군요. 크나큰 오해입니다. 어떻게 쓰더라도(캐스
팅으로 명시적으로 비꾸거나 컴파일러가 암시적으로 바꾸거나) 일단 타입 변환이 있으면 이로 
말미암아 런타임에 실행되는 코드가 만들어지는 경우가 정말 적지 않습나다. 
다음의 코드를 봐 주세요.

int x, y;
...
double d = static_cast<double>(x)/y;	// x를 y로 나눕니다. 그러나 이때
										// 부동소수점 나눗셈을 사용합니다.