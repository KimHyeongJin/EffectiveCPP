6 상속, 그리고 객체 지향 설계

객체 지향 프로그래밍(object-oriented programming: OOP)이 이 바닥에서 큰 유행을 
일으키며 주름잡아 온 지도 어언 20년 가까이 된 만큼, 아마도 여러분 중 대부분은 상속이
니, 파생이니, 가상 함수니 하는 것들을 웬만큼 경험해 보셨으리라 생각합니다. 한평생 C만
가지고 프로그래밍을 해 오신 분이라 해도 OOP와 담 쌓았노라고 큰소리칠 만한분이 계실까
요? 확신컨대 아닐 겁니다.

그럼에도, C++의 OOP는 여러분이 익히 알고들 계시는 OOP보다 조금 더 생각할 부분이
많다는 점이 이번 장을 준비한 이유입니다. 상속은 단일 상속과 디중 상속이 가능하고, 
상속관계 하나하나가 public, protected, private의 성질을 가질 수 있습니다. 그뿐
아니라 여기에 가상 상속과 비가상 상속이 얹힐 수 있지요. 멤버 함수는 또 어떻고요. 
가상 함수? 비가상 함수? 순수 가상 함수? 리고 C++가 지원하는 다른 기능들과 이들의 
상호관계도 생각하지 않으면 안 됩니다. 기본 매개변수는 가상 함수와 어떻게 맞물려 돌아
갈까요? 상속은 C++의 이름 탐색 규칙에 어떤 영향을 줄까요? 또 설계 시의 선택사항은 
어떤 식으로 바뀔까요? 어떤 클래스의 동작 원리를 외부에서 수정할 수 있어야 한다고 결
정했을 때, 과연 가상 함수가 최선의 방법 일까요?

이 장에서는 이런저런 이야깃거리를 모두 정리해 보겠습니다. 여기에 덧붙여, '조금 더 
생각할 부분이 많은' C++의 OOP 개념이 실제로 어떤 의미를 지니는가, 다시 말해 C++의
OOP 관련 기능 하나하나를 코드에 적용할 때 무엇을 표현해야 정확하게 쓰는 것인지를 이
야기해 볼까 합니다. 이를테면, public 상속은 반드시 "is-a" 관계를 뜻해야 하며, 이 
외의 의미를 붙이려고 하면 난처해질 수도 있습니다. 또 다른 예로, 가상 함수의 의미는 "인터페이스가 상속되어야 한다"인 반면, 비가상 함수의 의미는 "인터페이스와 구현이 둘
다 상속되어야 한다"입니다. 이것을 정확히 구분하지 못하는 프로그래머들이 정말 많더군요.

객체 지향 프로그래잉에 있어서 C++가 갖고 있는 이런저런 특징들의 의미를 이해하고 나
면, 일단 OOP를 보는 여러분 눈이 바뀌는 기분이 들 것입니다. 여러분의 바뀐 눈은 언어에
서 제공하는 객체 지향 관련 특정들을 더 잘 구분히는 데만 써먹고 끝나는 것이 아니
라, 여러분이 지금 만들고 있는 소프트웨어 시스템에 대해 여러분이 말하고 싶은 바를 결정
하는 문제에까지 유쾌한 영향을 줄 것입니다. 뭐니 뭐니 해도, 여러분이 무엇을 말하고 싶은
가를 몸으로 파악하는 것이 먼저입니다. 이게 되어 있으면, 그것을 C++로 옮기는 것은 그
다지 어려운 일도 아니죠.* 가상 함수 = 인터페이스가 상속되어야 한다.* 비가상 함수 = 인터페이스와 구현이 둘다 상속되어야 한다.항목 32: public 상속 모형은 반드시 "is-a(...는...의 일종이다)"를 따르도록 만들자윌리엄 디멘트(Willim Dement) 교수2)가 쓴 책인 "Some Must Watch While Some Must
Sleep"(W. H. Freeman and Company, 1974)을 읽어 보면, 그분이 맡은 수업에서 가장 
'중요한' 내용을 학생들의 기억에 심어 주기 위해 디멘트 교수가 어떤 시도를 했는가에 대한
이야기가 나옵니다. 그 당시에 디멘트 교수는 강의 시간에 '영국의 어린 학생들은 헤이스팅
스 전투3)가 1066년에 있었다는 사실 정도는 웬만큼 알고 있으며, 그보다 좀더 많이 기억하
고 있다"라는 이야기를 한 적이 있었습니다. 기억력이 조금 나쁜 아이라도 1066년만큼은 알
고 있다는 점은 꽤 힘주어 말했다고 합니다. 디멘트 교수는 계속해서 '몇 개 되지 않는' 핵
심적인 수업 내용을 학생들에게 전해 주었는데, 이 중에는 수면제가 불면증을 일으킨다는
꽤 흥미 있는 사실도 들어 있었습니다. 디멘트 교수는 학생들에게, 학기 내내 한 이야기들
중 다른 것은 다 잊어버리더라도 몇 개 되지 않는 핵심적인 수업 내용만은 꼭 기억해 달라
고 부탁하였고, 다시 그 수업 내용으로 가서 하고 또 반복했다고 합니다. 

2)	윌리엄 찰스 디멘트(Willim Charles Dement, 1928~):의학박사. 수면 연구가. 스
	탠포드 대학 수면 연구소(Sleep Laboratory)의 창립자이며 현재 교수로 있다. 미국
	수면의학의 아버지로 불리며 하버드 의대 수면 연구실을 이끄는 앨런 홉슨 교수와 함께
	쌍벽을 이루고 있다. 위의 책은 1974년에 디멘트 교수가 쓴 책으로, 사람이 잠을 자고
	꿈을 꿀 때 발생하는 일들을 설명하고 있다.-옮긴이
3)	헤이스팅스 전투(Battle of Hastings): 1066년에 기병대를 앞세운 노르망디 대공 
	윌리엄(정복왕 윌리엄이라고 불리는)이 영국을 침공하여 당시 잉글랜드의 헤럴드 왕이 
	이끄는 보병과 벌인, 영국 통합 전쟁 최후의 전투. 우리 나라	로 치면 백제의 계백과 
	신라의 김유신이 맞붙은 황산별 전투 정도의 역사적 무게를 지닐 것 같다.-옮긴이

학기말이 되어 기말고사를 치렀는데, 마지막 시험 문제를 이렇게 냈습니다. "이번 수업에서
들은 것 중, 여러분의 남은 인생 동안 절대로 못 잊을 것을 딱 하나만 쓰시오" 그런데 나
중에 학생들의 시험답안을 채점하던 디멘트 교수는 마지막 문제에 대한 학생들의 답안을 보
고 충격을 받았다고 합니다. 거의 모두가 1066을 써서 내더란 말이죠.

그래서 사실 저도 지금 두렵습니다. C++로 객체 지향 프로그래멍을 하면서 다른 건 잊더라
도 꼭 잊지 말아 달라고 여러분께 부탁하고 싶은 중요한 규칙이 딱 하나 있거든요. 바로,
public 상속은 "is-a(...는 ...의 일종이다)"를 의미한디는 이야기입니다. 부탁컨대 이 
규칙을 여러분의 두뇌에 반드시 'commit'해 주세요.

여러분이 클래스 D("Derived")를 클래스 B("Base")로부터 public 상속을 통해 파생시켰다
면, 여러분은 C++ 컴파일러에게 이렇게 말한 것과 똑같습니다(여러분의 코드를 읽는 다른 프
로그래머도 이렇게 이해합니다). D 타입으로 만들어진 모든 객체는 또한 B 타입의 객체이지만,
그 반대는 되지 않는다고요. 다시 말해 B는 D보다 더 일반적인 개념을 나타내며, D는 B보다
더 특수한 개념을 나타낸다고 알리는 것입니다. 그러니까, B 타입의 객체가 쓰일 수 있는
곳에는 D 타입의 객체도 마찬가지로 쓰일 수 있다고 단정(assert) 하는 것이죠. D 타입의 모
든 객체는 B 타입의 객체도 되니까요. 반면, D 타입이 필요한 부분에 B 타입의 객체를 쓰
는 것은 불가능합니다. 모든 D는 B의 일종이지만(D is a B), B는 D의 일종이 아니기 때문입
니다.

C++는 public 상속을 이렇게 해석하도록 문법적으로 지원하고 있습니다. 아래의 예제를
한번 보세요.

class Person {...};
class Student: public Person {...};

모든 학생들은 사람이지만 모든 사람이 학생은 아니라는 사실은 일상적인 경험을 통해 모두
알고 있습니다. 위의 클래스 계통이 말해 주는 바 그대로죠. 사람에 해당되는 사실은 어떤
것이든(예를 들면, 누구나 생일이 있다는 점) 학생에게도 해당된다고 예상할 수 있는 것입니다.
하지만 학생에 해당되는 모든 것들이(어떤 학교에 다니고 있다는 점 등) 일반적인 사람에게도
해당될 거라고 기대하지는 않습니다. '사람'은 '학생'보다 더 일반적인 개념입니다. 학생은 
사람을 더 특수하게 만든 한 종류이고요.

이제 C++의 땅에 발을 디뎌 봅시다. Person 타입(Person에 대한 포인터 혹은 Person에
대한 참조자도 됩니다)의 인자를 기대하는 함수는 Student 객체(역시, Student에 대한 포인
터 혹은 Student에 대한 참조자도 됩니다)도 받아들일 수 있습니다. 다음을 보세요.

void eat(const Person& p);	// 먹는 것은 누구든 합니다.

void study(const Student& s);	// 학과 공부는 학생만 합니다.

Person p;		// p는 Person의 일종입니다.
Student s;		// s는 Student의 일종입니다.

eat(p);		// 문제 없습니다.

eat(s);		// 문제 없습니다.

study(s);	// 좋습니다.

study(p);	// 에러. p는 Student가 아닙니다.

이 이야기는 public 상속에서만 통합니다. 필자가 설명한 대로 C++가 동작하려면
Student가 Person과 public 상속 관계를 가져야 합니다. private 상속은 의미 자
체가 완전히 다르고(항목 39 참조), protected 상속은 글쎄요, 요즘에도 의미가 아리아리
합니다.

public 상속과 is-a 관계가 똑같은 뜻이라는 이야기는 꽤 직관적이고 간단하긴 하지만, 그
직관 때문에 판단을 잘못하는 경우도 있습니다. 예를 하나 들죠. 팽권이 새의 일종이라는 점
은 누구나 아는 사실이고, 새라는 개념만 보면 새가 날 수 있다는 점도 사실입니다. 이것을
순박하게(!?) C++로 표현해 보려고 하면 아래와 비슷한 코드가 나올 것입니다.

class Bird
{
public:
	virtual void fly();		// 새는 날 수 있다.
	...
};

class Penguin: public Bird	// 펭귄은 새입니다.
{
	...
};