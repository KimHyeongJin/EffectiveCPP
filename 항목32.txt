6 상속, 그리고 객체 지향 설계

객체 지향 프로그래밍(object-oriented programming: OOP)이 이 바닥에서 큰 유행을 
일으키며 주름잡아 온 지도 어언 20년 가까이 된 만큼, 아마도 여러분 중 대부분은 상속이
니, 파생이니, 가상 함수니 하는 것들을 웬만큼 경험해 보셨으리라 생각합니다. 한평생 C만
가지고 프로그래밍을 해 오신 분이라 해도 OOP와 담 쌓았노라고 큰소리칠 만한분이 계실까
요? 확신컨대 아닐 겁니다.

그럼에도, C++의 OOP는 여러분이 익히 알고들 계시는 OOP보다 조금 더 생각할 부분이
많다는 점이 이번 장을 준비한 이유입니다. 상속은 단일 상속과 디중 상속이 가능하고, 
상속관계 하나하나가 public, protected, private의 성질을 가질 수 있습니다. 그뿐
아니라 여기에 가상 상속과 비가상 상속이 얹힐 수 있지요. 멤버 함수는 또 어떻고요. 
가상 함수? 비가상 함수? 순수 가상 함수? 리고 C++가 지원하는 다른 기능들과 이들의 
상호관계도 생각하지 않으면 안 됩니다. 기본 매개변수는 가상 함수와 어떻게 맞물려 돌아
갈까요? 상속은 C++의 이름 탐색 규칙에 어떤 영향을 줄까요? 또 설계 시의 선택사항은 
어떤 식으로 바뀔까요? 어떤 클래스의 동작 원리를 외부에서 수정할 수 있어야 한다고 결
정했을 때, 과연 가상 함수가 최선의 방법 일까요?

이 장에서는 이런저런 이야깃거리를 모두 정리해 보겠습니다. 여기에 덧붙여, '조금 더 
생각할 부분이 많은' C++의 OOP 개념이 실제로 어떤 의미를 지니는가, 다시 말해 C++의
OOP 관련 기능 하나하나를 코드에 적용할 때 무엇을 표현해야 정확하게 쓰는 것인지를 이
야기해 볼까 합니다. 이를테면, public 상속은 반드시 "is-a" 관계를 뜻해야 하며, 이 
외의 의미를 붙이려고 하면 난처해질 수도 있습니다. 또 다른 예로, 가상 함수의 의미는 
"인터페이스가 상속되어야 한다"인 반면, 비가상 함수의 의미는 "인터페이스와 구현이 둘
다 상속되어야 한다"입니다. 이것을 정확히 구분하지 못하는 프로그래머들이 정말 많더군요.

객체 지향 프로그래잉에 있어서 C++가 갖고 있는 이런저런 특징들의 의미를 이해하고 나
면, 일단 OOP를 보는 여러분 눈이 바뀌는 기분이 들 것입니다. 여러분의 바뀐 눈은 언어에
서 제공하는 객체 지향 관련 특정들을 더 잘 구분히는 데만 써먹고 끝나는 것이 아니
라, 여러분이 지금 만들고 있는 소프트웨어 시스템에 대해 여러분이 말하고 싶은 바를 결정
하는 문제에까지 유쾌한 영향을 줄 것입니다. 뭐니 뭐니 해도, 여러분이 무엇을 말하고 싶은
가를 몸으로 파악하는 것이 먼저입니다. 이게 되어 있으면, 그것을 C++로 옮기는 것은 그
다지 어려운 일도 아니죠.

* 가상 함수 = 인터페이스가 상속되어야 한다.
* 비가상 함수 = 인터페이스와 구현이 둘다 상속되어야 한다.

항목 32: public 상속 모형은 반드시 "is-a(...는...의 일종이다)"를 따르도록 만들자

윌리엄 디멘트(Willim Dement) 교수2)가 쓴 책인 "Some Must Watch While Some Must
Sleep"(W. H. Freeman and Company, 1974)을 읽어 보면, 그분이 맡은 수업에서 가장 
'중요한' 내용을 학생들의 기억에 심어 주기 위해 디멘트 교수가 어떤 시도를 했는가에 대한
이야기가 나옵니다. 그 당시에 디멘트 교수는 강의 시간에 '영국의 어린 학생들은 헤이스팅
스 전투3)가 1066년에 있었다는 사실 정도는 웬만큼 알고 있으며, 그보다 좀더 많이 기억하
고 있다"라는 이야기를 한 적이 있었습니다. 기억력이 조금 나쁜 아이라도 1066년만큼은 알
고 있다는 점은 꽤 힘주어 말했다고 합니다. 디멘트 교수는 계속해서 '몇 개 되지 않는' 핵
심적인 수업 내용을 학생들에게 전해 주었는데, 이 중에는 수면제가 불면증을 일으킨다는
꽤 흥미 있는 사실도 들어 있었습니다. 디멘트 교수는 학생들에게, 학기 내내 한 이야기들
중 다른 것은 다 잊어버리더라도 몇 개 되지 않는 핵심적인 수업 내용만은 꼭 기억해 달라
고 부탁하였고, 다시 그 수업 내용으로 가서 하고 또 반복했다고 합니다. 

2)	윌리엄 찰스 디멘트(Willim Charles Dement, 1928~):의학박사. 수면 연구가. 스
	탠포드 대학 수면 연구소(Sleep Laboratory)의 창립자이며 현재 교수로 있다. 미국
	수면의학의 아버지로 불리며 하버드 의대 수면 연구실을 이끄는 앨런 홉슨 교수와 함께
	쌍벽을 이루고 있다. 위의 책은 1974년에 디멘트 교수가 쓴 책으로, 사람이 잠을 자고
	꿈을 꿀 때 발생하는 일들을 설명하고 있다.-옮긴이
3)	헤이스팅스 전투(Battle of Hastings): 1066년에 기병대를 앞세운 노르망디 대공 
	윌리엄(정복왕 윌리엄이라고 불리는)이 영국을 침공하여 당시 잉글랜드의 헤럴드 왕이 
	이끄는 보병과 벌인, 영국 통합 전쟁 최후의 전투. 우리 나라	로 치면 백제의 계백과 
	신라의 김유신이 맞붙은 황산별 전투 정도의 역사적 무게를 지닐 것 같다.-옮긴이

학기말이 되어 기말고사를 치렀는데, 마지막 시험 문제를 이렇게 냈습니다. "이번 수업에서
들은 것 중, 여러분의 남은 인생 동안 절대로 못 잊을 것을 딱 하나만 쓰시오" 그런데 나
중에 학생들의 시험답안을 채점하던 디멘트 교수는 마지막 문제에 대한 학생들의 답안을 보
고 충격을 받았다고 합니다. 거의 모두가 1066을 써서 내더란 말이죠.

그래서 사실 저도 지금 두렵습니다. C++로 객체 지향 프로그래멍을 하면서 다른 건 잊더라
도 꼭 잊지 말아 달라고 여러분께 부탁하고 싶은 중요한 규칙이 딱 하나 있거든요. 바로,
public 상속은 "is-a(...는 ...의 일종이다)"를 의미한디는 이야기입니다. 부탁컨대 이 
규칙을 여러분의 두뇌에 반드시 'commit'해 주세요.

여러분이 클래스 D("Derived")를 클래스 B("Base")로부터 public 상속을 통해 파생시켰다
면, 여러분은 C++ 컴파일러에게 이렇게 말한 것과 똑같습니다(여러분의 코드를 읽는 다른 프
로그래머도 이렇게 이해합니다). D 타입으로 만들어진 모든 객체는 또한 B 타입의 객체이지만,
그 반대는 되지 않는다고요. 다시 말해 B는 D보다 더 일반적인 개념을 나타내며, D는 B보다
더 특수한 개념을 나타낸다고 알리는 것입니다. 그러니까, B 타입의 객체가 쓰일 수 있는
곳에는 D 타입의 객체도 마찬가지로 쓰일 수 있다고 단정(assert) 하는 것이죠. D 타입의 모
든 객체는 B 타입의 객체도 되니까요. 반면, D 타입이 필요한 부분에 B 타입의 객체를 쓰
는 것은 불가능합니다. 모든 D는 B의 일종이지만(D is a B), B는 D의 일종이 아니기 때문입
니다.

C++는 public 상속을 이렇게 해석하도록 문법적으로 지원하고 있습니다. 아래의 예제를
한번 보세요.

class Person {...};
class Student: public Person {...};

모든 학생들은 사람이지만 모든 사람이 학생은 아니라는 사실은 일상적인 경험을 통해 모두
알고 있습니다. 위의 클래스 계통이 말해 주는 바 그대로죠. 사람에 해당되는 사실은 어떤
것이든(예를 들면, 누구나 생일이 있다는 점) 학생에게도 해당된다고 예상할 수 있는 것입니다.
하지만 학생에 해당되는 모든 것들이(어떤 학교에 다니고 있다는 점 등) 일반적인 사람에게도
해당될 거라고 기대하지는 않습니다. '사람'은 '학생'보다 더 일반적인 개념입니다. 학생은 
사람을 더 특수하게 만든 한 종류이고요.

이제 C++의 땅에 발을 디뎌 봅시다. Person 타입(Person에 대한 포인터 혹은 Person에
대한 참조자도 됩니다)의 인자를 기대하는 함수는 Student 객체(역시, Student에 대한 포인
터 혹은 Student에 대한 참조자도 됩니다)도 받아들일 수 있습니다. 다음을 보세요.

void eat(const Person& p);	// 먹는 것은 누구든 합니다.

void study(const Student& s);	// 학과 공부는 학생만 합니다.

Person p;		// p는 Person의 일종입니다.
Student s;		// s는 Student의 일종입니다.

eat(p);		// 문제 없습니다.

eat(s);		// 문제 없습니다.

study(s);	// 좋습니다.

study(p);	// 에러. p는 Student가 아닙니다.

이 이야기는 public 상속에서만 통합니다. 필자가 설명한 대로 C++가 동작하려면
Student가 Person과 public 상속 관계를 가져야 합니다. private 상속은 의미 자
체가 완전히 다르고(항목 39 참조), protected 상속은 글쎄요, 요즘에도 의미가 아리아리
합니다.

public 상속과 is-a 관계가 똑같은 뜻이라는 이야기는 꽤 직관적이고 간단하긴 하지만, 그
직관 때문에 판단을 잘못하는 경우도 있습니다. 예를 하나 들죠. 팽권이 새의 일종이라는 점
은 누구나 아는 사실이고, 새라는 개념만 보면 새가 날 수 있다는 점도 사실입니다. 이것을
순박하게(!?) C++로 표현해 보려고 하면 아래와 비슷한 코드가 나올 것입니다.

class Bird
{
public:
	virtual void fly();		// 새는 날 수 있다.
	...
};

class Penguin: public Bird	// 펭귄은 새입니다.
{
	...
};

갑자기 뭔가 이상해진 느낌이 듭니다. 위의 클래스 계통에 의하면 팽권은 날 수 있잖아요.
하지만 이것은 맞지 않습니다. 무슨 일일까요?

지금 우리는 명확치 않은 자연어, 즉 사람의 말에 소위 '낚인' 것입니다. "새는 날 수 있다"
라고 말할 당시, 모든 종류의 새가 날 수 있다는 의미를 품고 말한 것은 아니었습니다. 그저
자체 비행 능력을 가진 동물이 새이니까 그렇게 말했을 뿐이었죠. 말을 더 명확히 했다면
날지 않는 새 종류도 있다는 점도 구분할 수 있었을 것입니다. 즉, 다음과 같이 조금 더 현
실에 가까운 클래스 계통구조를 뽑을 수 있었을 거란 말이죠.

class Bird
{
	...			// fly 함수가 선언되지 않았습니다.
};

class FlyingBird: public Bird
{
public:
	virtual void fly();
	...
};

class Penguin: public Bird
{
	...			// fly 함수가 선언되지 않았습니다.
};

보시다시피, 처음에 했던 설계보다 우리가 알고 있는 현실에 더욱 충실한 클래스 구조가 되
었습니다.

그렇다고 해서 이 날개 달린 동물 이야기가 이것으로 끝난 것은 아닙니다. 어떤 소프트웨어
시스템의 경우엔 비행 능력이 있는 새와 없는 새를 구분하지 않아도 될 수 있기 때문입니
다. 새의 부리와 날개에만 관심이 있고 비행 가지고는 도통 할 일이 없는 응용프로그램을
만든다면, 두 개의 클래스로 구성된 처음의 계통이 훨씬 만족스러울 것입니다. 이 점은 모든
소프트웨어에 이상적인 설계 같은 것은 없다는 사실을 간단히 반증하는 예라 할 수 있겠네
요. 무릇 최고의 설계는, 제작하려는 소프트웨어 시스템이 기대하는 바에 따라 달라지는 것
입니다. 오늘날도 그렇고 미래에도 마찬가지입니다. 여러분이 지금 만드는 응용프로그램이
비행에 대한 지식을 전혀 쓰지 않으며 나중에도 쓸 일이 없을 것이라면, 날 수 있는 새와
날지 않는 새를 구분하지 않는 것이 탁월한 선택일 수도 있습니다. 사실 이런 것들을 잘 구분
해서 설계하는 쪽이 바람직하기도 합니다. 나는 새도 있고 못 나는 새도 있다는 사실은 여러
분이 본뜨려고 하는 세계가 어떤 것이냐에 따라 고려해도 되고 안 해도 되니까 말입니다.

필자가 "모든 새는 날 수 있고, 팽권은 새인데, 팽권은 못 난다네. 에헤라디여" 문제라고 
이름 붙인 지금 이 문제에 대해 또 다른 대처 방법을 생각하시는 분들이 물론 있습니다. 그
방법이란, 팽권의 fly 함수를 재정의해서 런타임 에러를 내도록 하자는 거죠.

void error(const std::string& msg);	// 어딘가에 정의되어 있을 것입니다.

class Penguin: public Bird
{
public:
	virtual void fly() { error("Attempt to make a penguin fly!"); }
	...
};

눈을 크게 뜨고 보셔야 합니다. 위의 코드가 말하는 바는 여러분이 생각하고 있는 것과 
조금 다르기 때문입니다. 이 경우는 "팽권은 날 수 없다"가 아닙니다. "팽권은 날 수 있다. 
그러나 팽권이 실제로 날려고 하면 에러가 난다"라고 말하는 거라고요.

어떻게 그 차이를 알아챌 수 있을까요? 딴 것 있겠습니까, 에러가 발견될 때를 보면 되겠죠.
"팽권은 날 수 없다"라는 지령은 컴파일러가 내릴 수 있지만, "팽권이 실제로 날려고 하면
에러가 난다"라는 규칙을 위반하는 것은 프로그램이 실행될 때만 발견할 수 있습니다.

그럼 "팽뀐은 날 수 없다-도장 꽝"이라는 제약사항도 같이 넣어 보도록 하죠. penguin 
객체에 대해서는 비행과 관련된 함수를 정의하지 않도록 하면 되겠습니다.

class Bird
{
	...			// fly 함수가 선언되지 않았습니다.
};

class Penguin: public Bird
{
	...			// fly 함수가 선언되지 않았습니다.
};

이제 여러분이 팽권을 날려 보려고 하면, 컴파일 단계에서 컴파일러가 여러분이 뭔가를 어
겼다고 앙탈을 부려댈 것입니다.

Penguin p;
p.fly();		// 에러!

런타임 에러를 주는 방법을 썼을 때 생기는 일과 꽤나 다른 모습입니다. 이 방법을 쓰면
컴파일러는 p.fly를 호출하는 것에 대해 한 마디도 하지 않습니다. 항목 18에서 이야기했
듯이, 유효하지 않은 코드를 컴파일 단계에서 막아 주는 인터페이스가 좋은 인터페이스입니
다. 즉, 팽귄의 무모한 비행을 컴파일 타임에 거부하는 설계가 그것을 런타임에 뒤늦게 알아
채는 설계보다 훨씬 좋다는 말이죠.

런타임 에러보다 컴파일 타임 에러가 더 낫다.

혹시 몇몇 독자들은 조류학에 조예가 깊지 못해 지금까진 별 말 못했지만, 초등학교 시절쯤
에 해 본 도형놀이라면 한 번 해 볼 수 있다고 생각하고 계실 것 같습니다. 맞죠? 그러니까,
직사각형과 정사각형 나부랭이가 복잡해 봐야 얼마나 하겠냐, 이거죠?

좋습니다. 그럼 간단한 질문을 하나 드릴 테니 답해 보세요. Square(정사각형) 클래스는
Rectangle(직사각형) 클래스부터 상속을 받아야 할까요?

Square ->? Rectangle

"님아" 어이없다는 듯한 독자 여러분의 반응입니다. "당연하죠! 정사각형이 직사각형의 
일종이고, 그 반대는 대개 아니라는 건 누구나 다 안다고요" 뭐, 맞는 말입니다. 그
런데 학교 안에서만 맞는다는게 애석할 뿐이죠. 나잇살도 먹을 만큼 먹었으니 학교 
안에서나 먹힐 만한 이야기는 이제 그만 합시다.

class Rectangle
{
public:
	virtual void setHeight(int newHeight);
	virtual void setWidth(int newWidth);
	virtual int height() const;
	virtual int width() const;
	...
};

void makeBigger(Rectangle& r)		// r의 넓이를 늘리는 함수
{
	int oldHeight = r.height();
	r.setWidth(r.width()+10);		// r의 가로 길이에 10을 더합니다.
	assert(r.height() == oldHeight);	// r의 세로 길이가 변하지 않는다는
}										// 조건에 단정문을 걸어둡니다.

여기서 위의 단정문이 실패할 일이 없다는 것은 확실합니다. makeBigger 함수는 r의 
가로 길이만 변경할 뿐이고, 세로 길이는 바뀌지 않습니다.

이제 아래의 코드를 봐주세요. public 상속을 써서 정사각형을 직사각형처럼 처리하게끔
허용하는코드입니다.

class Square: public Rectangle{ ... };

Square s;
...
assert(s.width() == s.height());	// 이 단정문은 모든 정사각형에 대해 
									// 참이어야 한다.
makeBigger(s);				// 상속된 것이므로, s는 Rectangle의 일종.
							// 즉, s의 넓이를 늘릴 수 있다.
assert(s.width() == s.height);	// 이번에도 이 단정문이 모든 정사각형에
								// 대해 참이어여 한다.

당연히 두 번째 단정문도 실패해서는 안 됩니다. 정사각형의 정의가 그렇듯, 정사각형의 
가로 길이는 세로 길이와 같으니까요.

그런데 문제가 생겼습니다. 뭔가 조정이 필요한 단정문 이 한두 개가 아니지 않습니끼?
+	makeBigger 함수를 호출하기 전에, s의 세로 길이는 가로 길이와 같아야 합니다.
+	makeBigger 함수가 실행되는 중에, s의 가로 길이는 변하는데 세로 길이는 안 
	변해	야합니다.
+	makeBigger 함수에서 복귀한 후에, s의 세로 길이는 역시 가로 길이와 같아야 
	합니다(잘 보세요. s가 makeBigger로 넘겨질 때 참조에 의한 전달이 되고 있습
	니다. 따라서 makeBigger 함수가 변경하는 것은 s 그 자체이지, s의 사본이 
	아닙니다).

이로써 여러분은 이상하고 아름다운 'public 상속' 나라를 체험하는 것입니다. 이 나라는
다른 학문 분야(콕 집자면 수학이죠)에서까지 발휘된 여러분의 멋들어진 육감이 여러분 예상
대로 움직여 주지 않는 나라입니다. 작금의 상황에서 우리들의 발목을 잡고 있는 것은, 직사
각형의 성질중 어떤 것(가로 길이가 세로 길이에 상관없이 바뀔 수 있습니다)은 정사각형(가로
와 세로 길이가 같아야 합니다)에 적용할 수 없다는 점입니다. 그러나 public 상속은 기본
클래스 객체가 가진 모든 것들이('모든 것들'에 밑줄 확 그어 주세요) 파생 클래스 객체에도 
그대로 적용된다고 단정하는 상속입니다. 그런데 직사각형과 정사각형의 경우를 보면(항목 38
에서 보시게 될 set 및 list 예제의 경우도 마찬가지입니다) 이런 단정이 참이 될 수 없습
니다. 따라서 이 둘의 관계를 public 상속을 써서 표현하려고 하면 틀리는 것이 당연하지요. 
컴파일러 수준에서는 문법적 하자가 없기 때문에 이런 코드가 무사히 통과됩니다. 하지만 위의
코드에서 살펴보았듯이 무사통과된 코드가 제대로 동작할 거라는 보장은 없습니다. 코드가 컴
파일된다는 것이 제대로 동작한디는 의미는 아니거든요. 사실 이런 점 때문에라도 프로그래머
여러분은 계속 배움의 길을 꾸준히 개척해 가야 하는 것입니다(남들보다 더 자주 말이죠).

모처럼 새로 배운 객체 지향 설계를 한 번 써먹어 봤는데 몇 년 동안 소프트웨어를 개발해
오면서 쌓아 온 여러분의 직관적인 통찰력이 통하지 않는다고 해서 슬퍼하거나 노여워하지
마세요. 결코 헛공부가 아닙니다. 다만 여러분은 여러분이 갈고 닦아 머릿속에 넣어둔 설계
방법들에 '상속'이란 것을 지금 막 더한 것이고, 이제는 상속을 적절히 응용할 수 있도록 도
와줄 새로운 안목을 여러분의 직관적인 통찰력에 붙여 갈 순서입니다. 이렇게 하다 보면, 누
군가가 여러분에게 몇 페이지짜리 함수 하니를 보여줬는데 Penguin이 Bird로부터 상속
을 받거나 Square가 Rectangle로부터 상속을 받게 만들었던 일이 떠올라 지금처럼 씩
웃을 때가 언젠가는 올 겁니다. 아마 이게 제대로 하는 방법일지도 모르죠. 꼭 그렇지는 않
은 분도 계실 테지만요.

클래스들 사이에 맺을 수 있는 관계로 is-a 관계만 있는 것은 아닙니다.
두 가지가 더 있는데, 
하나는 "has-a(...는 ...를 가짐)"이고 
또 하나는 "is-implemented-in-terms-of(...는...를 써서 구현됨)"입니다.

이 두 가지는 항목 38 및 항목 39에서 보게 될 것입니다. C++ 코드를 보다 보면 is-a
이외의 나머지 두 관계를 is-a 관계로 모형화해서 설계가 이상하게 꼬이는 경우가 정말 
많습니다. 그러니까 클래스 사이에 맺을 수 있는 관계들을 명확하게 구분할 수 있도록 하고, 
이 각각을 C++로 가장 잘 표현히는 방법도 공부해 둘 것을 이 필자 여러분께 외치는 바입니다.

이것만은 잊지 말자!
*	public 상속의 의미는 "is-a(...는 ...의 일종)"입니다. 기본 클래스에 적용되는 
	모든 것들이 파생 클래스에 그대로 적용되어야 합니다. 왜냐하면 모든 파생 클래스 객체는 
	기본 클래스 객체의 일종이기 때문입니다.