항목 34: 인터페이스 상속과 구현 상속의 차이를 제대로 파악하고 구별하자

(public) 상속이라는 개념은 언뜻 보기에는 그다지 복잡하지 않은 것 같지만, 좀더 자세히
들여다보면 사실 두 가지로 나뉩니다. 하나는 함수 인터페이스의 상속이고, 또 하나는 함수
구현의 상속입니다. 인터페이스 상속 및 구현 상속의 차이는, 이 책의 "독자 여러분 반갑습
니다"에서 이야기한 바 있는 함수 선언(function declaration) 및 함수 정의(function
definition)의 차이와 맥을 같이 한다고 보면 됩니다.

클래스 설계자의 입장에서 보면, 멤버 함수의 인터페이스(선언)만을 파생 클래스에 상속받고
싶을 때가 분명히 있습니다. 어쩔 때는 함수의 인터페이스 및 구현을 모두 상속받고 그 상
속받은 구현이 오버라이드가 가능하게 만들었으면 하는 분도 계십니다. 반대로, 인터페이스와 
구현을 상속받되 어떤 것도 오버라이드할 수 없도록 막고 싶은 경우도 있을 거고요.

이러저러한 선택사항들 사이의 차이점은 몸으로 제대로 느껴보는게 중요합니다. 이런 의미
에서, 그래픽 응용프로그램에 쓰이는 기하학적 도형을 나타내는 클래스 계통구조를 놓고 한
번 생각해 봅시다.

class Shape
{
public:
	virtual void draw() const = 0;
	virtual void error(const std::string& msg);
	int objectID() const;
	...
};

class Rectangle: public Shape{...};
class Ellipse: public Shape{...};

Shape는 추상 클래스입니다. 순수 가상 함수인 draw가 바로 추상 클래스 딱지를 붙인 장
본인이죠. 결국, Shape 클래스의 인스턴스를 만들려고 하면 안 되고, 이 클래스의 파생 클
래스만 인스턴스화가 가능합니다. 하지만 아무 힘도 없을 것 같은 이 Shape가 이 클래스
로부터(public 상속에 의해) 파생된 클래스에 대해 미치는 영향은 가히 절대군주와 맞먹습
다. 어째서일까요?

*	멤버 함수 인터페이스는 항상 상속되게 되어 있기 때문입니다.
	항목 32 에서 설명했듯이, public 상속의 의미는 ls-a 이므로 기본 클래스에 
	해당하는 것들은 모두 파생 클래스에도 해당되어야 합니다. 따라서 어떤 클래스에서 
	동작하는 함수는 그 클래스의 파생	클래스에서도 동작해야 맞습니다.

Shape 클래스에는 세 개의 함수가 선언되어 있습니다. 첫째, draw 함수는 암시적인 표시
장치에 현재의 객체를 그립니다. 둘째, error 함수는 다른 멤버 함수들이 호출하는 함수로,
이들이 에러를 보고할 필요가 있을 때 사용됩니다. 셋째, objectID 함수는 주어진 객체에
붙는 유일한 정수 식별자를 반환합니다. 이들 세 함수는 선언된 방법도 각기 다릅니다.
draw는 순수 가상 함수이고, error는 단순(비순수?) 가상 함수입니다. objectID는 비가
상 함수로 선언되어 있고요. 그런데 선언이 다르다는 것에 대체 어떤 속뜻이 들어 있는 것일
까요?

자, 우선 순수 가상 함수인 draw부터 생각해 봅시다.

class Shape
{
public:
	virtual void draw() const = 0;
	...
};

순수 가상 함수에 대해 말씀드릴 수 있는 가장 두드러진 특정이라면 두 가지입니다.

첫째, 어떤 순수 가상 함수를 물려받은 구체 클래스가 해당 순수 가상 함수를 다시 
선언해야 합니다. 
둘째, 순수 가상 함수는 전형적으로 추상 클래스 안에서 정의를 갖지 않습니다. 이 두
가지를 하나로 모아 보변 다음과 같은 결론이 나옵니다.

*	순수 가상 함수를 선언히는 목적은 파생 클래스에게 함수의 인터페이스만을 
	물려주려는 것입니다.

Shape::draw 함수에 대해 정말이지 딱 맞는 이야기 아닙니까? 그도 그럴 것이, "Shape
계통을 따르는 모든 객체는 그리기(draw)가 가능해야 한다"라는 요구사항은 그리 이상할
것이 없지만, 그리기에 대해 구체적인 생각도 없이 객체를 만들었을 때도 '그리기'가 되도록
해 주는 draw 함수의 구현, 다시 말해 기본 구현을 제공하는 것은 Shape 클래스 차원에
서 어떻게 할 수가 없으니 말입니다. 이를테면, 타원을 그리는 알고리즘은 직사각형을 그리
는 알고리즘과 같을래야 같을 수 없을 것입니다. Shape::draw 함수의 선언은 차후에
Shape로부터 구체 클래스를 파생시킬 설계자에게 "draw 함수는 여러분이 직접 제공하도
록 하시우. 하지만 당신이 어떻게 구현할지에 대해선 난 아무 생각 없소"라고 말하는 것과
같습니다.

말 나온 김에 드리는 말씀인데요. 사실은 순수 가상 함수에도 정의를 제공할 수 있습니다.
다시 말해, Shape::draw 함수에 대해 구현을 붙일 수 있다는 이야기예요. C++도 이에
대해 툴툴거리는 일이 없습니다. 단, 구현이 붙은 순수 가상 함수를 호출하려면 반드시 
클래스 이름을 한정자로 붙여 주어야만 한다는 점7)도 힘주어 말씀드립니다.

7) 추상 클래스로는 인스턴스를 만들 수 없으므로 당연한 이치라 하겠다 - 옮긴이

Shape *ps = new Shape;		// 에러! Shape는 추상 클래스다.

Shape *ps1 = new Rectangle;
ps1->draw();				// Rectangle::draw를 호출

Shape *ps2 = new Ellipse;
ps2->draw();				// Ellipse::draw를 호출

ps1->Shape::draw();		// Shape::draw를 호출(구현된 순수 가상 함수)
ps2->Shape::draw();		// Shape::draw를 호출(구현된 순수 가상 함수)

프로그래머 동호회 정기 모임 같은 곳에서 좀 튀어 보이기 위해 이런 이야기를 끄집어내어서
써먹는 건 여러분야 알아서 할 일이고요. 어쨌든 방금 말씀드린 부분은 이후에도 잊어버리지
않는 것이 긴 인생에 도움이 될 겁니다. 뒤에서 확인하시겠지만, 이 부분은 단순(비순수) 가상
함수에 대한 기본 구현을 종전보다 안전하게 제공하는 메커니즘으로도 활용할 수 있습니다.
다음은 단순(비순수) 가상 함수입니다. 단순 가상 함수의 이면에 들어 있는 속뜻은 순수 가상
함수의 그것과 비교할 때 몇 가지 다른 면을 갖고 있습니다. 파생 클래스로 하여금 함수의
인터페이스를 상속하게 한다는 점은 똑같지만, 파생 클래스 쪽에서 오버라이드할 수 있는
함수 구현부도 제공한다는 점이 다릅니다. 1분만 곰곰이 생각해 보시면 다음과 같은 속
뜻이 있음을 알게 될 것입니다.

*	단순 가상 함수를 선언하는 목적은 파생 클래스로 하여금 함수의 인터페이스뿐만 
	아니라 그 함수의 기본 구현도 물려받게 하자는 것입니다.

그럼, Shape::error 함수의 경우를 한번 생각해 보죠.

class Shape
{
public:
	virtual void error(const std::string& msg);
	...
};

이 인터페이스가 전하는 바는 이렇습니다. 실행 중에 에러와 마주쳤을 때 자동으로 호출될
함수를 제공하는 것은 모든 클래스가 해야 하는 일이지만, 그렇다고 각 클래스마다 그때그
때 꼭 맞는 방법으로 에러를 처리할 필요는 없다는 것입니다. 에러가 생기더라도 특별히 해
주는 일이 없는 클래스라면, Shape 클래스에서 기본으로 제공되는 에러 처리를 그냥 써도
됩니다. 다시 말해, Shape::error 함수의 선언문은 나중에 파생 클래스를 설계할 개발
자에게 이런 메시지를 전히는 것입니다. "error 함수는 여러분이 지원해야 한다우. 그러나
굳이 새로 만들 생각이 없다면 Shape 클래스에 있는 기본 버전을 그냥 쓰시구려."

알고 보면 단순 가상 함수에서 함수 인터페이스와 기본 구현을 한꺼번에 지정하도록 내버려
두는 것은 위험할 수도 있습니다. 이유를 설명하기 위해 예를 하나 들겠습니다. XYZ라는
이름의 가상의 항공사가 있고 이 항공사의 비행기는 A 모델과 B 모델, 이렇게 두 가지밖에
없습니다. 게다가 이 두 모델은 비행 방식이 똑같습니다. 따라서 XYZ의 비행기는 다음과
같은 클래스 계통으로 설계할 수 있을 것입니다.

class Airport {...};// 공항을 나타내는 클래스

class Airplane
{
public:
	virtual void fly(const Airport& destination);
	...
};

void Airplane::fly(const Airport& destination)
{
	//주어진 목적지로 비행기를 날려 보내는 기본 동작 원리를 가진 코드
}

class ModelA: public Airplane {...};
class ModelB: public Airplane {...};

보시다시피 Airplane::fly 함수는 가상 함수로 선언되어 있습니다. 모든 비행기는 fly
함수를 지원해야 한다는 점을 나타내야 하니까요. 또 모델이 다른 비행기는 원칙상 fly 함
수에 대한 구현을 저마다 다르게 요구할 수 있다는 사실을 알고 있다는 뜻도 되는 거죠. 
하지만 ModelA 및 ModelB 클래스에 대해 똑같은 코드를 작성하지는 말아야 하므로, 기본
적인 비행 원리를 Airplane::fly 함수의 본문으로 제공함으로써 이것을 ModelA 및
ModelB가 물려받을 수 있도록 하였습니다.

지극히 고전적인 객체 지향 설계라는 점은 두 말 하면 입만 아프겠지요. 두 클래스가 하나
의 공통 특정(fly 함수를 구현하는 방법)을 공유하고 있으므로, 이 공통 특징을 기본 클래스
로 올려보낸 뒤에 두 클래스가 이 특징을 물려받는 식으로 설계된 것입니다. 설계를 이렇게
하면 우선 클래스 사이의 공통 사항으로 둘 수 있는 특징이 명확해지고, 코드가 중복되지
않게 되며, 이후의 기능 개선의 통로도 열려 있게 되는데다가, 장기적인 유지보수도 쉬워집
니다. 입에 거품을 물고 객체 지향 기술을 좋아라 하는 이유들 전부입니다. XYZ 항공사에
게는 아주 훈훈한 상황이겠죠.

이와 같은 훌륭한 설계에 힘입어 매출도 죽죽 올라가는 XYZ 항공사가 새로운 항공기 형태
를 도입하기로 결정합니다. 이른바 C모델입니다. C 모델은 지금까지의 A 모델 및 B 모델
과 비교할 때 몇 가지가 사뭇 다릅니다. 특히, 비행 방식이 완전히 다릅니다.

XYZ 항공사의 프로그래머들은 서둘러 C 모델을 위한 클래스를 기존의 클래스 계통에 추가
했지만, 새 모델을 서비스에 투입하려고 허둥대다가 그만 fly 함수를 재정의히는 것을 잊
어버리고 말았습니다.

class ModelC: public Airplane 
{
	...	// fly 함수가 선언되지 않음
};

이것을 가지고 코드를 만든다면 아래와 크게 다르지 않게 나올 것입니다. 

Airport PDX {...};	// PDX는 필자의 집에서 가까운 곳에 있는 공항입니다.

Airplane *ps = new ModelC;
...
pa->fly(PDX);	// Airplane::fly 함수가 호출됨.

아니, 이게 무슨 개념이탈이란 입니까? ModelC 객체가 마치 ModelA 혹은 ModelB라
도 된 것처럼 날려보는 코드란 말입니다. 여행 업계에서 빈축을 사기에 부족함이 없는 행동
이라고나 할까요.

작금의 문제는 Airplane::fly 함수가 기본 동작을 구현해서 갖고 있다는 점이 아니라,
ModelC 클래스는 이 기본 동작을 원한다고 명시적으로 밝히지 않았는데도 이 동작을 물려
받는 데 아무런 걸림돌이 없다는 점입니다. 단, 기본 동작을 파생 래스에게 제공하는 것도
쉽지만 파생 클래스에서 요구하지 않으면 주지 않는 방법도 그리 어렵지 않아서 다행입니다.
일종의 수법인데요. 가상 함수의 인터페이스와 그 가상 함수의 기본을 잇는 연결 관계
를 끊어 버리는 것입니다. 실제로 어떻게 하는지는 아래의 코드에서 확인하세요.

class Airplane
{
public:
	virtual void fly(const Airport& destination) = 0;
	...
protected:
	void defaultFly(const Airport& destination);
};

void Airplane::defaultFly(const Airport& destination)
{
	주어진 목적지로 비행기를 날려 보내는 기본 동작 원리를 가진 코드
}

Airplane::fly 함수가 순수 가상 함수로 바뀌었는데, 어떻게 바뀌었는지 잘 보시기 바
랍니다. 이 가상 함수가 바로 fly 함수의 인터페이스를 제공하는 역할을 맡게 됩니다. 그렇
다고 이전의 기본 구현이 사라진 것은 아니고, 여전히 Airplane 클래스에 남아 있습니다.
단, 지금은 defaultFly라는 이름의 별도의 함수로 거듭났습니다. 기본 동작을 쓰고 싶은
클래스, 다시 맑해 ModelA 및 ModelB 등에서는 fly 함수의 본문 안에서 그냥 이
defaultFly 함수를 인라인 호출하기만 하면 됩니다(아, 함수 인라인과 가상 함수의 상호 작
용에 대한 이야기를 항목 30에 신경 써서 마련해 두었으니 참고하세요).

class ModelA: public Airplane
{
public:
	virtual void fly(const Airport& destination)
	{
		defaultFly(destination);
	}
	...
};

class ModelB: public Airplane
{
public:
	virtual void fly(const Airport& destination)
	{
		defaultFly(destination);
	}
	...
};

이제는 ModelC 클래스가 자신과 맞지 않는 기본 구현을 우연찮게 물려받을 가능성은 없어
졌습니다. fly 함수가 Airplane의 순수 가상 함수로 선언되어 있어서, ModelC
자신만의 버전을 스스로 제공하지 않으면 안되는 상황이니 말입니다.

class ModelC: public Airplane
{
public:
	virtual void fly(const Airport& destination);
	...
};

void ModelC::fly(const Airport& destination)
{
	주어진 목적지로 ModelC 비행기를 날려 보내는 코드
}

이 방법으로 프로그래머의 실수를 100% 막을 수는 없지만(여전히 '복사해서 붙이기' 신공으로
주위를 난감하게 만들 수 있습니다), 원래의 설계보다는 훨씬 믿고 쓸 만해졌습니다. 시간이 남
은 김에 Airplane::defaultFly 함수에 대해서도 좀 끼적여 보겠습니다. 이 함수는
protected 멤버입니다 Airplane 및 그 클래스의 파생 클래스만 내부적으로 사용하는
구현 세부사항이기 때문에 그런 거죠. 비행기를 사용하는 사용자는 '비행기가 날 수 있다'라
는 점만 알면 될 뿐, '비행 동작이 어떻게 구현되는가'는 신경 쓰지 말아야 합니다.

또 다른 중요사항은 Airplane::defaultFly 함수가 비가상 함수라는 점입니다. 그 이유
는 파생 클래스에서 이 함수를 재정의해선 안 되기 때문입니다. 항목 36에서 그대로 알
려 주는 내용이기도 합니다. 만일 defaultFly가 가상 함수이면 여러분은 열심히 꼬리에
꼬리를 무는 문제에 빠질 수 있거든요. 즉, 어떤 파생 클래스에서 defaultFly를 재정의
하는 것을 잊어버렸다면 대체 어떻게 해야 하냐는 거죠.

인터페이스 및 기본 구현을 제공히는 함수, 그러니까 fly 및 defaultFly 같은 함수를
별도로 마련하는 아이디어를 별로 좋아하지 않는 분들도 더러 있습니다. 그다지 중요하지도
않은 관계로 얽힌 함수 이름들이 군웅할거하면서 클래스의 네임스페이스가 더러워진다는 
것을 한 가지 이유로 지적합니다. 그러면서도 인터페이스와 기본 구현이 분리되어야 
한다는 점은 여전히 동의하고 있더군요. 외견상 부조리처럼 보이는 이런 상황을 그 분들은 
어떤 식으로 해결하는 걸까요? 방법적으로는 순수 가상 함수가 구체 파생 클래스에서 재
선언되어야 한다는 사실을 활용하되, 자체적으로 순수 가상 함수의 구현을 구비해 두는 거
라고 합니다. 그럼, 순수 가상 함수를 정의하는 기능을 Airplane 클래스 계통에서 어떻게
활용할 수 있을지 다음의 코드로 확인해 볼까요?

class Airplane
{
public:
	virtual void fly(const Airport& destination) = 0;
	...
};

void Airplane::fly(const Airport& destination)// 순수 가상함수의 구현
{
	주어진 목적지로 비행기를 날려 보내는 기본 코드
}

class ModelA: public Airplane
{
public:
	virtual void fly(const Airport& destination)
	{ Airplane::fly(destination); }
	...
};

class ModelB: public Airplane
{
public:
	virtual void fly(const Airport& destination)
	{ Airplane::fly(destination); }
	...
};

class ModelC: public Airplane
{
public:
	virtual void fly(const Airport& destination)
	...
};

void ModelC::fly(const Airport& destination)
{
	주어진 목적지로 ModelC 비행기를 날려 보내는 코드
}

별도의 함수인 Airplane::defaultFly의 자리에 순수 가상 함수인 Airplane::fly의 
본문이 들어와 있는 것만 제외하면 이전의 설계와 거의 똑같습니다. 요컨대 fly함수가 
선언부 및 정의부의 두 쪽으로 나뉜 것입나다. 선언부는 이 함수의 인터페이스(파생 클래스
가 사용해야 하는)를 지정하고, 정의부는 이 함수의 기본 동작(파생 클래스가 사용해도 되
나, 명시적으로 원할 경우에만 사용이 가능한)을 지정합니다. 하지만 fly와 defaultFly가
하나로 합쳐지는 바람에 함수 양쪽에 각기 다른 보호 수준을 부여할 수 있는 융통성은 날아
가고 말았습니다. 그러니까, (defaultFly에 들어 있음으로써) protected 영역에 있었던
코드가 이제는 public 영역에 있게 되었습니다(fly 안으로 옮겨졌으니까요).

자, 이제는 대미를 장식할 세 번째 함수, Shape의 비가상 함수인 ObjectID입니다.class Shape{public:	int objectID() const;	...};멤버 함수가 비가상 함수로 되어 있다는 것은, 이 함수는 파생 클래스에서 다른 행동이 일
어날 것으로 가정하지 않았다는 뜻입니다. 실제로, 비가상 멤버 함수는 클래스 파생에 상관없
이 변하지 않는 동작을 지정하는 데 쓰입니다. 이 함수의 역할 자체가, 미래에 만들어질 파생
클래스가 아무리 특수한 클래스라 해도 변하지 않는 동작을 수행히는 것이기 때문입니다.
깔끔히 정리하면,

*	비가상 함수를 선언하는 목적은 파생 클래스가 함수 인터페이스와 더불어 그 함수의 필수
	적인 구현(mandatory implementation)을 물려받게 하는 것입니다.

그러니까, Shape::objectID의 선언은 이렇게 말하는 것이라고 생각하면 맞습니다­.
"Shape 및 이것에서 파생된 모든 객체는 객체의 식별자를 내어 주는 함수를 갖게 되겠지.
객체 식별자를 계산하는 방법은 항상 똑같겠군. 실제 계산 방법은 Shape::objectID의
정의에서 결정되고, 파생 클래스는 이것을 바꿀 수 없겠는걸." 비가상 함수는 클래스 파생에
상관없는 불변동작8)과 같기 때문에, 파생 클래스에서 재정의할 수 있는 수준의 것이 절대로
아닙니다. 이 부분은 항목 36에서 자세히 살펴보겠습니다.

순수 가상 함수, 단순 가상 함수, 비가상 함수의 선언문이 가진 이런저런 차이점 덕택에, 
여러분은 파생 클래스가 물려받았으면 하는 것들을 정밀하게 지정할 수 있습니다. 판단에 
따라 인터페이스만 상속시켜도 되고 인터페이스와 기본 구현을 함께 상속시킬 수도 있으며,
아니면 인터페이스와 필수 구현을 상속시킬 수 있는 것입니다. 각각의 선언문 형식만큼 뜻
하는 바도 제각각이기 때문에, 어떤 클래스에 멤버 함수를 선언해 넣는 여러분은 이들 중
하나를 고를 때 각별히 신경을 쓰셔야 합니다. 멤버 함수를 선언할 때, 클래스 설계를 많이
해 보지 못한 분들의 클래스에서 가장 흔히 발견되는 결정적인 실수 두 가지도 피해 주셨으
면 좋겠습니다.

첫 번째 실수는 모든 멤버 함수를 비가상 함수로 선언하는 것입니다. 이렇게 하면 파생 클
래스를 만들더라도 기본 클래스의 동작을 특별하게 만들 만한 여지가 없어지게 되죠. 특히
비가상 소멸자가 문제거리가 될 수 있습니다(항목 7 참조). 아, 물론 클래스 파생을 처음부터
염두에 두지 않은 클래스를 설계히는 경우는 얼마든지 있습니다. 사실 이런 용도의 클래스
는 비가상 함수들만 모아두는 게 맞죠. 하지만 가상 함수와 비가상 함수의 차이에 대한 생
각도 잘 하지 않고 이런 클래스를 선언하거나, 가상 함수를 쓰면 무조건 성능이 안 좋은 줄
만 알고 이런 클래스를 선언하는 분들이 안타까울 정도로 많다는 것이 문제입니다. 진실은
안 변합니다. 기본 클래스로 쓰이는 클래스는 십중팔구 가상 함수를 갖고 있게 됩니다(역시
항목 7 참조).

가상 함수의 비용 때문에 마음이 편치 않으신 분께는, 홀륭한 선배님들이 남기신 경험의 산
물인 80-20 법칙을 말씀드리고 싶습니다(항목 30 참조). 이 법칙은 어지간한 프로그램에서는
전체 실행 시간의 80%가 소모되는 부분이 전체 코드의 20%밖에 되지 않는다는 법칙입니다.
굉장히 중요한 법칙입니다. 왜냐하면 정말 특수한 상황이 아니면 함수 호출 중 80%를 가상
함수로 두더라도 여러분 프로그램의 전체 수행 성능에는 가장 약하게 느낄 수 있을 만큼의
손실도 생기지 않는다는 뜻이기 때문입니다. 가상 함수의 비용을 물까 말까 갈팡질팡하며
눈가에 그늘 만드시기 전에, 비용을 무느냐 안 무느냐에 따라 진짜 큰 차이를 만들 수 있는
20%의 코드에 좀더 집중해 보시는 게 어띨는지요.

8)	원서에서는 invriant라고 쓰였다. 많은 경우에 쓰이는 invriant는 어떤 객체의 
	유효한 상태를 규정하는 조건 혹은 그 조건을 점검하는 코드를 일컫는 전문 용어로, 
	불변식 혹은 불변속성이란 우리말 대역을 가지고 있으나, 여기서 쓰인 invriant는 
	그와 달리 동작이 변하지 않는 함수라는 뜻이다.-옮긴이

또 한 가지 실수는 모든 멤버 함수를 가상 함수로 선언하는 것입니다. 아, 물론 맞을 경우도
없는 것은 아닙니다. 항목 31의 인터페이스 클래스가 그 증거니까요. 하지만 어떻게 보면 이
클래스를 설계한 사람은 자신이 만든 것을 남에게 보일 용기가 없는 부끄럼쟁이가 아닌가
하는 인상을 줄 수도 있습니다. 분명히 파생 클래스에서 재정의가 안 되어야 하는 함수도
분명히 있을 것입니다. 그리고 이런 함수가 있으면 반드시 비가상 함수로 만들어 둠으로써
입장을 확실히 밝히는 것이 제대로 된 자세죠. 잠깐 시간 내서 아무 함수나 재정의하면 모
든 사람의 입맛에 짝짝 맞게 돌아가는 클래스인 척(!) 한다고 해서 누구도 고맙다고 하지 않
습니다. 클래스 파생에 상관없는 불변동작을 갖고 있어야 한다면, 움츠리지 말고 똑 부러지
게 말하란 말입니다. '그렇게 할거야'라고요.

이것만은 잊지 말자!
*	인터페이스 상속은 구현 상속과 다릅니다. public 상속에서, 파생 클래스는 항상 기본
	클래스의 인터페이스를 모두 물려받습니다.
*	순수 가상 함수는 인터페이스 상속만을 허용합니다.
*	단순(비순수) 가상 함수는 인터페이스 상속과 더불어 기본 구현의 상속도 가능하도록 
	지정합니다.
*	비가상 함수는 인터페이스 상속과 더불어 필수 구현의 상속도 가능하도록 지정합니다.