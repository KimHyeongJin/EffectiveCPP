항목 34: 인터페이스 상속과 구현 상속의 차이를 제대로 파악하고 구별하자

(public) 상속이라는 개념은 언뜻 보기에는 그다지 복잡하지 않은 것 같지만, 좀더 자세히
들여다보면 사실 두 가지로 나뉩니다. 하나는 함수 인터페이스의 상속이고, 또 하나는 함수
구현의 상속입니다. 인터페이스 상속 및 구현 상속의 차이는, 이 책의 "독자 여러분 반갑습
니다"에서 이야기한 바 있는 함수 선언(function declaration) 및 함수 정의(function
definition)의 차이와 맥을 같이 한다고 보면 됩니다.

클래스 설계자의 입장에서 보면, 멤버 함수의 인터페이스(선언)만을 파생 클래스에 상속받고
싶을 때가 분명히 있습니다. 어쩔 때는 함수의 인터페이스 및 구현을 모두 상속받고 그 상
속받은 구현이 오버라이드가 능하게 만들었으면 하는 분도 계십니다. 반대로, 인터페이스와 
구현을 상속받되 어떤 것도 오버라이드할 수 없도록 막고 싶은 경우도 있을 거고요.

이러저러한 선택사항들 사이의 차이점은 몸으로 제대로 느껴보는게 중요합니다. 이런 의미
에서, 그래픽 응용프로그램에 쓰이 는 기하학적 도형을 나타내는 래스 계통구조를 놓고 한
번 생각해 봅시다.class Shape{public:	virtual void draw() const = 0;	virtual void error(const std::string& msg);	int objectID() const;	...};class Rectangle: public Shape{...};class Ellipse: public Shape{...};Shape는 추상 클래스입니다. 순수 가상 함수인 draw가 바로 추상 클래스 딱지를 붙인 장
본인이죠. 결국, Shape 클래스의 인스턴스를 만들려고 하면 안 되고, 이 클래스의 파생 클
래스만 인스턴스화가 가능합니다. 하지만 아무 힘도 없을 것 같은 이 Shape가 이 클래스
로부터(public 상속에 의해) 파생된 클래스에 대해 미치는 영향은 가히 절대군주와 맞먹습
다. 어째서일까요?

*	멤버 함수 인터페이스는 항상 상속되게 되어 있기 때문입니다.
	항목 32 에서 설명했듯이, public 상속의 의미는 ls-a 이므로 기본 클래스에 
	해당하는 것들은 모두 파생 클래스에도 해당되어야 합니다. 따라서 어떤 클래스에서 
	동작하는 함수는 그 클래스의 파생	클래스에서도 동작해야 맞습니다.

Shape 클래스에는 세 개의 함수가 선언되어 있습니다. 첫째, draw 함수는 암시적인 표시
장치에 현재의 객체를 그립니다. 둘째, error 함수는 다른 멤버 함수들이 호출하는 함수로,
이들이 에러를 보고할 필요가 있을 때 사용됩니다. 셋째, objectID 함수는 주어진 객체에
붙는 유일한 정수 식별자를 반환합니다. 이들 세 함수는 선언된 방법도 각기 다릅니다.
draw는 순수 가상 함수이고, error는 단순(비순수?) 가상 함수입니다. objectID는 비가
상 함수로 선언되어 있고요. 그런데 선언이 다르다는 것에 대체 어떤 속뜻이 들어 있는 것일
까요?

자, 우선 순수 가상 함수인 draw부터 생각해 봅시다.

class Shape
{
public:
	virtual void draw() const = 0;
	...
};

순수 가상 함수에 대해 말씀드릴 수 있는 가장 두드러진 특정이라면 두 가지입니다.

첫째, 어떤 순수 가상 함수를 물려받은 구체 클래스가 해당 순수 가상 함수를 다시 
선언해야 합니다. 
둘째, 순수 가상 함수는 전형적으로 추상 클래스 안에서 정의를 갖지 않습니다. 이 두
가지를 하나로 모아 보변 다음과 같은 결론이 나옵니다.

*	순수 가상 함수를 선언히는 목적은 파생 클래스에게 함수의 인터페이스만을 
	물려주려는 것입니다.

Shape::draw 함수에 대해 정말이지 딱 맞는 이야기 아닙니까? 그도 그럴 것이, "Shape
계통을 따르는 모든 객체는 그리기(draw)가 가능해야 한다"라는 요구사항은 그리 이상할
것이 없지만, 그리기에 대해 구체적인 생각도 없이 객체를 만들었을 때도 '그리기'가 되도록
해 주는 draw 함수의 구현, 다시 말해 기본 구현을 제공하는 것은 Shape 클래스 차원에
서 어떻게 할 수가 없으니 말입니다. 이를테면, 타원을 그리는 알고리즘은 직사각형을 그리
는 알고리즘과 같을래야 같을 수 없을 것입니다. Shape::draw 함수의 선언은 차후에
Shape로부터 구체 클래스를 파생시킬 설계자에게 "draw 함수는 여러분이 직접 제공하도
록 하시우. 하지만 당신이 어떻게 구현할지에 대해선 난 아무 생각 없소"라고 말하는 것과
같습니다.

말 나온 김에 드리는 말씀인데요. 사실은 순수 가상 함수에도 정의를 제공할 수 있습니다.
다시 말해, Shape::draw 함수에 대해 구현을 붙일 수 있다는 이야기예요. C++도 이에
대해 툴툴거리는 일이 없습니다. 단, 구현이 붙은 순수 가상 함수를 호출하려면 반드시 
클래스 이름을 한정자로 붙여 주어야만 한다는 점7)도 힘주어 말씀드립니다.