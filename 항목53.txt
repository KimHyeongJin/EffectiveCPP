항목 53: 컴파일러 경고를 지나치지 말자.

아침 식사 거르듯이 컴파일러 경고 보기를 돌같이 하는 프로그래머들을 자주 보곤 합니다.
진짜로 심각한 문제라면 컴파일러 경고가 아니라 에러가 나올 테지, 그렇게 생각하시고 계시
는 거죠? 다른 언어에서는 이렇게 생각한다고 해서 큰 문제가 생기지는 않을지도 모릅니다.
하지만 C++의 경우에는 여러분이 저질러 놓은 코드가 어떤 것인가에 대해 컴파일러 제작
자가 여러분보다 더 잘 이해하고 있기를 바라는 것 자체가 큰 도박입니다. 예를 하나 들죠.
누구나 한 번쯤은 저질러 봤을 법한 실수 하나를 아래에 써 보겠습니다.

class B
{
	public:
		virtual void f() const;
};

class D: public B
{
	public:
		virtual void f();
};

가상 함수인 B::f를 D::f에서 재정의(redefine, 오바라이드) 하겠다는 의도인데, 여기에 
실수가 숨어 있습니다. B 클래스의 f는 상수(const) 멤버 함수이지만, D 클래스의 f는 괄호 
뒤에 const가 붙어 있지 않습니다. 필자가 알고 있는 컴파일러 중 하나를 써서 이 코드를 
돌리면 다음과 같은 경고가 나오더군요.

warning: D::f() hides virtual B::f();
가려지는 것은 public 함수를 하위 클래스에서 재정의 했을 때?
하위 클래스에서 가상 함수를 재정의 하는 것은 가려지는 것이 아니다?

아직 산전수전 겪어 보지 못한 햇병아리 프로그래머들 사이엔 이 경고 메시지를 보고 당연 
하다는 듯 이렇게 반응하는 분들이 많더군요. "컴파일러께서 왜 이러시나... D::f가 B::f
를 가리지 안 가려? 그러라고 만든 건데!" 한 치의 어긋남 없이 틀렸습니다. 공부하세요.
너무나도 착하고 가련한 우리 컴파일러는 지금, B에서 선언된 f가 D에서 재선언된 것이 아
니라 아예 가려졌다는 사실을 목 놓아 외치는 중이란 말입니다(어째서 그런 것인지는 항목 33
을 읽으면 알 수 있습니다). 이 경고를 무시하고 지나갔다가는 프로그램이 십중팔구 이상하게
동작하게 될 것임은 물론, 다시 한 번 무한짜증 야근동반 디버깅과 이 밤을 다시 한 번 보내
며 고생하다가 결국 컴파일러가 처음에 잡아낸 그 부분을 넘어간 것이 문제였다는 사실을
아주 한참 후에에 알 거라니까요.

여러분이 주로 사용해 온 특정 컴파일러에서 내주는 경고 메시지들에 어느 정도 익숙해지고
나면, 이 외의 다른 메시지들도 어떤 뜻으로 나온 건지를 슬슬 이해하는 수준에 오게 됩니
다(눈에 보이는 것과 실제 뜻이 너무너무 자주 다르다는 게 문제죠). 이러한 경험이 웬만큼
쌓이면, 어떤 경고는 넘어가도 되고 어떤 경고는 없애주어야 하는지를 선택할 수 있는 공력
도 쌓입니다. 물론, 최고 경고 수준을 걸더라도 경고 메시지 없이 컴파일되는 코드를 작성
하는 것이 일반적으로 더 좋은 실천법이라는 보편타당한 가르침도 무시하면 안 되겠지요.
어떻게 했든 정말 중요한 점은 따로 있습니다. 여러분 눞앞에서 어떤 경고 메시지를 없애기
전에, 그 경고가 여러분에게 알리려는 바를 정확히 이해해햐 한다는 것입니다.

컴파일러 경고는 제작사의 고유 선택에 따라 달라지는 것이기 때문에, 이것만큼은 태생적으
로 구현별 의존 사항이란 사실을 잊지 마세요. 그렇기 때문에 여러분이 저지른 실수를 컴파
일러가 대신 잡아주는 것만 믿고 아무 생각 없이 쫄래쫄래 프로그래밍에 임하는 자세는 정
말 좋지 않습니다. 이름을 가리는 위의 예제 코드만 봐도 그렇습니다. 어떤 다른 컴파일러
(하지만 많이들 사용하는)의 경우에는 이 코드에 대해 찍 소리도 안 한단 말입니다.

이것만은 잊지 말자!
	*	컴파일러 경고를 쉽게 지나치지 맙시다. 여러분의 컴파일러에서 지원하는 최고
		경고 수준에도 경고 메시지를 내지 않고 컴파일되는 코드를 만드는 쪽에 전력을
		다 하십시오.
	*	컴파일러 경고에 너무 기대는 인생을 지양하십시오. 컴파일러마다 트집을 잡고
		경고를 내는 부분이 천차만별이기 때문입니다. 지금 코드를 다른 컴파일러로 이식
		하면서 여러분이 익숙해져 있는 경고 메시지가 온 데 간 데 없이 사라질 수도 
		있습니다.