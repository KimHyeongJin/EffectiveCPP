항목 15: 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자

자원 관리 클래스는 재치 만발의 듬직한 클래스입니다. 실수로 터질 수 있는 자원 누출을
튼튼히 막아 주는 보호벽 역할을 해 주니까요. 똑바로 설계된 시스템이라면 자원 누출이 없
어야 한다는 것은 기본적으로 갖추어야 할 덕목 아니겠습니까. 사실 우리네 세상이 순하게
살아도 아무 문제가 없는 세상이라면, 자원을 가지고 어떻게 해야 할 때 이런 클래스만 사용
해도 될 것입니다. 굳이 직접 실제 자원을 조작하느라 손을 더럽힐 이유가 없잖아요. 그런데
세상은 그리 만만하지 않습니다. 이미 현장에서 열심히 쓰이고 있는 수많은 API 들이 자원을
직접 참조하도록 만들어져 있어서, 하늘이 두 조각 나더라도 이것들을 안 쓰겠다고 마음
먹지 않는다면(이럴 일이 거의 없긴 하지요), 자원 관리 객체의 보호벽을 슬그머니 넘어가서
실제 자원을 직접 주물러야 할 일이 더러 있을 것입니다.

혹시 항목 13을 읽어 보셨나요? createInvestment 등의 팩토리 함수를 호출한 결과
(포인터)를 담기 위해 auto_ptr 혹은 tr1::shared_ptr과 같은 스마트 포인터를 사용
하는 아이디어가 소개되었었죠.

// 항목 13에서 가져온 예제
std::tr1::shared_ptr<Investment>pInv(createInvestment());

이때 어떤 Investment 객체를 사용하는 함수로서 여러분이 시용하려고 하는 것이 다음
과 같다고 가정해 봅시다.

int daysHeld(const Investment* pi);	// 투자금이 유입된 이후로 경과한 날수

그리고 이렇게 호출하고 싶을 텐데요.

int days = daysHeld(pInv);	// error!!

애석하게도 이 코드는 컴파일이 안 됩니다. daysHeld 함수는 Investment* 타입의 실
제 포인터를 원히는데, 여러분은 tr1::shared_ptr<Investment> 타입의 객체를 넘
기고 있잖아요.

사정이 이렇다 보니, RAII 클래스(지금은 tr1::shared_ptr)의 객체를 그 객체가 감싸고
있는 실제 지원(그러니까 Investment*)으로 변환할 방법이 필요해집니다. 이런 목적에 일
반적인 방법을 쓴다면 두 가지가 있는데, 

첫 번째는 명시적 변환(explicit conversion)이고
두 번째는 암시적 변환(implicit conversion)입니다.

tr1::shared_ptr 및 auto_ptr은 명시적 변환을 수행하는 get이라는 멤버 함수를
제공합니다. 다시 말해 이 함수를 사용하면 각 타입으로 만든 스마트 포인터 객체에 들어
있는 실제 포인터(의 사본)를 얻어낼 수 있습니다.

int days = daysHeld(pInv.get());	// 이제 문제없습니다. pInv에 들어 있는
									// 실제 포인터를 daysHeld에 넘기니까요.

제대로 만들어진 스마트 포인터 클래스라면 거의 모두가 그렇듯, tr1::shared_ptr과
auto_ptr은 포인터 역참조 연산자(operator-> 및 operator*)도 오버로딩하고 있습니
다. 따라서 자신이 관리하는 실제 포인터에 대한 암시적 변환도 쉽게 할 수 있습니다. 다음의
코드를 봐 주세요.

class Investment	// 여러 형태의 투자를 모델링한 투자 클래스들의 최상위 클래스
{
public:
	bool isTaxFree() const;
	...
};

Investment* createInvestment();	// 팩토리 함수

// tr1::shared_ptr이 자원 관리를 맡도록 합니다.
std::tr1::shared_ptr<Investment>pi1(createInvestment());

bool taxable1 = !(pi1->isTaxFree());	// operator->를 써서 자원에 접근

...
// auto_ptr로 하여금 자원 관리를 맡도록 합니다.
std::auto_ptr<Investment>pi2(createInvestment());

bool taxable2 = !((*pi2).isTaxFree());	// operator*를 써서 자원에 접근
...

RAII 객체 안에 들어 있는 실제 자원을 얻어낼 필요가 종종 생기기 때문에, RAII 클래스
설계자 중에는 암시적 변환 함수를 제공하여 자원 접끈을 매끄럽게 할 수 있도록 만드는 분
도 있답니다. 예를 들어, 어떤 하부 수준 C API로 직접 조작이 가능한 폰트를 RAII 클래스
로 둘러싸서 쓰는 경우를 생각해 보죠.

FontHandle getFont();	// C API에서 가져온 함수 - 매개변수가 있으면 복잡하기 
						// 때문에 생략

void releaseFont(FontHandle fh);

class Font	// RAII 클래스
{
public:
	explict Font(FontHandle fh):f(fh){} // 자원을 획득합니다. 여기서 값에
										// 의한 전달이 수행되는 것에 주의하세요.
										// 자원 해제를 C API로 하기 때문입니다.
	~Font(){ releaseFont(f); }
private:
	FontHandle f;	// 실제 폰트 자원
};

하부 수준 C API는 FontHandle을 사용하도록 만들어져 있으며 규모도 무척 크다고 가
정하면, Font 객체를 FontHandle로 변환해야 할 경우도 적지 않을 것이라는 예상을 해
볼 수 있죠. Font 클래스에서는 이를 위한 명시적 변환 함수로 get을 제공할 수 있을 것
입니다.

class Font
{
public:
	...
	FontHandle get() const { return f; }	// 명시적 변환 함수
	...
};

이렇게 해 두면 어쨌든 쓸 수 있긴 한데, 사용자는 하부 수준 API를 쓰고 싶을 때마다
get을 호출해야 할 것입니다.void changeFontSize(FontHandle f, int newSize);	// 폰트 API의 일부Font f(getFont());int newFontSize();...changeFontSize(f.get(), newFontSize);	// Font에서 FontHandle로										// 명시적으로 바꾼 후에 넘김.변환할 때마다 무슨 함수를 호출해 주어야 한다는 점이 짜증나서 Font 클래스를 안 쓰고
말겠다는 프로그래머도 분명히 나오게 됩니다. 이것 때문에 폰트 자원이 누출될 가능성이
늘어난다면 그것만큼 애석한 일도 없을 거예요. Font 클래스를 설계한 가장 큰 목적이 폰
트 자원의 누출을 막는 것인데도요.

대안이 없진 않습니다. FontHandle로의 암시적 변환 함수를 Font에서 제공하도록 하면
되는거죠.

class Font
{
public:
	...
	operator FontHandle() const { return f; }	// 암시적 변환 함수
	...
};

암시적 변환 함수 덕택에 C API를 사용하기가 훨씬 쉬워지고 자연스러워집니다.

Font f(getFont());
int newFontSize;
...
changeFontsize(f, newFontSize);	// Font에서 FontHandle로 암시적
								// 변환을 수행합니다.

그렇다고 마냥 좋은 것만은 아닙니다. 암시적 변환이 들어가변 실수를 저지를 여지가 많아
집니다. 진짜 Font를 쓰려고 한 부분에서 원하지도 않았는데 FontHandle로 덜커덕 바
뀔 수도 있다는 거죠.

Font f1(getFont());
...
FontHandle f2 = f1;	// 이런! 원래 의도는 Font 객체를 복사하는 것이었는데,
					// 엉뚱하게도 f1이 FontHandle로 바뀌고 나서 복사되어
					// 버렸습니다.

이렇게 되면 Font 객체인 f1이 관리하고 있는 폰트(FontHandle)가 f2를 통해서도 직
접 사용할 수 있는 상태가 됩니다. 하나의 지원이 양다리를 걸치고 있는 이와 같은 상황은
좋지 않습니다. f1이 소멸될 시점을 생각해 보세요. 당연히 폰트가 해제될 텐데, 그럼 f2는
해제된 폰트에 달랑달랑 매달려 있는꼴 이 되지 않겠어요?

RAII 클래스를 실제 자원으로 바꾸는 방법으로서 명시적 변환을 제공할 것인지(get 멤버
함수 등) 아니면 암시적 변환을 허용할 것인지에 대한 결정은 그 RAII 클래스만의 특정한
용도와 사용 환경에 따라 달라집니다. 어쨌든 가장 잘 설계한 클래스라면 항목 18의 조언을
따라 "제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게" 만들어져야 할 것입니다. 늘 그런 것은
아니지만, 암시적 변환보다는 get 등의 명시적 변환 함수를 제공하는 쪽이 나을 때가 많습
니다. 원하지 않은 타입 변환이 일어날 여지를 줄여주는 것은 확실하니까요. 하지만 암시적 타
입 변환에서 생기는 사용 시의 자연스러움이 빛을 발히는 경우도 있디는 점도 알아두셨으면
니다.

이번 항목을 읽으면서 혹시 이런 생각을 하신 분 없나요? RAII 클래스에서 자원 접근 함수
를 열어 주는 설계가 혹시 캡슐화에 위배되는 것은 아닌지 하고 말입니다. 솔직히 그렇긴
하지만, 처음부터 틀려먹은 엉망진창 설계도 아닙니다. RAII 클래스는 애초부터 데이터 은
닉이 목적이 아닙니다. 원하는 동작(자원 해제)이 실수 없이 이루어지도록 하면 OK인 걸요.
굳이 원한다면 '자원 해제'라는 기본 기능 위에 캡슐화 기능을 없을 수는 있겠지만, 꼭 필요
한 것은 아닙니다. 이야기가 왔으니 말입니다만, 시중에 나와 있는 RAII 클래스 중에는
이미 자원의 엄격한 캡슐화와 느슨한 캡슐화를 동시에 지원하는 것들도 꽤 있습니다. tr1::
share_ptr이 대표적인 예인데, 이 클래스는 참조 카운팅 메커니즘에 필요한 장치들은
모두 캡슐화하고 있지만, 그와 동시에 자신이 관리하는 포인터를 쉽게 접근할 수 있는 통로
도 여전히 제공하고 있습니다. 꼼꼼히 제대로 설계된 클래스가 그렇듯, 사용자가 볼 필요가
없는 데이터는 가리지만 고객 차원에서 꼭 접근해야 히는 데이터는 열어 주는 것입니다.

이것만은 잊지 말자!
*	실제 자원을 직접 접근해야 하는 기존 API들도 많기 때문에 RAII 클래스를 만들 때는
	그 클래스가 관리하는 자원을 얻을 수 있는 방법을 열어 주어야 합니다.
*	자원 접근은 명시적 변환 혹은 암시적 변환을 통해 가능합니다. 안전성만 따지면 명시적
	변환이 대체적으로 더 낫지만, 고객 편의성을 놓고 보면 암시적 변환이 괜찮습니다.