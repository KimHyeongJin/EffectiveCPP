항목 15: 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자

자원 관리 클래스는 재치 만발의 듬직한 클래스입니다. 실수로 터질 수 있는 자원 누출을
튼튼히 막아 주는 보호벽 역할을 해 주니까요. 똑바로 설계된 시스템이라면 자원 누출이 없
어야 한다는 것은 기본적으로 갖추어야 할 덕목 아니겠습니까. 사실 우리네 세상이 순하게
살아도 아무 문제가 없는 세상이라면, 자원을 가지고 어떻게 해야 할 때 이런 클래스만 사용
해도 될 것입니다. 굳이 직접 실제 자원을 조작하느라 손을 더럽힐 이유가 없잖아요. 그런데
세상은 그리 만만하지 않습니다. 이미 현장에서 열심히 쓰이고 있는 수많은 API 들이 자원을
직접 참조하도록 만들어져 있어서, 하늘이 두 조각 나더라도 이것들을 안 쓰겠다고 마음
먹지 않는다면(이럴 일이 거의 없긴 하지요), 자원 관리 객체의 보호벽을 슬그머니 넘어가서
실제 자원을 직접 주물러야 할 일이 더러 있을 것입니다.

혹시 항목 13을 읽어 보셨나요? createInvestment 등의 팩토리 함수를 호출한 결과
(포인터)를 담기 위해 auto_ptr 혹은 tr1::shared_ptr과 같은 스마트 포인터를 사용
하는 아이디어가 소개되었었죠.

// 항목 13에서 가져온 예제
std::tr1::shared_ptr<Investment>pInv(createInvestment());

이때 어떤 Investment 객체를 사용하는 함수로서 여러분이 시용하려고 하는 것이 다음
과 같다고 가정해 봅시다.

int daysHeld(const Investment* pi);	// 투자금이 유입된 이후로 경과한 날수

그리고 이렇게 호출하고 싶을 텐데요.

int days = daysHeld(pInv);	// error!!

애석하게도 이 코드는 컴파일이 안 됩니다. daysHeld 함수는 Investment* 타입의 실
제 포인터를 원히는데, 여러분은 tr1::shared_ptr<Investment> 타입의 객체를 넘
기고 있잖아요.

사정이 이렇다 보니, RAII 클래스(지금은 tr1::shared_ptr)의 객체를 그 객체가 감싸고
있는 실제 지원(그러니까 Investment*)으로 변환할 방법이 필요해집니다. 이런 목적에 일
반적인 방법을 쓴다면 두 가지가 있는데, 

첫 번째는 명시적 변환(explicit conversion)이고
두 번째는 암시적 변환(implicit conversion)입니다.

tr1::shared_ptr 및 auto_ptr은 명시적 변환을 수행하는 get이라는 멤버 함수를
제공합니다. 다시 말해 이 함수를 사용하면 각 타입으로 만든 스마트 포인터 객체에 들어
있는 실제 포인터(의 사본)를 얻어낼 수 있습니다.

int days = daysHeld(pInv.get());	// 이제 문제없습니다. pInv에 들어 있는
									// 실제 포인터를 daysHeld에 넘기니까요.

제대로 만들어진 스마트 포인터 클래스라면 거의 모두가 그렇듯, tr1::shared_ptr과
auto_ptr은 포인터 역참조 연산자(operator-> 및 operator*)도 오버로딩하고 있습니
다. 따라서 자신이 관리하는 실제 포인터에 대한 암시적 변환도 쉽게 할 수 있습니다. 다음의
코드를 봐 주세요.

class Investment	// 여러 형태의 투자를 모델링한 투자 클래스들의 최상위 클래스
{
public:
	bool isTaxFree() const;
	...
};

Investment* createInvestment();	// 팩토리 함수

// tr1::shared_ptr이 자원 관리를 맡도록 합니다.
std::tr1::shared_ptr<Investment>pi1(createInvestment());

bool taxable1 = !(pi1->isTaxFree());	// operator->를 써서 자원에 접근

...
// auto_ptr로 하여금 자원 관리를 맡도록 합니다.
std::auto_ptr<Investment>pi2(createInvestment());

bool taxable2 = !((*pi2).isTaxFree());	// operator*를 써서 자원에 접근
...

RAII 객체 안에 들어 있는 실제 자원을 얻어낼 필요가 종종 생기기 때문에, RAII 클래스
설계자 중에는 암시적 변환 함수를 제공하여 자원 접끈을 매끄럽게 할 수 있도록 만드는 분
도 있답니다. 예를 들어, 어떤 하부 수준 C API로 직접 조작이 가능한 폰트를 RAII 클래스
로 둘러싸서 쓰는 경우를 생각해 보죠.

FontHandle getFont();	// C API에서 가져온 함수 - 매개변수가 있으면 복잡하기 
						// 때문에 생략

void releaseFont(FontHandle fh);

class Font	// RAII 클래스
{
public:
	explict Font(FontHandle fh):f(fh){} // 자원을 획득합니다. 여기서 값에
										// 의한 전달이 수행되는 것에 주의하세요.
										// 자원 해제를 C API로 하기 때문입니다.
	~Font(){ releaseFont(f); }
private:
	FontHandle f;	// 실제 폰트 자원
};
