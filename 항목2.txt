항목 2: #define을 쓰려거든 const, enum, inline을 떠올리자
(가급적 선행 처리자보다 컴파일러를 더 가까이 하자)

결국 항목 이름을 위의 것으로 정하긴 했지만 "가급적 선행 처리자보다 컴파일러를 더 가까
이 하자"라는 제목으로 가는 게 더 괜찮았을 것 같긴 합니다. #define 은 C++ 언어 자체
의 일부가 아닌 것으로 취급될 수 있으니까 말이죠. 하기야 이 점도 문제입니다. 아래 줄과
비슷한 코드를 썼다고 가정해 보죠.

#define ASPECT_RATIO 1.653

우리에겐 이미 ASPECT_RATIO가 기호식 이름(symbolic name) 으로 보이지만 컴파일러에겐
전혀 보이지 않습니다. 소스 코드가 어떻게든 컴파일러에게 넘어가기 전에 선행 처리자가
밀어버리고 숫자 상수로 바꾸어 버리기 때문입니다. 그 결과후 ASPECT_RATIO라는 이름은
컴파일러가 쓰는 기호 테이블에 어가지 않지요. 그래서 숫자 상수로 대체된 코드에서 컴
파일 에러라도 발생하게 되면 꽤나 햇갈릴 수 있습니다. 소스 코드엔 분명히 ASPECT_
RATIO가 있었는데 에러 메시지엔 1.653이 있으니까요. 행여 ASPECT_RATIO가 정의된
파일이 여러분이 작성한 것이 아니면 곤란해집니다. 대체 1.653이 어디에서 왔는지 모를
수도 있고 이것을 찾아 들어가느라 시간을 허비할 일도 생길 테지요. 이 문제는 기호식 디
버거(symbolic debugger)에서도 나타날 소지가 있습니다. 마찬가지로 기호 테이블에 이름이
들어가지 않기 때문입니다.

이 문제의 해결법은 매크로 대신 상수를 쓰는 것입니다.

const double AspectRatio = 1.653;	// 대문자로만 표기히는 이름은 대개 매크로에
									// 쓰는 것이어서, 이름 표기도 바꿉니다.

AspectRatio는 언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 당연히 컴파일
러의 눈에도 보이며 기호 테이블에도 당연히 들어갑니다. 게다가 (위의 예제처럼) 상수가 부
동소수점 실수 타입일 경우에는 컴파일을 거친 최종 코드의 크기가 #define을 썼을 때보
다 작게 나올 수 있습니다. 가만히 생각해 보면 이유를 알 수 있는데요. 매크로를 쓰면 코드
에 ASPECT_RATIO가 등장하기만 하면 선행 처리지셰 의해 1.653으로 모두 바뀌면서 결국
목적 코드 안에 1.653의 사본이 등장 횟수만큼 들어가게 되지만, 상수 타입의 AspectRatio
는 아무리 여러번 쓰이더라도 사본은 딱 한 개만 생기기 때문입니다.

참, #define을 상수로 교체하려는 분께는 딱 두 가지 경우만 특별히 조심하라고 말씀드리
겠습니다.

첫째는 상수 포인터(constant pointer)를 정의하는 경우입니다. 
상수 정의는 대개 헤더 파일에 넣는 것이 상례이므로(다른 소스 파일이 이것을 인클루드해서 
쓰게 되지요) 포인터(pointer)는 꼭 const로 선언해 주어야 하고, 이와 아울러 포인터가 
가리키는 대상까지 const로 선언하는 것이 보통입니다. 이를테면 어떤 헤더 파일 안에 
char* 기반의 문자열 상수를 정의한다면 다음과 같이 const를 두 번 써야 한다는 말입니다.

const char * const authorName = "Scott Meyers";

const의 의미와 사용법에 대한 자세한 사항은 항목 3을 참고하시면 됩니다. 특히 포인터
와 함께 쓰일 경우에 대해 궁금하신 분은 꼭 보십시오. 참, 문자열 상수를 쓸 때 위와 이
char* 기반의 구닥다리 문자열보다는 string 객체가 대체적으로 사용하기 괜찮습니다.
그러니까 authorName은 다음과 이 정의히는 것이 더 좋다는 이야기죠.

const std::string authorName("Scott Meyers");

두 번째 경우는 클래스 멤버로 상수를 정의하는 경우, 즉 클래스 상수를 정의하는 경우입니
다. 어떤 상수의 유효범위를 클래스로 한정하고자 할 때는 그 상수를 멤버로 만들어야 하는
데, 그 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 정적(static) 멤버로 만들어야
합니다. 다음을 보시죠.

class GamePlayer
{
private:
	static const int NumTurns = 5;	// 상수 선언
	int scores[NumTurns];			// 상수를 사용하는 부분
	...
};

위에서 보신 NumTurns는 '선언(declaration)'된 것입니다. '정의'가 아니니 주의하세요.

C++에서는 여러분이 사용하고자 하는 것에 대해 '정의'가 마련되어 있어야 하는 게 보통이
지만, 정적 멤버로 만들어지는 정수류(각종 정수 타입, char, bool 등) 타입의 클래스 내부
상수는 예외입니다. 이들에 대해 주소를 취하지 않는 한, 정의 없이 선언만 해도 아무 문제
가 없게 되어 있습니다. 단, 클래스 상수의 주소를 구한다든지, 여러분이 주소를 구하지 않
는데도 여러분이 쓰는 컴파일러가 잘못 만들어진 관계로 정의를 달라고 떼쓰는 경우에는 별
도의 정의를 제공해야 합니다. 아래가 그 예입니다.

const int GamePlayer::NumTurns; // NumTurns의 정의. 값이 주어지지 않는
								// 이유는 아래를 계속 보시면 나옵니다.

이때 클래스 상수의 정의는 구현 파일에 둡니다. 헤더 파일에는 두지 않습니다.

* 정의에는 상수의 초기값이 있으면 안 되는데, 왜냐하면 클래스 상수의 초기값은 해당 상수가 선언된 시
점에서 바로 주어지기 때문입니다(즉, NumTurns는 선언될 당시에 바로 초기화된다는 것입니다).

그런데 주의할 것이 하나 있습니다. 혹시 클래스 상수를 #define으로 만드실 생각을 해
보는 건 아나죠? 방법 자체가 말이 안 됩니다. 대저 #define은 유효범위란 게 뭔지도 모
르는 피조물이니까요. 매크로는 일단 정의되면 컴파일이 끝날 때까지(중간에 #undef 되지만
않으면) 유효하다는 점을 기억해 두시기 바랍니다. 정리하면, #define은 클래스 상수를 정
의히는 데 쓸 수도 없을 뿐 아니라 어떤 형태의 캡슐화 혜택도 받을 수 없습니다. 말하자면
'private' 성격의 #define 같은 것은 없다는 이야기입니다. 물론, 이와 대조적으로 상수
데이터 멤버는 캡슐화가 되죠. NumTurns가 그거잖아요.

조금 오래된 컴파일러는 위의 문법을 받아들이지 않는 경우가 종종 있습니다. 이유는 간단
합니다. 정적 클래스 멤버가 선언된 시점에 초기값을 주는 것이 대개 맞지 않다고 판단하기
때문이죠. 게다가 클래스 내부 초기화를 허용하는 경우가 정수 타입의 상수에 대해서만 국
한되어 있으니 말입니다. 어쨌든 위의 문법이 먹히지 않는 컴파일러를 쓸 때는, 초기값을 상
수 '정의' 시점에 주도록 하십시오.

class CostEstimate
{
private:
	static const double FudgeFactor;	// 정적 클래스 상수의 선언
	...									// 이것은 헤더 파일에 둡니다.
};

const double CostEstimate::FudgeFactor = 1.35;	// 정적 클래스 상수의 정의
					// 이것은 구현 파일에 둡니다.

웬만한 경우라면 이것으로 충분합니다. 딱 한 가지 예외가 있다면 해당 클스를 컴파일하
는 도중에 클래스 상수의 값이 필요할 때인데, 이를테면 GamePlayer::scores 등의 배
열 멤버를 선언할 때가 대표적인 예입니다(컴파일러는 컴파일 과정에서 이 배열의 크기를 알아야
한다며 버틸 것입니다). 그렇기 때문에 정수 타입의 정적 클래스 상수에 대한 클래스 내 초기
화를 금지하는(다시 말하지만 이것은 표준에 어긋난 구식입니다) 구식 컴파일러에 대한 배려로
서 괜찮은 방법을 추천한다면, '나열자 둔갑술(enum hack)'이라는 통칭으로 멋스럽게(그리고
냄새 나지 않는 이미지로) 알려진 기법을 생각할 수 있겠습니다. 이 기법의 원리는 나열자
(enumerator) 타입의 값은 int가 놓일 곳에도 쓸 수 있다는 C++의 진실을 적극 활용하는
것입니다. 그러니까 GamePlayer는 다음과 이 정의할 수 았다는 거죠.

class GamePlayer
{
private:
	enum { NumTurns = 5 };	// "나열자 둔갑술":Numturns를 5에 대한 기호식
							// 이름으로 만듭니다.
	int scores[NumTurns];	// 깔끔하게 해결!
	...
};

이 나열자 둔갑술은 알아 두는 것이 여러가지 이유로 피가 되고 살이 됩니다.

첫째, 나열자 둔갑술은 동작 방식이 const보다는 #define에 더 가깝습니다. 
바로 지금의 여러분이 원하는 바랄까요. 예를 들어, const의 주소를 잡아내는 것은 합당하지만, 
enum의 주소를 취하는 일은 불법 이며 #define의 주소를 얻는 것 역시 맞지 않습니다. 
혹시 여러분이 선언한 정수 상수를 가지고 다른 사람이 주소를 얻는다든지 참조자를 쓴다든지 하는 
것이 싫다면 enum 이 아주 좋은 자물쇠가 될 수 있습니다(코딩 방식의 걸정을 통해 설계상의 제약을 
강화하는 이런 방법은 항목 18에서 다루었으니 참고하세요). 또한 제대로 만들어진 컴파일러는 정
수 타입의 const 객체에 대해 저장공간을 준비하지 않겠지만(그 객체에 대한 포인터나 참조자
를 만들지 않는 한) 조금 편찮게 만들어진 컴파일러는 반대로 동작할 수도 있어서, 소심한
프로그래머 측면에선 양쪽 모두에 대해 안전하게 const 객체에 대한 메모리를 만들지 않
는 방법을 쓰고 싶을 것입니다. enum은 #define처럼 어떤 형태의 쓸데없는 메모리 할당
도 절대 저지르지 않습니다.

나열자 둔갑술을 알아야 하는 두 번째 이유는 지극히 실용적인 이유인데, 상당히 많은 코드
에서 이 기법이 쓰이고 있으므로 혹시 이런 것을 발견하면 쉽게 알아보도록 눈을 단련시켜
두라는 것입니다. 사실, 이 나열자 둔갑술은 템플릿 메타프로그래밍의 핵심 기법이기도 합니
디(항목 48 참조).

살짝 다른 길로 갔죠? 다시 선행 처리자에 집중합시다. 상당히 많은 경우에서 발견할 수 있
는 #define 지시자의 또 다른 오용 사례는 매크로 함수입니다. 함수처럼 보이지만 함수 호
출 오버헤드를 일으키지 않는 메크로를 구현하는 것이지요. 일단 아래의 예를 보세요. 매
크로 인자들 중 큰 것을 사용해서 어떤 함수 f를 호출하는 매크로입니다.

// a와 b 중에 큰 것을 f에 넘겨 호출합니다.
#define CALL_WITH_MAX(a, b) f( (a)>(b)?(a):(b) )

이런 식의 매크로는 단점이 한두 개가 아닙니다. 그냥 생각만 해 보는 데도 미음이 아프죠.
다른 프로그래밍 책에서 익히 들어왔겠지만, 이런 매크로를 작성할 때는 매크로 본문에 들
어 있는 인자마다 반드시 괄호를 씌워 주는 센스를 잊지 말아야 합니다. 이게 안 되어 있으
면, 표현식을 매크로에 넘길 때 골치 아픈 일이 발생할 수 있으니까요. 그런데 이 부분을 제
대로 처리한다고 해서 끝난 것일까요? 괴현상을 아래에서 직접 만나보시기 비랍니다.

int a = 5, b = 0;

CALL_WITH_MAX(++a, b);		// a 가 두 번 증가합니다.
f( (++a)>(b)?(++a):(b) )

CALL_WITH_MAX(++a, b+10);	// a 가 한 번 증가합니다.
f( (++a)>(b+10)?(++a):(b+10) )

어떻습니까? f가 호출되기 전에 a가 증가하는 횟수가 달라지죠? 바로, 비교를 통해 처리한
결과가 어떤 것이냐에 따라 달라지니 끼무러칠 노릇이죠.

C++에서는 함수 호출을 없애 준다는 명목 하에 자행되는 이런 어처구니없는 작태를 참을
필요가 없습니다. 천만다행이죠. 기존 매크로의 효율을 그대로 유지 함은 물론 정규 함수의
모든 동작벙식 및 타입 안전성까지 완벽히 취할 수 있는 빙법이 있으니까요. 바로, 인라인
함수에 대한 템플릿(항목 30 참조)을 준비하는 것입니다.

template<typename T>							// T가 정확히 무엇인지
inline void callWithMax(const T& a, const T& b)	// 모르기 때문에, 매개변수로
{												// 상수 객체에 대한 참조를
	f(a>b?a:b);									// 씁니다. 항목 20 참조
}

이 함수는 템플릿이기 때문에 동일 계열 함수군(family of functions)1)을 만들어냅니다. 
동일한 타입의 객체 두 개를 인자로 받고 둘 중 큰 것을 f에 넘겨서 호출히는 구조입니다. 보시
면 알겠지만 함수 본문에 괄호로 분칠을 해 댈 필요가 없고, 인자를 여러번 평가할지도 모른
다는 걱정도 없어집니다. 그뿐 아니라 callWithMax는 진짜 함수이기 때문에 유효범위
및 접근 규칙을 그대로 따라갑니다. 임의의 클래스 안에서만 쓸 수 있는 인라인 함수에 대
한 이야기가 나오더라도 전혀 이상하지 않다는 이야기죠. 하지만 크로의 경우엔 이런 말
이 나오는 것 자체가 의미가 없습니다.

::1)비야네 스트롭스트롬의 저서인 "TC++ PL"에서 템플릿을 언급할 때 사용한 용어로,
하나의 템플릿을 통해 만들어질 것으로 예측 가능한 모든 함수를 통칭한다-옮긴이

const, enum, inline의 친절한 손길이 우리 가까이에 있다는 사실을 늘 유념해 두면,
선행 처리자(특히 #define)를 꼭 써야 하는 경우가 많이 줄어들게 됩니다. 그렇다고 현실적
으로 완전히 뿌리 뽑기는 힘듭니다. 예를 들어 #include는 부동의 필수 요소로 남아 있
고, #ifdef/#ifndef도 컴파일 조정 기능으로 현장에서 아주 잘 뛰고 있습니다. 선행 처
리자는 은퇴시기가 아직 꽤 님았다고 봅니다만, 기회가 될 때마다 장기 휴가를 자주 보내줌
으로써 마음의 준비를 해 두도록 합시다. 

이것만은 잊지 말자!
* 단순한 상수를 쓸 때는, #define보다 const 객체 혹은 enum을 우선 생각합시다.
* 함수처럼 씨이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각합시다.