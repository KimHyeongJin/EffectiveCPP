항목 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자

객체의 값을 초기화하는 데 있어서 C++의 행보가 갈팡질팡 하는 게 영 마음에 들지
않습니다. 예를 하나 들면, 다음과 같이이 했을 때

int x;

어떤 상황에서는 x의 값이 확실히 초기화되지만(0으로), 또 다른 상황에서는 그것이 보장되
지 않는다는 것입니다. 다른 예를 하나 더 보죠.

class Point 
{
	int x, y;
};

...
Point p;

이렇게 했을 때, p의 데이터 멤버 역시 어떤 상황에서는 초기화가 보장되지만 어쩔 때는 또
안 됩니다. 초기화되지 않은 객체를 용납하지 않는 언어를 이전에 사용하던 독자분이 이 부
분을 읽고 계시다면 밑줄 칠 필기구를 지금 꼭 챙기시기 바랍니다. 상당히 중요하니까요.

아시겠지만, 초기화되지 않은 값을 읽도록 내버려 두면 정의되지 않은 동작이 그대로 흘러
나오게 됩니다. 어떤 플랫폼의 경우에는 미초기화 객체를 읽기만 해도 프로그램이 서 버리
기도 합니다만, 대체적인 경우에는 적당히 무작위 비트의 값을 읽고 객체의 내부가 이상한
값을 갖게 됩니다. 결국엔 프로그램이 신비롭게 동작함은 물론이고 프로그래머는 무한 짜증
디버깅의 시간을 보내야 할 테고요.

C++의 객체(변수) 초기화가 중구난방인 것은 절대 아닙니다. 언제 초기화가 보장되며 언제
그렇지 않은지에 대한 규칙이 명확히 준비되어 있지요. 안타끼운 점은 규칙 자체가 아주 조
금 복잡하다는 것인데, 필자의 사견이지만 머리에 새겨둘 가치가 있기엔 너무 복잡합니다.
일단 일반적인 사항부터 정리해 보죠 C++의 C 부분(항목 1 참조)만을 쓰고 있으며 초기화
에 런타임 비용이 소모될 수 있는 상황이라면 이 초기화된다는 보장이 없습니다. 그렇지
만 C가 아닌 부분으로 발을 걸치게 되면 사정이 때때로 달라집니다. 배열(C++ 의 C 부분)은
각 원소가 확실히 초기화된다는 보장이 없으나 vector(C++ 의 STL 부분)는 그러한 보장을
갖게 되는 이유가 바로 이런 법칙 때문입니다.

사정이야 어쨌든 찜찜한 상태인 것은 어쩔 수 없지요. 가장 좋은 방법은 모든 객체를 사용
하기 전에 항상 초기화하는 것입니다. 기본 제공 타입으로 만들어진 비멤버 객체에 대해서는
초기화를 손수 해야 하겠습니다. 아래의 예를 보시죠.

int x = 0;		// int의 직접 초기화

const char * text = "A C-style string";	// 포인터의 직접 초기화(항목 3도 참조)

double d;		// 입력 스트림에서 읽음으로써
std::cin>>d;	// "초기화" 수행

이런 부분을 제외하고 나면, C++ 초기화의 나머지 부분은 생성자로 귀결됩니다. 생성자에
서 지킬 규칙은 지극히 간단합니다. 그 객체의 모든 것을 초기화하자! 이것만 지키면 만사 
오케이입니다.

참 지키기도 쉬운 규칙입니다만, 대입(assignment)을 초기화(initialization)와 햇갈리지 않는
것이 가장 중요하다는 데 따옴표를 달고 싶습니다. 주소록의 개인별 기재사항을 나타내는
클래스를 한 예로 들어 보죠. 이 클래스의 생성자는 다음과 같이 구현되어 있다고 가정합시다.

class PhoneNumber{...};

class ABEntry	// ABEntry = "Address Book Entry"
{
public:
	ABEntry(const std::string& name, 
	const std::string& address, 
	const std::list<PhoneNumber>& phones);
private:
	std::string theName;
	std::string theAddress;
	std::list<PhoneNumber> thePhones;
	int numTimesConsulted;
};

ABEntry::ABEntry(const std::string& name, 
				const std::string& address, 
				const std::list<PhoneNumber>& phones)
{
	theName = name;			// 지금은 모두 '대입'을 하고 있습니다.
	theAddress = address;	// '초기화'가 아닙니다.
	thePhones = phones;
	numTimesConsulted = 0;
}

이렇게 하면 ABEntry 객체는 여러분이 원했던 값을 가지고 일터로 나가게 되겠지만, 웬지
그리 개운한 방법은 아닙니다. C++ 규칙에 의하면 어떤 객체이든 그 객체의 데이터 멤버는
생성자의 본문이 실행되기 전에 초기화되어야 한다고 명기되어 있습니다. 현재의 ABEntry
생성자를 살짝 들여다보죠. theName, theAddress 및 thePhones는 여기서 초기화되
고 있는 것이 아니라, 어떤 값이 대입되고 있는 것입니다. 초기화는 진작 지나갔지요. 정확히
말하자면, ABEntry 생성자에 진입하기도 전에 이들 세 데이터 멤버의 기본 생성자가 호출
되었습니다. 잠깐, 그럼 numTimesConsulted도 미리 초기화되었을까요? 꼭 그런 것은
아닙니다. 기본제공 타입의 데이터 멤버이기 때문이죠. 기본제공 타입의 경우에는(생성자 안
에서) 대입되기 전에 초기화되리란 보장이 없습니다.

ABEntry 생성자를 좀더 멋있게 만들 수 있을까요? 물론입니다. 인상부터 지루하기 짝이
없는 대입문 대신에 멤버 초기화 리스트를 사용하면 됩니다.

ABEntry::ABEntry(const std::string& name, 
				const std::string& address, 
				const std::list<PhoneNumber>& phones)
				:theName(name), 
				theAddress(address),	// 이제 모두 초기화되고 있습니다. 
				thePhones(phones), 
				numTimesConsulted(0)
{}

::msdn https://docs.microsoft.com/ko-kr/cpp/cpp/constructors-cpp?view=vs-2019
위 링크의 내용을 보면 생성자 본문에서 값을 할당하는 것 보다 더 효율적으로 클래스 멤버를 
초기화 하는 방법이 맴버 초기화 리스트라고 말하고 있다.

데이터 멤버에 사용자가 원하는 값을 주고 시작한다는 점에서는 똑같지만, 방금 만든 생성
자는 앞의 것보다 더 효율적일 가능성이 큽니다. 대입만 사용한 버전의 경우 theName,
theAddress 및 thePhones에 대해 기본 생성자를 호출해서 초기화를 미리 해 놓은 후
에 생성자(대입을 사용한)에서 바로 새로운 값을 대입하고 있습니다. 따라서 먼저 호출된 
기본 생성자에서 해 놓은 초기화는 아깝게도 그냥 헛짓이 되고 말았습니다. 

이 문제는 멤버 초기화 리스트를 사용하면 피해 갈 수 있습니다.

초기화 리스트에 들어가는 인자는 바로 데이터 멤버에 대한 생성자의 인자로 쓰이기 때문입니다.
(데이터 멤버의 생성자에서 사용하는 인자로 쓰이기 때문...?)
지금의 경우, theName은 name으로부터 복사 생성자에 의해 초기화되고, 
theAddres는 address로부터 역시 복사 생성자에 의해 초기화되며, 
thePhones도 동일한 과정을 거쳐 phones로부터 초기화됩니다.

대부분의 데이터 타입에 대해서는, 기본 생성자 호출 후에 복사 대입 연산자를 연달아 
호출하는 이전의 방법보다 복사 생성자를 한 번 호출하는 쪽이 더 효율적입니다(????). 
어쩔 때는 훨씬 더 그렇고요.

각주 ????
윗 줄에서 말하는 대부분의 데이터 타입에 대해서....?
int num;// 기본 생성자 호출
int num2 = 100;
num = num2;// 복사 생성자 호출
이걸 말하는 것일까?

앞에서 말한 '대부분의 타입'에 포함되지 않는 타입이 numTimesConsulted와 같은 기본
제공 타입입니다. 기본제공 타입의 객체는 초기 화와 대입에 걸리는 비용의 차이가 없지만,
역시 멤버 초기화 리스트에 모두 넣어 주는 쪽이 가장 좋습니다. 또, 데이터 멤버를 기본 생
성자로 초기화하고 싶을 때도 멤버 초기화 리스트를 사용하는 습관을 들이세요. 생성자 인
자로 아무것도 주지 않으면 되니까 힘든 일도 아닐 것이고요. 예를 들어, 매개변수 없
는 생성자가 ABEntry 클래스에 들어 있었다면, 아마 아래처럼 구현할 수 있을 것입니다.

ABEntry::ABEntry()
:theName(),		// theName의 기본 ctor를 호출합니다. 
theAddress(),	// theAddress에 대해서도 그렇게 하고요.
thePhones(),	// thePhones에 대해서도 그렇게 하지만,
numTimesConsulted(0)// numTimesConsulted는 명시적으로 0으로 초기화 합니다.
{}