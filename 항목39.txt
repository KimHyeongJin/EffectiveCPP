항목 39: private 상속은 심사숙고해서 구사하자.

C++는 public 상속을 is-a 관계로 나타냅니다. 이 점은 항목 32에서 함께 공부한 바 
있지요. Student가 Person으로부터 public 상속으로 파생된 상태의 클래스 계통이 주어졌
을 때, 함수 호출을 성공시키기 위해 컴파일러가 Student를 Person으로 암시적 변환을
수행하는 예제를 통해 is-a 관계를 잘 설명했던 것 같아요. 이 예제를 이번 항목에 다시 써먹
어 보도록 하겠습니다. 대신, 상속 방식만 public 상속 말고 private 상속으로 살짝 바
꾸겠습니다.

class Person {...};

class Student:private Person{...};// 이젠 private 상속입니다.

void eat(const Person& p);// 누구라도 사람은 먹을 수 있다.

void study(const Student& s);// 공부는 학생만 할 수 있습니다.

Person p;	// p는 Person의 일종이다.
Student s;	// s는 Student의 일종이다.
eat(p);	// 사람은 먹을 수 있죠.
eat(s); // 에러! Student는 Person의 일종이 아닙니다.

private 상속은 분명히 is-a를 뜻하지 않습니다. 그렇다면 다른 뜻이 있긴 할 텐데, 뭘까요?

"잠깐만요!" 저쪽에서 손 번쩍 드는 분이 보이는군요. "뜻보다 우선 어떻게 동작하는지부터
알려 주세요. private 상속을 쓰면 뭐가 어떻게 되는 거예요?" 음, 글쎄요. private 상
속을 지배하는 첫 번째 동작 규칙은 방금 여러분이 위의 예제에서 보신 그대로입니다.
public 상속과 대조적으로, 클래스 사이의 상속 관계가 private이면 컴파일러는 일반적
으로 파생 클래스 객체(이를테면 Student)를 기본 클래스 객체(그러니까 Person)로 변환하
지 않습니다. eat 함수 호출이 s에 대해서 실패했던 이유가 궁금하셨던 분은 이제 의문이
풀렸을 것입니다. 다음, 두 번째 동작 규칙은 기본 클래스로부터 물려받은 멤버는 파생 클래
스에서 모조리 private 멤버가 된다는 것입니다. 기본 클래스에서 원래 protected 
멤버였거나 public 멤버였어도 말이죠.

요약 하자면...
첫 번째 동작 규칙:파생 클래스 객체를 기본 클래스 객체로 변환하지 않습니다.
두 번째 동작 규칙:기본 클래스로부터 물려받은 멤버는 파생 클래스에서 모조리 
private 멤버가 된다는 것입니다.

멍석을 꽤 오래 깔았습니다. 이제는 의미에 대해 말씀드릴 수 있겠죠? private 상속의 
의미는 is-implemented-in-terms-of입니다. B 클래스로부터 private 상속을 통해 
D 클래스를 파생시킨 것은, B 클래스에서 쓸 수 있는 기능들 몇 개를 활용할 목적으로 
한 행동이지, B 타입과 D 타입의 객체 사이에 어떤 개념적 관계가 있어서 한 행동이 아니라는 
것입니다. 단도직입적으로 말해서, private 상속은 그 자체로 구현 기법 중 하나입니다(기본 
클래스로부터 물려받은 것들이 전부 파생 클래스에서 private 멤버가 되는 이유도 이것으로 
설명이 됩니다. 기본 클래스는 그저 구현 세부사항일 뿐이란 거죠). 항목 34에서 소개한 용어를 
가지고 이야기하면, private 상속의 의미는 '구현만 물려받을 수 있다. 인터페이스는 국물도 
없다'라는 뜻입니다.D가 B로부터 private 상속을 받으면, 이것은 그냥 D 객체가 B 객체를 
써서 구현되는 거라고 생각하세요. 더 바랄 것도 없습니다. private 상속은 소프트워어 설계
(design) 도중에는 아무런 의미도 갖지 않으며, 단지 소프트웨어 구현(implementation) 
중에만 의미를 가질 뿐입니다.

그런데 private 상속의 의미가 is-implemented-in-terms-of라는 사실은 다소 
헷갈리는 부분이 있기도 합니다. 항목 38에서 분명 객체 합성도 똑같은 뜻을 갖는다고 
했거든요. 그렇다면 이 둘(private 상속, 객체 합성) 중에 어떻게 골라야 못 골랐다는 
댓글이 안 달릴까요? 답은 지극히 간단합니다. 할 수 있으면 객체 합성을 사용하고, 꼭 
해야 하면 private 상속을 사용하십시오. 대체 언제가 '꼭 해야 하는' 때일까요? 비공개 
멤버를 접근할 때 혹은 가상 함수를 재정의 할 경우가 주로 이 그림에 속합니다. 비록 공간
문제가 얽히면서 완전히 private 상속으로 기울 수밖에 없는 '만약의 경우'도 있긴
하지만요. 이 만약의 경우에 대해서는 조금 뒤에 함께 고민해 봅시다. 뭐, 어쨌든 '만약'
의 경우이니 말입니다.

Widget 객체를 사용하는 응용프로그램을 하나 만들고 있다고 가정합시다. 무슨 바람이
불었는지는 몰라도, 어떻게 Widget 객체가 사용되는지를 좀더 이해햐아 할 필요가 있다는
생각이 들었습니다. 다시 말해, Widget의 멤버 함수의 호출 횟수 같은 것들도 알고 싶고
실행 시간이 지남에 따라 호출 비율이 어떻게 변하는지도 알고 싶다 이거죠. 실행 단계가
딱딱 구분되는 프로그램은 각 단계에 따라 보여주는 프로파일(profile)11) 양상도 다를 
수 있습니다. 이를테면, 컴파일러가 소스 코드를 파싱하는 단계에서 상요된 함수들은 최적
화 및 코드 생성 단계가 진행되는 동안에 사용된 함수들과 상당 부분 다른 것도 한 가지
예입니다.

11)	프로파일(profile): 프로그램이 실행되면서 호출되는 함수들의 순차적 리스트 및 
각 함수의 실행 시간과 전체 시간에대한 실행 시간 비율을 분석하는 작업 혹은 그 분석
결과. 프로파일러는 개발환경에 따라 다르다. VC++6에서는 링커 옵션에 /profile을 주어
활성화 할 수 있고, VC++7/7.1 이상에서는 별도의 프로그램 성능 분석도구(IBM Purify,
Compuware DevPartner Studio 등)가 필요하며, 유닉스 및 mingw 등의 개발환경에서는 
오픈소스 도구인 gprof을 사용할 수 있다. 프로세서에 특화된 분석도구로는 인텔의 VTune,
AMD의 Code Analyst 등이 있다.-옮긴이

그런 전차로, 각 멤버 함수가 몇 번이나 호출되는지를 추적하기 위해 Widget 클래스를
직접 손보기로 합니다. 멤버 함수의 호출 횟수 정보는 프로그램이 실행되는 도중에 
주기적으로 점검하도록 만들 텐데, 필요하다면 이 정보 외에 각 Widget 객체의 값과
더불어 우리 생각에 유용하다고 여겨지는 다른 자료들도 넣을 수 있을 것입니다.
이 작업을 위해 일종의 타이머를 하나 설치해 놓습니다. 함수 사용 통계를 수집할 때를
알려주는 용도로 이 타이머를 쓰자는 거죠.

코드를 새로 만드니 기존의 코드를 가져와 쓰는 게 더 좋으므로, 예전에 만들어 두었던
유틸리티 툴킷을 한번 뒤져 봅니다. 기쁘게도 이런 클래스가 있었습니다.

class Timer
{
public:
	explict Timer(int tickFrequency);
	virtual void onTick() const;	// 이렁 시간이 경과할 때마다 자동으로
	...								// 이것이 호출됩니다.
};

딱 우리가 찾고 있던 것이었습니다. Timer 객체는 반복적으로 시간을 경과시킬 주기를
우리가 정해 줄 수 있고, 일정 시간이 경과할 때마다 가상 함수를 호출하도록 되어
있습니다. 이 가상 함수를 재정해서, Widget 객체의 현재 상태를 점검하면 되는 거죠.
오 예, 제가 만들었지만 진짜 완벽하지 않습니까?

이렇게 하려면 Widget 클래스에서 Timer의 가상 함수를 재정의할 수 있어야 하므로,
Widget 클래스는 어쨌든 Timer에서 상속을 받아야 합니다. 하지만 지금 상황에서
public 상속은 맞지 않습니다. Widget이 Timer의 일종(is-a)은 아니니까요.
게다가, Widget 객체의 사용자는 Widget 객체를 통해 onTick 함수를 호출해선 안
됩니다. 이 함수는 개념적으로 Widget 인터페이스의 일부로 볼 수 없기 때문입니다.
onTick 함수의 호출을 내버려 두는 것은 결국 Widget 인터페이스를 잘못 사용하기가
쉬워지게 만드는 것과 같습니다. "제대로 사용하기에는 쉽게, 잘 못 사용하기에는 어렵게
만들라"는 항목 18의 조언을 분명히 어기는 행동이죠. public 상속은 처음부터 틀린
선택입니다.

그르므로 private 상속을 하는 것입니다.

class Widget: private Timer
{
private:
	virtual void onTick() const;	// Widget 사용 자료 등을 수집합니다.
	...
};

상속 방식을 private로 한 덕택에, Timer의 public 멤버인 onTick 함수는 Widget
에서 private 멤버가 되었습니다.