항목 39: private 상속은 심사숙고해서 구사하자.

C++는 public 상속을 is-a 관계로 나타냅니다. 이 점은 항목 32에서 함께 공부한 바 
있지요. Student가 Person으로부터 public 상속으로 파생된 상태의 클래스 계통이 주어졌
을 때, 함수 호출을 성공시키기 위해 컴파일러가 Student를 Person으로 암시적 변환을
수행하는 예제를 통해 is-a 관계를 잘 설명했던 것 같아요. 이 예제를 이번 항목에 다시 써먹
어 보도록 하겠습니다. 대신, 상속 방식만 public 상속 말고 private 상속으로 살짝 바
꾸겠습니다.

class Person {...};

class Student:private Person{...};// 이젠 private 상속입니다.

void eat(const Person& p);// 누구라도 사람은 먹을 수 있다.

void study(const Student& s);// 공부는 학생만 할 수 있습니다.

Person p;	// p는 Person의 일종이다.
Student s;	// s는 Student의 일종이다.
eat(p);	// 사람은 먹을 수 있죠.
eat(s); // 에러! Student는 Person의 일종이 아닙니다.

private 상속은 분명히 is-a를 뜻하지 않습니다. 그렇다면 다른 뜻이 있긴 할 텐데, 뭘까요?

"잠깐만요!" 저쪽에서 손 번쩍 드는 분이 보이는군요. "뜻보다 우선 어떻게 동작하는지부터
알려 주세요. private 상속을 쓰면 뭐가 어떻게 되는 거예요?" 음, 글쎄요. private 상
속을 지배하는 첫 번째 동작 규칙은 방금 여러분이 위의 예제에서 보신 그대로입니다.
public 상속과 대조적으로, 클래스 사이의 상속 관계가 private이면 컴파일러는 일반적
으로 파생 클래스 객체(이를테면 Student)를 기본 클래스 객체(그러니까 Person)로 변환하
지 않습니다. eat 함수 호출이 s에 대해서 실패했던 이유가 궁금하셨던 분은 이제 의문이
풀렸을 것입니다. 다음, 두 번째 동작 규칙은 기본 클래스로부터 물려받은 멤버는 파생 클래
스에서 모조리 private 멤버가 된다는 것입니다. 기본 클래스에서 원래 protected 
멤버였거나 public 멤버였어도 말이죠.

*	클래스 사이의 상속 관계가 private이면 컴파일러는 일반적으로 파생 클래스 
	객체(이를테면 Student)를 기본 클래스 객체(그러니까 Person)로 변환하지 않습니다.

요약 하자면...
첫 번째 동작 규칙:파생 클래스 객체를 기본 클래스 객체로 변환하지 않습니다.
두 번째 동작 규칙:기본 클래스로부터 물려받은 멤버는 파생 클래스에서 모조리 
private 멤버가 된다는 것입니다.

멍석을 꽤 오래 깔았습니다. 이제는 의미에 대해 말씀드릴 수 있겠죠? private 상속의 
의미는 is-implemented-in-terms-of입니다. B 클래스로부터 private 상속을 통해 
D 클래스를 파생시킨 것은, B 클래스에서 쓸 수 있는 기능들 몇 개를 활용할 목적으로 
한 행동이지, B 타입과 D 타입의 객체 사이에 어떤 개념적 관계가 있어서 한 행동이 아니라는 
것입니다. 단도직입적으로 말해서, private 상속은 그 자체로 구현 기법 중 하나입니다(기본 
클래스로부터 물려받은 것들이 전부 파생 클래스에서 private 멤버가 되는 이유도 이것으로 
설명이 됩니다. 기본 클래스는 그저 구현 세부사항일 뿐이란 거죠). 항목 34에서 소개한 용어를 
가지고 이야기하면, private 상속의 의미는 '구현만 물려받을 수 있다. 인터페이스는 국물도 
없다'라는 뜻입니다.D가 B로부터 private 상속을 받으면, 이것은 그냥 D 객체가 B 객체를 
써서 구현되는 거라고 생각하세요. 더 바랄 것도 없습니다. private 상속은 소프트워어 설계
(design) 도중에는 아무런 의미도 갖지 않으며, 단지 소프트웨어 구현(implementation) 
중에만 의미를 가질 뿐입니다.

그런데 private 상속의 의미가 is-implemented-in-terms-of라는 사실은 다소 
헷갈리는 부분이 있기도 합니다. 항목 38에서 분명 객체 합성도 똑같은 뜻을 갖는다고 
했거든요. 그렇다면 이 둘(private 상속, 객체 합성) 중에 어떻게 골라야 못 골랐다는 
댓글이 안 달릴까요? 답은 지극히 간단합니다. 할 수 있으면 객체 합성을 사용하고, 꼭 
해야 하면 private 상속을 사용하십시오. 대체 언제가 '꼭 해야 하는' 때일까요? 비공개 
멤버를 접근할 때 혹은 가상 함수를 재정의 할 경우가 주로 이 그림에 속합니다. 비록 공간
문제가 얽히면서 완전히 private 상속으로 기울 수밖에 없는 '만약의 경우'도 있긴
하지만요. 이 만약의 경우에 대해서는 조금 뒤에 함께 고민해 봅시다. 뭐, 어쨌든 '만약'
의 경우이니 말입니다.

Widget 객체를 사용하는 응용프로그램을 하나 만들고 있다고 가정합시다. 무슨 바람이
불었는지는 몰라도, 어떻게 Widget 객체가 사용되는지를 좀더 이해햐아 할 필요가 있다는
생각이 들었습니다. 다시 말해, Widget의 멤버 함수의 호출 횟수 같은 것들도 알고 싶고
실행 시간이 지남에 따라 호출 비율이 어떻게 변하는지도 알고 싶다 이거죠. 실행 단계가
딱딱 구분되는 프로그램은 각 단계에 따라 보여주는 프로파일(profile)11) 양상도 다를 
수 있습니다. 이를테면, 컴파일러가 소스 코드를 파싱하는 단계에서 상요된 함수들은 최적
화 및 코드 생성 단계가 진행되는 동안에 사용된 함수들과 상당 부분 다른 것도 한 가지
예입니다.

11)	프로파일(profile): 프로그램이 실행되면서 호출되는 함수들의 순차적 리스트 및 
각 함수의 실행 시간과 전체 시간에대한 실행 시간 비율을 분석하는 작업 혹은 그 분석
결과. 프로파일러는 개발환경에 따라 다르다. VC++6에서는 링커 옵션에 /profile을 주어
활성화 할 수 있고, VC++7/7.1 이상에서는 별도의 프로그램 성능 분석도구(IBM Purify,
Compuware DevPartner Studio 등)가 필요하며, 유닉스 및 mingw 등의 개발환경에서는 
오픈소스 도구인 gprof을 사용할 수 있다. 프로세서에 특화된 분석도구로는 인텔의 VTune,
AMD의 Code Analyst 등이 있다.-옮긴이

그런 전차로, 각 멤버 함수가 몇 번이나 호출되는지를 추적하기 위해 Widget 클래스를
직접 손보기로 합니다. 멤버 함수의 호출 횟수 정보는 프로그램이 실행되는 도중에 
주기적으로 점검하도록 만들 텐데, 필요하다면 이 정보 외에 각 Widget 객체의 값과
더불어 우리 생각에 유용하다고 여겨지는 다른 자료들도 넣을 수 있을 것입니다.
이 작업을 위해 일종의 타이머를 하나 설치해 놓습니다. 함수 사용 통계를 수집할 때를
알려주는 용도로 이 타이머를 쓰자는 거죠.

코드를 새로 만드니 기존의 코드를 가져와 쓰는 게 더 좋으므로, 예전에 만들어 두었던
유틸리티 툴킷을 한번 뒤져 봅니다. 기쁘게도 이런 클래스가 있었습니다.

class Timer
{
public:
	explict Timer(int tickFrequency);
	virtual void onTick() const;	// 이렁 시간이 경과할 때마다 자동으로
	...								// 이것이 호출됩니다.
};

딱 우리가 찾고 있던 것이었습니다. Timer 객체는 반복적으로 시간을 경과시킬 주기를
우리가 정해 줄 수 있고, 일정 시간이 경과할 때마다 가상 함수를 호출하도록 되어
있습니다. 이 가상 함수를 재정해서, Widget 객체의 현재 상태를 점검하면 되는 거죠.
오 예, 제가 만들었지만 진짜 완벽하지 않습니까?

이렇게 하려면 Widget 클래스에서 Timer의 가상 함수를 재정의할 수 있어야 하므로,
Widget 클래스는 어쨌든 Timer에서 상속을 받아야 합니다. 하지만 지금 상황에서
public 상속은 맞지 않습니다. Widget이 Timer의 일종(is-a)은 아니니까요.
게다가, Widget 객체의 사용자는 Widget 객체를 통해 onTick 함수를 호출해선 안
됩니다. 이 함수는 개념적으로 Widget 인터페이스의 일부로 볼 수 없기 때문입니다.
onTick 함수의 호출을 내버려 두는 것은 결국 Widget 인터페이스를 잘못 사용하기가
쉬워지게 만드는 것과 같습니다. "제대로 사용하기에는 쉽게, 잘 못 사용하기에는 어렵게
만들라"는 항목 18의 조언을 분명히 어기는 행동이죠. public 상속은 처음부터 틀린
선택입니다.

그르므로 private 상속을 하는 것입니다.

class Widget: private Timer
{
private:
	virtual void onTick() const;	// Widget 사용 자료 등을 수집합니다.
	...
};

상속 방식을 private로 한 덕택에, Timer의 public 멤버인 onTick 함수는 Widget
에서 private 멤버가 되었습니다. 이 함수를 우리가 직접 다시 선언한다고 해도 private
멤베인 사실은 변함없지요. 하지만 이 onTick 함수를 public 인터페이스로 빼놓는 순간
사용자는 분명히 '이 함수는 호출할 수 있구나'라고 오해할 것이고, 바로 항목 18을
위반하는 것이 되겠지요.

이것만 놓고 보면 흠잡힐 게 없는 설계입니다. 하지만 지금 꼭 private 상속을 할 필요가
있느냐는 점은 조금 생각해 볼 만합니다. 대신에 객체 합성을 쓰기로 마음먹었다면 충분히
그렇게 해도 되는 상황이거든요. Timer로부터 public 상속을 받은 클래스를 Widget
안에 private 중첩 클래스로 선언해 놓고, 이 클래스에서 onTick을 재정의한 다음, 이
타입(클래스)의 객체 하나를 Widget 안에 데이터 멤버로서 넣는 것입니다. 방금 한 이야기
를 코드와 그림으로 옮겨보면 다음과 같습니다.

class Widget
{
private:
	class WidgetTimer: public Timer
	{
	public:
		virtual void onTick() const;
		...
	};
	WidgetTimer timer;
	...
};

그림은 생략

private 상속만 써서 만든 설계와 비교하면 상당히 복잡한 구조입니다. 
(public) 상속에다가 객체 합성이 들어가 있고, 게다가 클래스를 새로 만들기까
지(WidgetTimer) 했으니까요. 솔직히 말씀드리면, 필자가 이런 예제를 보여준 데는
'하나의 설계 문제에 대한 접근 방법이 꼭 하나만 있는 것은 아니다'라는 사실과
'여러 가지 방법을 실제로 고민하는 습관을 들이는 것이 좋다'라는 주장을 여러분께
상기시키고 싶었던 이유가 있었습니다(항목 35에도 이런 이야기가 있죠). 뭐 원래의
의도야 그랬지만, 현실적으로는 private 상속 대신에 public 상속에 객체 합성 
조합이 더 자주 즐겨 쓰이긴 합니다. 다음과 같은 두 가지 좋은 점 때문입니다.

첫째, Widget 클래스를 설계하는 데 있어서 파생은 가능하게 하되, 파생 클래스에서
onTick을 재정의할 수 없도록 설계 차원에서 막고 싶을 때 유용합니다. 만약
Widget을 Timer로부터 상속시킨 구조라면 이런 게 안 됩니다. 심지어 상속을
private로 해도 안됩니다(항목 35의 내용을 생각해 보세요. 파생 클래스는 자신이
물려받은 가상 함수를 호출할 권한이 없더라도 가상 함수를 재정의할 수는 있습니다).
하지만 위처럼 Timer로부터 상속을 받은 WidgetTimer가 Widget 클래스의 private
영역에 있으면, Widget의 파생 클래스는 아무리 용을 써도 WidgetTimer에 접근할
수 없습니다. 때문에 무슨 상속을 받거나 가상 함수를 재정의 하거나 할 수 없는 거죠.
혹시 독자 여러분 중에 자바 혹은 C# 언어를 하다가 C++로 옮겨오면서 파생 클래스에
가상 함수를 제정의할 수 없게 막는 기능(자바의 final 메서드 및 C#의 sealed 
메서드 같은)이 없어서 우울해 하셨던 분이 있다면, C++를 써서 이와 근접하게 
구현할 수 있는 괜찮은 아이디어 하나를 여기서 얻으신 겁니다.

둘째, Widget의 컴파일 의존성을 최소화하고 싶을 때 좋습니다. Widget이 Timer에서
파생된 상태라면, Widget이 컴파일될 때 Timer의 정의도 끌어올 수 있어야 하기
때문에, Widget의 정의부 파일에서 Timer.h 같은 헤더를 #include 해야 할지도
모릅니다. 반면, 지금의 설계에서는 WidgetTimer의 정의를 Widget으로부터 빼내고
Widget이  WidgetTimer 객체에 대한 포인터만 갖도록 만들어 두면, WidgetTimer
클래스를 간단히 선언하는 것만으로도 컴파일 의존성을 슬쩍 피할 수 있습니다.
Timer에 관련된 어떤 것도 #include할 필요가 없으니까요. 규모가 큰 시스템을
만들 때 이런 구성요소 분리는 굉장히 중요해질 수 있는 요소랍니다(컴파일 의존성을
최소화하는 문제를 좀 자세히 들여다봐야 하겠다고 생각하시는 분은 항목 31을 참고
하십시오).

private 상속을 해야 할 경우에 관해서 앞에서 한 마디 늘어놓은 것, 혹시 기억
나실지 모르겠습니다. 기본 클래스의 비공개 부분에 파생 클래스가 접근해야 한다
거나 가상 함수를 한 개 이상 재정의해야 할 경우가 주된 용도라고 말씀드렸었죠.
이때 클래스 사이의 개념적인 관계는 is-a가 아니라 is-implmented-in-terms
-of라는 말씀도요. 하지만 객체 합성보다 private 상속을 선호할 수밖에 없는
소위 공간 최적화가 얽힌 '만약의 경우'도 있다는 말도 덧붙였었죠. 이제는 말할
수 있습니다.

이 만약의 경우는 정말 '만에 하나'입니다. 데이터가 전혀 없는 클래스를 사용할
때가 아니면 볼 수도 없습니다. 데이터가 없는 클래스란 비정적 데이터 멤버가 
없는 클래스를 일겉습니다. 그러니까 가상 함수도 하나도 없어야 하고(가상 함수가
한 개라도 있으면 각 객체마다 vptr이 하나씩 추가되니까요. 항목 7 참조), 가상
기본 클래스도 없어야 합니다(가상 기본 클래스도 크기 오버헤드를 일으키는 요인
이기 때문입니다. 항목 40 참조). 이런 공백 클래스(empty class)는 개념적으로
차지하는 메모리 공간이 없는 게 맞습니다. 객체별로 저장할 데이터가 없으니
당연하죠. 하지만 이런저런 기술적인 우여곡절 때문에 C++에는 "독립구조(free-
standing)의 객체는 반드시 크기가 0을 넘어야 한다"라는 요상한 금기사항 같은
것이 정해져 내려오고 있어서, 다음과 같은 코드를 써 보면

class Empty{};	// 정의된 데이터가 없으므로, 객체는 메모리를 사용하지
				// 말아야 합니다.
class HoldsAnInt	// int를 저장할 공간만 필요해야 합니다.
{
private:
	int x;
	Empty e;	// 메모리 요구가 없어야 합니다.
};

sizeof(HoldsAnInt) > sizeof(int)가 되는 괴현상을 목도하게 됩니다.
Empyt 타입의 데이터 멤버가 메모리를 요구하는 거죠. 대부분의 컴파일러에서
sizeof(Empty)의 값은 1로 나옵니다. 크기가 0인 독립구조의 객체가 생기는
것을 금지하는 C++의 제약을 지키기 위해, 컴파일러는 이런 "공백" 객체에 char
한 개를 슬그머니 끼워넣는 식으로 처리하기 때문입니다. 하지만 바이트 정렬
(alignment)(항목 50 참조)이 필요하다고 판단되면 컴파일러는 HoldsAnInt 
등의 클래스에 바이트 패딩(padding) 과정을 추가할 수도 있어서, HoldsAnInt
객체의 크기는 char 하나의 크기를 넘게 됩니다. 실제로 두 번째(코드에선 첫째로 
보이지만) int를 담을 수 있는 만큼으로 늘어나죠(필자가 테스트해 본 모든 컴파일
러에서 일관되게 일어난 현상이었습니다).

그런데 눈치가 빠른 독자라면, 필자가 객체 크기가 0이면 안 된다고 말하면서 
'독립구조'라는 말을 신경 써서 했던게 수상쩍었을 겁니다. 맞습니다.
C++의 제약은 파생 클래스 객체의 기본 클래스 부분에는 적용되지 않습니다. 이때의
기본 클래스 부분은 독립구조 객체, 다시 말해 홀로서기를 한 객체가 아니기 때문입니다.
Empty 타입의 객체를 데이터 멤버로 두지 말고 Empty로부터 상속을 시켜 보면,

class HoldsAnInt: private Empty
{
private:
	int x;
};

sizeof(HoldsAnInt) == sizeof(int)를 확인할 수 있습니다. 이 공간 절약 
기법은 공백 기본 클래스 최적화(Empty Base Opimization:EBO)라고 알려져 있으며,
필자가 테스트한 모든 컴파일러에서 구현하고 있답니다. 메모리 공간에 많이 신경쓰는
사용자를 상대하는 라이브러리 개발자라면 EBO를 알아두는 게 좋을 것입니다. 이와
더불어 알아두면 쓸 만한 사실이 하나 더 있는데, EBO는 일반적으로 단일 상속에서만
적용된다는 점입니다. C++ 객체의 레이아웃을 결정하는 규칙이 일반적으로 이러저러한
관계로, 기본 클래스를 두 개 이상 갖는 파생 클래스에는 EBO가 적용될 수 없다고
하네요.

실무적인 입장에서 이야기하면, "공백" 클래스는 진짜로 텅 빈 것은 아닙니다.
비정적 데이터 멤버는 안 갖고 있지만, typedef 혹은 enum, 정적 데이터 멤버는
물론이고 비가상 함수까지 갖는 경우가 비일비재합니다. STL에는 방금 말한 성격의
멤버(대부분 typedef타입)를 포함하고 있는, 기술적으로 공백 처리된 클래스가 많이
있습니다. unary_function과 binary_function이 그 예인데, 이들은 사용자 정
의 함수 객체를 만들때 상속시킬 기본 클래스로 굉장히 자주 사용되는 클래스입니다.
요즘은 EBO의 구현 보편화된 덕택에, 이런 상속은 아무리 자주 되더라도 파생 클래
스의 크기를 증가시키는 일이 거의 없습니다.

하지만 이젠 다시 '만약'이 아닌 일상으로 돌아올 때입니다. 솔직히 말해 아무것도
없는 클래스를 사용하는 경우는 정말 드물죠. 그렇기 때문에 EBO 하나만 갖고 
private 상속이 뭔가 합법적으로 정당화된 것은 무리에 가깝습니다. 게다가 대부분
의 상속은 is-a 관계를 나타내고, 이 부분은 public 상속이다 맡고 있습니다. 
private 상속이 설 땅은 없다는 거죠. is-implemented-in-terms-of 관계는 
객체 합성과 private 상속이 둘 다 나타낼 수 있지만, 이해하기에는 객체 합성이 
훨씬 낫죠. 그래서 할 수 있으면 객체 합성을 사용해야 한다고 말씀드린 것입니다.

private 상속이 적법한 설계 전략일 가능성이 가장 높은 경우가 있습니다. 아무리
봐 주어도 is-a 관계로 이어질 것 같지 않은 두 클래스를 사용해야 하는데, 이 둘
사이에서 한쪽 클래스가 다른 쪽 클래스의 protected 멤버에 접근해야 하거나 다른
쪽 클래스의 가상 함수를 재정의해야 할 때가 바로 이 경우입니다. 그렇다고 private
상속 아니면 안 되는 것도 아닙니다. 여러분도 보셨듯이 public 상속과 객체 합성을
적절히 잘 섞으면, 설계 복잡도는 좀더 올라가겠지만 원하는 동작을 얻을 수 있거든요.
"private 상속을 심사숙고해서 구사하자"라는 말의 의미는, 섣불리 이것을 쓸 필요가
없다는 생각을 갖고 모든 대안을 고민한 후에, 주어진 두 클래스 사이의 관계를 나타낼
가장 좋은 방법이 private 상속이라는 결론이 나면 쓰라는 뜻입니다.

이것만은 잊지 말자!
*	private 상속의 의미는 is-implemented-in-terms-of(...는 ...를 써서
	구현됨)입니다. 대개 객체 합성과 비교해서 쓰이는 분야가 많지는 않지만, 파생
	클래스 쪽에서 기본 클래스의 protected 멤버에 접근해야 할 경우 혹은 상속받
	은 가상 함수를 재정의해야 할 경우에는 private 상속이 나름대로 의미가 있습니다.

*	객체 합성과 달리 private 상속은 공백 기본 클래스 최적화(EBO)를 활성화시킬
	수 있습니다. 이 점은 객체 크기를 가지고 고민하는 라이브러리 개발자에게 꽤
	매력적인 특징이 되기도 합니다.