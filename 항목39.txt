항목 39: private 상속은 심사숙고해서 구사하자.

C++는 public 상속을 is-a 관계로 나타냅니다. 이 점은 항목 32에서 함께 공부한 바 
있지요. Student가 Person으로부터 public 상속으로 파생된 상태의 클래스 계통이 주어졌
을 때, 함수 호출을 성공시키기 위해 컴파일러가 Student를 Person으로 암시적 변환을
수행하는 예제를 통해 is-a 관계를 잘 설명했던 것 같아요. 이 예제를 이번 항목에 다시 써먹
어 보도록 하겠습니다. 대신, 상속 방식만 public 상속 말고 private 상속으로 살짝 바
꾸겠습니다.

class Person {...};

class Student:private Person{...};// 이젠 private 상속입니다.

void eat(const Person& p);// 누구라도 사람은 먹을 수 있다.

void study(const Student& s);// 공부는 학생만 할 수 있습니다.

Person p;	// p는 Person의 일종이다.
Student s;	// s는 Student의 일종이다.
eat(p);	// 사람은 먹을 수 있죠.
eat(s); // 에러! Student는 Person의 일종이 아닙니다.

private 상속은 분명히 is-a를 뜻하지 않습니다. 그렇다면 다른 뜻이 있긴 할 텐데, 뭘까요?

"잠깐만요!" 저쪽에서 손 번쩍 드는 분이 보이는군요. "뜻보다 우선 어떻게 동작하는지부터
알려 주세요. private 상속을 쓰면 뭐가 어떻게 되는 거예요?" 음, 글쎄요. private 상
속을 지배하는 첫 번째 동작 규칙은 방금 여러분이 위의 예제에서 보신 그대로입니다.
public 상속과 대조적으로, 클래스 사이의 상속 관계가 private이면 컴파일러는 일반적
으로 파생 클래스 객체(이를테면 Student)를 기본 클래스 객체(그러니까 Person)로 변환하
지 않습니다. eat 함수 호출이 s에 대해서 실패했던 이유가 궁금하셨던 분은 이제 의문이
풀렸을 것입니다. 다음, 두 번째 동작 규칙은 기본 클래스로부터 물려받은 멤버는 파생 클래
스에서 모조리 private 멤버가 된다는 것입니다. 기본 클래스에서 원래 protected 
멤버였거나 public 멤버였어도 말이죠.

요약 하자면...
첫 번째 동작 규칙:파생 클래스 객체를 기본 클래스 객체로 변환하지 않습니다.
두 번째 동작 규칙:기본 클래스로부터 물려받은 멤버는 파생 클래스에서 모조리 
private 멤버가 된다는 것입니다.

멍석을 꽤 오래 깔았습니다. 이제는 의미에 대해 말씀드릴 수 있겠죠? private 상속의 
의미는 is-implemented-in-terms-of입니다. B 클래스로부터 private 상속을 통해 
D 클래스를 파생시킨 것은, B 클래스에서 쓸 수 있는 기능들 몇 개를 활용할 목적으로 
한 행동이지, B 타입과 D 타입의 객체 사이에 어떤 개념적 관계가 있어서 한 행동이 아니라는 
것입니다. 단도직입적으로 말해서, private 상속은 그 자체로 구현 기법 중 하나입니다(기본 
클래스로부터 물려받은 것들이 전부 파생 클래스에서 private 멤버가 되는 이유도 이것으로 
설명이 됩니다. 기본 클래스는 그저 구현 세부사항일 뿐이란 거죠). 항목 34에서 소개한 용어를 
가지고 이야기하면, private 상속의 의미는 '구현만 물려받을 수 있다. 인터페이스는 국물도 
없다'라는 뜻입니다.D가 B로부터 private 상속을 받으면, 이것은 그냥 D 객체가 B 객체를 
써서 구현되는 거라고 생각하세요. 더 바랄 것도 없습니다. private 상속은 소프트워어 설계
(design) 도중에는 아무런 의미도 갖지 않으며, 단지 소프트웨어 구현(implementation) 중에
만 의미를 가질 뿐입니다. 