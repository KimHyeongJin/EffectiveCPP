항목 33: 상속된 이름을 숨기는 인은 피하자

이름(name)에 대해서 셰익스피어(Shakespeare)가 한 말이 있습니다. "이름이 대체 무엇인가
요?"4) 이렇게 묻고 이렇게 말했습니다. "우리가 장미를 다른 이름으로 부른대도 여전히 장
미 향기가 날 텐데." 5) 또 이 음유시인은 이렇게도 말했습니다. "이름을 훔쳐가는 자는 ... 빼
앗긴 사람만 빈털터리로 만들고 마는 것입니다"6)라고요. 맞는 이야기 같죠? 이걸 보니 C++ 

4)	셰익스피어의 희곡 로미오와 줄리엣(Romeo and Juliet)에서 가장 유명한 발코니 장면인 
	2막 1장에 나오는 줄리엣의 대사 중 하나이다. "EC++" 원서에는 "What’s in a name?"
	이라고 쓰여 있으며 희곡 원문도 같다 - 옮긴이
5)	바로 앞의 각주에 나온 줄리엣의 대사가 계속 이어지는 것이다. "EC++" 원서에는 
	"A rose by any other name would smell as sweet"으로 적혀 있으며 역시 희곡 
	원문도 같다. 쉽게 말해, 이름 따위 집어치우고 자기랑 러브나하자, 뭐 이런 뜻 - 옮긴이
6)	역시 셰익스피어의 희곡 "오셀로(Othello)" 3막 3장에 나오는 대사로, 이아고(iago)가 
	오셀로를 부추기연서 하는 말이다. 희곡 원문은 "But he that filches from me my 
	good name robs me of that which not enriches him makes me poor indeed
	(그렇지만 명예를 도둑맞으면 훔친 놈은 별 볼 일 없지만 빼앗긴 쪽은 큰 손실을 보게 됩니
	다)"이다. "EC++" 원서는 필요한 부분만 발췌하여 "he that filches from me my 
	good name makes me poor indeed" 라고 되어 있으며, 역자는 우리말로 옮기면서 
	본문의 성격에 맞게 '명예'를 '이름'으로 바꾸었다.-옮긴이

코드에서 볼 수 있는 이른바 '상속된 이름'이 생각나려고 하네요. 이번 항목의 주제이기도
하죠.

상속이란 이름을 달고 이번 항목을 시작했지만, 사실 상속과는 별 관계가 없습니다. 진짜 관
계가 있는 것은 유효범위(scope)입니다. 우선 다음의 코드를 보면서 시작하도록 하죠.

int x;		// 전역 변수

void someFunc()
{
	double x;		// 지역 변수
	std::cin>>x;	// 입력을 받아, 지역 변수 x에 새 값을 읽어 넣습니다.
}

값을 읽어 x에 넣는 위의 문장에서 실제로 참조하는 x는 전역 변수가 아니라 지역 변수
입니다. 이유는 안쪽 유효범위에 있는 이름이 바깥쪽 유효범위에 있는 이름을 가리기("덮기") 
때문입니다. 위의 코드의 경우에 유효범위가 어떤 식으로 되어 있는지를 그려보면 다음과 
같습니다.

---------------------------
전역 유효범위
x
	-------------------
	someFunc의 유효범위
	x
	-------------------
---------------------------
*전역 유혀범위 안에 someFunc의 유효범위가 포함된 그림

컴파일러가 someFunc의 유효범위 안에서 x라는 이름을 만나면, 일단 그 컴파일러는 자신
이 처리하고 있는 유효범위, 즉 지역 유효범위 (local scope)를 뒤져서 같은 이름을 가진 
것이 있는가를 알아봅니다. 위에서 보신 대로 x라는 이름이 바로 있기 때문에, 이 외의 유효범위
에 대해서는 더 이상 탐색하지 않습니다. 지금의 경우 someFunc에 있는 x의 타입은
double이고 전역 변수 x의 타입은 int 이지만, 이것은 지금 중요한 사안이 아닙니다.
C++의 이름 가리기 규칙은 어쨌든 이름을 가려 버립니다. 겹치는 이름들의 타입이 같으냐
냐에 대한 부분은 신경도 안 쓴다는 거죠. 그러니까 위의 그림은, x라는 이름의 double
이 x라는 이름의 int를 가리는 것, 이렇게 말씀드릴 수 있겠습니다. 

자, 이제는 상속 이야기를 해 보죠. 기본 클래스에 속해 있는 것(멤버 함수, typedef 혹은
데이터 멤버)을 파생 클래스 멤버 함수 안에서 참조하는 문장이 있으면 컴파일러는 이 참조
대상을 바로 찾아낼 수 있습니다. 기본 클래스에 선언된 것은 파생 클래스가 모두 물려받기
때문이죠. 사실 이렇게 동작하는 이유는 파생 클래스의 유효범위가 기본 클래스의 유효범위
안에 중첩되어 있기 때문입니다. 다음의 예제를 보시죠.

class Base
{
private:
	int x;
public:
	virtual void mf1() = 0;
	virtual void mf2();
	void mf3();
	...
};

class Derived: public Base
{
pubic:
	virtual void mf1();
	void mf4();
	...
};

--------------------------------
Base의 유효 범위
x
mf1
mf2
mf3
	--------------------------
	Derived의 유효범위
	mf1
	mf4
	--------------------------
--------------------------------
*Base의 유효 범위 안에 Derived의 유효범위가 포함된 그림

보다시피 데이터 멤버와 멤버 함수의 이름이 public으로 공개되거나 private로 숨겨진
상태로 한데 뒤섞여 있는 예제입니다. 온갖 멤버 함수, 그러니끼 순수 가상, 그냥(비순수)
가상, 비가상 함수가 전부 모여 있죠? 지금 제가 이름에 대해 이야기하고 있다는 점을 강조
하고 싶어서 한번 모아 봤습니다. 맘 같아서는 타입의 이름도 넣을 수 있었을 것입니다.
enum, 중첩 클래스, typedef 등등 말이죠. 어쨌든 중요한 건 '이들이 이름이다'라는 것뿐
입니다. 무엇의 이름이냐 하는 것은 신경 쓰시지도 마세요. 지금 보시는 예제에서는 단일 상
속이 쓰이고 있는데, 일단 여기서 생기는 일만 제대로 이해해 두면 다중 상속을 썼을 때의
상황도 어렵지 않게 상할 수 있으니, 잘 따라오세요.

mf4가 파생 클래스에서 다음과 같이 구현되어 있다고 가정해 봅시다. 물론 전체 코드는 아
니죠.

void Derived::mf4()
{
	...
	mf2();
}

컴파일러는 이 함수 안을 차례로 읽어 가다가 mf2라는 이름이 쓰이고 있다는 것을 발견하
게 되는데, 이때 이 mf2가 어느 것에 대한 이름인지를 파악해야 하는 것이 급선무입니다.
이름의 출처 파악을 위해, 컴파일러는 mf2라는 이름이 붙은 것의 선언문이 들어 있는 유효
범위를 탐색하는 방법을 씁니다. 우선 지역 유효범위(즉, mf4의 유효범위) 내부를 뒤져 보는
데, mf2라 불리는 어떤 것도 선언된 게 없습니다. 그래서 mf4의 유효범위를 바깥에서 감
싸고 있는 유효범위를 찾습니다. 그러니까 지금의 경우에는 Derived 클래스의 유효범위가
그 유효범위에 해당되지요. 그런데 여전히 mf2라는 이름을 가진 것이 보이지 않으므로, 컴
파일러는 Derived 클래스를 감싸고 있는 바로 다음의 유효범위, 즉 Base 클래스의 유효
범위로 옮겨 갑니다. 여기서 컴파일러는 드디어 mf2라는 이름이 붙은 놈을 찾아내고, 탐색
이 비로소 끝납니다. 만약 Base 안에 mf2가 없으면 계속 탐색이 진행되는데, 우선 Base
를 둘러싸고 있는 네임스페이스가 있으면 그쪽부터 탐색을 시작해서, 마지막엔 전역 유효범위
까지 갑니다.

방금 위에서 말씀드린 탐색 과정은 유효범위에서 컴파일러가 이름을 찾을 때 실제로 정확히
일어나는 과정이지만, C++의 이름 탐색 과정을 모두 설명한 것은 아닙니다. 하지만 이름
규칙의 달인이라도 되어서 컴파일러를 만들 수 있을 정도의 공력을 키우는 게 지금 목표는
아니잖아요? 위의 예제처럼 기분 나쁘게 황당한 경우를 피해 가는 데 필요한 만큼만 알아두
어도 됩니다. 지금 말씀드린 정도면 충분한 정보라고 생각하고요.

다시 앞의 예제로 돌아옵시다. 이번에는 mf1 및 mf3을 오버로드하고, mf3의 오버로드 버전
을 Derived에 추가합니다[항목 36을 보시면, Derived에서 mf3 함수(비기상 함수가 상속된
것)를 오버로드하는 클래스 설계는 다른 사람들로 하여금 의혹을 사게 된다는 이야기가 나오지만,
지금은 클래스 상속 시에 이름이 보이느냐 안 보이느냐를 놓고 공부하는 중이니 그냥 넘어가도록
합시다].

class Base
{
private:
	int x;
public:
	virtual void mf1() = 0;
	virtual void mf1(int);
	virtual void mf2();
	void mf3();
	void mf3(double);
	...
};

class Derived: public Base
{
pubic:
	virtual void mf1();
	void mf3();
	void mf4();
	...
};

--------------------------------
Base의 유효 범위
x
mf1(함수 2개)
mf2
mf3(함수 2개)
	--------------------------
	Derived의 유효범위
	mf1
	mf3
	mf4
	--------------------------
--------------------------------
*Base의 유효 범위 안에 Derived의 유효범위가 포함된 그림

위의 코드가 동작하는 모습을 처음 접하고 나서 놀라지 않는 C++ 프로그래머는 아마 없을
것입니다. 무대가 클래스로 옮겨졌을 뿐, 유효범위에 기반한 이름 가리기 규칙은 전혀 변한
것이 없기 때문에, 기본 클래스에 있는 함수들 중에 mf1 및 mf3이라는 이름이 붙은 것은
모두 파생 클래스에 들어 있는 mf1 및 mf3에 의해 가려지고 맙니다. 이름 탐색의 시점에
서 보면, 어처구니없게도 Base::mf1과 Base::mf3은 Derived가 상속한 것이 아니게
된단 말입니다!

Derived d;
int x;
...
d.mf1();	// 좋습니다. Derived::mf1을 호출합니다.
d.mf1(x);	// 에러! Derived::mf1이 Base::mf1을 가립니다.
d.mf2();	// Base::mf2를 호출한다.
d.mf3();	// 문제없다. Derived::mf3을 호출한다.
d.mf3(x);	// 에러! Derived::mf3이 Base::mf3을 가립니다.

여러분도 보셨겠지만, 이런 어처구니없는 이름 가리기는 기본 클래스와 파생 클래스에 
있는(이름이 같은) 함수들이 받아들이는 매개변수 타입이 다르거나 말거나 상관이 없습니다.
심지어 함수들이 가상 함수인지 비가상 함수인지의 여부에도 상관없이 이름이 가려집니다. 
이번 항목을 시작하자마자 필자가 보여드린 코드에서 someFunc 함수 안에 있는 double
타입의 x가 전역 유효범위에 있는 int 타입의 x를 가렸듯이, 이번에는 Derived 클래스
의 mf3 함수가 Base 클래스의 mf3 함수를 가리고 있습니다. 받아들이는 타입도 완전히
다른데 말이죠.

이렇게 동작하는 데에는 다 그만한 이유가 있다는 이야기를 드리고 싶습니다. 여러분이 어
떤 라이브러리 혹은 응용프로그램 프레임워크를 이용하여 파생 클래스를 하나 만들 때, 멀
리 떨어져 있는 기본 클래스로부터 오버로드 버전을 상속시키는 경우를 막겠다는 것입니다.
일종의 실수로 간주하겠다는 것인데, 오버로드 버전을 상속했으면 하는 프로그래머가 우리
주변에 넘고 넘치니 애석한 일입니다. 사실, public 상속을 버젓이 쓰면서 기본 클래스의
오버로드 함수를 상속받지 않겠다는 것도 엄연히 is-a 관계 위반입니다. is-a 관계는 바로
public 상속의 진수라고 항목 32에서 강조하지 않았습니까? 사정이 이러하니, C++가 기
본적으로 해 버리는 '상속된 이름 가리기'를 무시하고 싶은 경우가 거의 대부분일 것입니다.

가려진 이름은 using 선언을 써서 끄집어낼 수 있습니다.
class Base
{
private:
	int x;
public:
	virtual void mf1() = 0;
	virtual void mf1(int);
	virtual void mf2();
	void mf3();
	void mf3(double);
	...
};

class Derived: public Base
{
pubic:
	using Base::mf1;	// Base에 있는 것들 중 mf1과 mf3을 이름으로 가진 						
	using Base::mf3;	// 것들을 Derived의 유효범위에서 볼 수 있도록(또 
						// public 멤버로) 만듭니다. 

	virtual void mf1();
	void mf3();
	void mf4();
	...
};

--------------------------------
Base의 유효 범위
x
mf1(함수 2개)
mf2
mf3(함수 2개)
	--------------------------
	Derived의 유효범위
	mf1(함수 2개)
	mf3(함수 2개)
	mf4
	--------------------------
--------------------------------
*Base의 유효 범위 안에 Derived의 유효범위가 포함된 그림

이제 우리가 예상했던 대로 돌아가는 상속이 되었습니다.

Derived d;
int x;
...
d.mf1();	// 이전처럼 Derived::mf1을 호출한다.
d.mf1(x);	// 문제없음. Base::mf1을 호출한다.
d.mf2();	// 문제없음. 이전처럼 Base::mf2를 호출한다.
d.mf3();	// Derived::mf3를 호출한다.
d.mf3(x);	// 문제없음. Base::mf3을 호출한다.

대강 어떤 이야기인지 감이 오시죠? 어떤 기본 클래스로부터 상속을 받으려고 히는데, 오버로
드된 함수가 그 클래스에 들어 있고 이 함수들 중 몇 개만 재정의(다른 말로 오버라이드)하고
싶다면, 각 이름에 대해 using 선언을 붙여 주어야 한다는 것입니다. 이렇게 하지 않으면
이름이 가려져 버리거든요. 가려진 이름은 여러분이 상속받고 싶어도 할 수가 없게 됩니다.

기본 클래스가 가진 함수를 전부 상속했으면 하는 것이 아닌 경우도 있긴 합니다. 물론 이
경우와 public 상속은 함께 놓고 생각하지 말아야 합니다. 기본 클래스와 파생 클래스 사
이의 is-a 관계가 깨져 버리기 때문이죠(위의 예제에서 보신 using 선언이 파생 클래스의
public 영역에 들어 있어야 하는 이유도 바로 이것입니다. 어떤 파생 클래스가 기본 클래스로부
터 public 상속으로 만들어진 것일 경우, 기본 클래스의 public 영역에 있는 이름들은 파생
클래스에서도 public 영역에 들어 있어야 합니다) 하지만 private 상속(항목 39 참조)을
사용한다면 이 경우가 문제가 될 수 있습니다. 예를 하나 들죠. Derived가 Base로부터
private 상속이 이루어졌다고 가정합시다. 그리고 Derived가 상속했으면 하는 mf1 함
수는 매개변수가 없는 버전 하나밖에 없다고 칩시다. 이때는 using 선언으로 해결할 수
없습니다. 그 이유는 using 선언을 내리면 그 이름에 해당되는 것들이 모두 파생 클래스로
내려가 버리기 때문입니다. 바야흐로 다른 기법이 필요한 경우가 된 거죠. 그 기법이란, 간
단한 전달 함수(forwarding function)를 만들어 놓는 것입니다.

class Base
{
private:
	int x;
public:
	virtual void mf1() = 0;
	virtual void mf1(int);
	virtual void mf2();
	void mf3();
	void mf3(double);
	...
};

class Derived: private Base
{
pubic:
	virtual void mf1(){ Base::mf1(); }	// 전달 함수입니다. 암시적으로
	...									// 인라인 함수가 된다(항목 30 참조).
};

...
Derived d;
int x;
d.mf1();	// Derived::mf1(매개변수 없는 버전)을 호출한다.
d.mf1(x);	// 에러! Derived::mf1은 가려져 있습니다.

지금 보신 인라인 전달 함수의 용도는 하나 더 있습니다. 기본 클래스의 이름을 파생 클래
스의 유효범위에 끌어와 쓰고 싶은데, using 선언을 아예 지원하지 못하는(물론 틀린 거죠)
암울한 시대의 컴파일러를 용하고 있다면 이 인라인 전달 함수를 써서 우회적으로 해결할
수 있습니다.

상속과 이름 가리기에 대한 이야기는 여기까지입니다. 전부 알려드렸다고 생각합니다만, 상
속이 템플릿과 엮일 경우에 전혀 다른 형태로 여러분을 괴롭히는 "상속된 이름 가려짐" 문
제는 여기서 다루지 않았습니다. 밑줄 없이는 볼 수 없는, '<'와 '>' 기호에 얽힌 파란만장한
이야기! 항목 43을 기대해 주세요.

이것만은 잊지 말자!
*	파상 클래스의 이름은 기본 클래스의 이름을 가립니다. public 상속에서는 이런 이름
	가림 현상은 바람직하지 않습니다.
*	가려진 이름을 다시 볼 수 있게 하는 방법으로 using 선언 혹은 전달 함수를 쓸 수
	있습니다.