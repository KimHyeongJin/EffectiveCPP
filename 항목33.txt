항목 33: 상속된 이름을 숨기는 인은 피하자

이름(name)에 대해서 셰익스피어(Shakespeare)가 한 말이 있습니다. "이름이 대체 무엇인가
요?"4) 이렇게 묻고 이렇게 말했습니다. "우리가 장미를 다른 이름으로 부른대도 여전히 장
미 향기가 날 텐데." 5) 또 이 음유시인은 이렇게도 말했습니다. "이름을 훔쳐가는 자는 ... 빼
앗긴 사람만 빈털터리로 만들고 마는 것입니다"6)라고요. 맞는 이야기 같죠? 이걸 보니 C++ 

4)	셰익스피어의 희곡 로미오와 줄리엣(Romeo and Juliet)에서 가장 유명한 발코니 장면인 
	2막 1장에 나오는 줄리엣의 대사 중 하나이다. "EC++" 원서에는 "What’s in a name?"
	이라고 쓰여 있으며 희곡 원문도 같다 - 옮긴이
5)	바로 앞의 각주에 나온 줄리엣의 대사가 계속 이어지는 것이다. "EC++" 원서에는 
	"A rose by any other name would smell as sweet"으로 적혀 있으며 역시 희곡 
	원문도 같다. 쉽게 말해, 이름 따위 집어치우고 자기랑 러브나하자, 뭐 이런 뜻 - 옮긴이
6)	역시 셰익스피어의 희곡 "오셀로(Othello)" 3막 3장에 나오는 대사로, 이아고(iago)가 
	오셀로를 부추기연서 하는 말이다. 희곡 원문은 "But he that filches from me my 
	good name robs me of that which not enriches him makes me poor indeed
	(그렇지만 명예를 도둑맞으면 훔친 놈은 별 볼 일 없지만 빼앗긴 쪽은 큰 손실을 보게 됩니
	다)"이다. "EC++" 원서는 필요한 부분만 발췌하여 "he that filches from me my 
	good name makes me poor indeed" 라고 되어 있으며, 역자는 우리말로 옮기면서 
	본문의 성격에 맞게 '명예'를 '이름'으로 바꾸었다.-옮긴이

코드에서 볼 수 있는 이른바 '상속된 이름'이 생각나려고 하네요. 이번 항목의 주제이기도
하죠.

상속이란 이름을 달고 이번 항목을 시작했지만, 사실 상속과는 별 관계가 없습니다. 진짜 관
계가 있는 것은 유효범위(scope)입니다. 우선 다음의 코드를 보면서 시작하도록 하죠.

int x;		// 전역 변수

void someFunc()
{
	double x;		// 지역 변수
	std::cin>>x;	// 입력을 받아, 지역 변수 x에 새 값을 읽어 넣습니다.
}

값을 읽어 x에 넣는 위의 문장에서 실제로 참조하는 x는 전역 변수가 아니라 지역 변수
입니다. 이유는 안쪽 유효범위에 있는 이름이 바깥쪽 유효범위에 있는 이름을 가리기("덮기") 
때문입니다. 위의 코드의 경우에 유효범위가 어떤 식으로 되어 있는지를 그려보면 다음과 
같습니다.

---------------------------
전역 유효범위
x
	-------------------
	someFunc의 유효범위
	x
	-------------------
---------------------------
*전역 유혀범위 안에 someFunc의 유효범위가 포함된 그림

컴파일러가 someFunc의 유효범위 안에서 x라는 이름을 만나면, 일단 그 컴파일러는 자신
이 처리하고 있는 유효범위, 즉 지역 유효범위 (local scope)를 뒤져서 같은 이름을 가진 
것이 있는가를 알아봅니다. 위에서 보신 대로 x라는 이름이 바로 있기 때문에, 이 외의 유효범위
에 대해서는 더 이상 탐색하지 않습니다. 지금의 경우 someFunc에 있는 x의 타입은
double이고 전역 변수 x의 타입은 int 이지만, 이것은 지금 중요한 사안이 아닙니다.
C++의 이름 가리기 규칙은 어쨌든 이름을 가려 버립니다. 겹치는 이름들의 타입이 같으냐
냐에 대한 부분은 신경도 안 쓴다는 거죠. 그러니까 위의 그림은, x라는 이름의 double
이 x라는 이름의 int를 가리는 것, 이렇게 말씀드릴 수 있겠습니다. 

자, 이제는 상속 이야기를 해 보죠. 기본 클래스에 속해 있는 것(멤버 함수, typedef 혹은
데이터 멤버)을 파생 클래스 멤버 함수 안에서 참조하는 문장이 있으면 컴파일러는 이 참조
대상을 바로 찾아낼 수 있습니다. 기본 클래스에 선언된 것은 파생 클래스가 모두 물려받기
때문이죠. 사실 이렇게 동작하는 이유는 파생 클래스의 유효범위가 기본 클래스의 유효범위
안에 중첩되어 있기 때문입니다. 다음의 예제를 보시죠.class Base{private:	int x;public:	virtual void mf1() = 0;	virtual void mf2();	void mf3();	...};class Derived: public Base{pubic:	virtual void mf1();	void mf4();	...};--------------------------------Base의 유효 범위xmf1mf2mf3	--------------------------	Derived의 유효범위	mf1	mf4	----------------------------------------------------------*Base의 유효 범위 안에 Derived의 유효범위가 포함된 그림보다시피 데이터 멤버와 멤버 함수의 이름이 public으로 공개되거나 private로 숨겨진
상태로 한데 뒤섞여 있는 예제입니다. 온갖 멤버 함수, 그러니끼 순수 가상, 그냥(비순수)
가상, 비가상 함수가 전부 모여 있죠? 지금 제가 이름에 대해 이야기하고 있다는 점을 강조
하고 싶어서 한번 모아 봤습니다. 맘 같아서는 타입의 이름도 넣을 수 있었을 것입니다.
enum, 중첩 클래스, typedef 등등 말이죠. 어쨌든 중요한 건 '이들이 이름이다'라는 것뿐
입니다. 무엇의 이름이냐 하는 것은 신경 쓰시지도 마세요. 지금 보시는 예제에서는 단일 상
속이 쓰이고 있는데, 일단 여기서 생기는 일만 제대로 이해해 두면 다중 상속을 썼을 때의
상황도 어렵지 않게 상할 수 있으니, 잘 따라오세요.

mf4가 파생 클래스에서 다음과 같이 구현되어 있다고 가정해 봅시다. 물론 전체 코드는 아
니죠.

void Derived::mf4()
{
	...
	mf2();
}

컴파일러는 이 함수 안을 차례로 읽어 가다가 mf2라는 이름이 쓰이고 있다는 것을 발견하
게 되는데, 이때 이 mf2가 어느 것에 대한 이름인지를 파악해야 하는 것이 급선무입니다.
이름의 출처 파악을 위해, 컴파일러는 mf2라는 이름이 붙은 것의 선언문이 들어 있는 유효
범위를 탐색하는 방법을 씁니다. 우선 지역 유효범위(즉, mf4의 유효범위) 내부를 뒤져 보는
데, mf2라 불리는 어떤 것도 선언된 게 없습니다. 그래서 mf4의 유효범위를 바깥에서 감
싸고 있는 유효범위를 찾습니다. 그러니까 지금의 경우에는 Derived 클래스의 유효범위가
그 유효범위에 해당되지요. 그런데 여전히 mf2라는 이름을 가진 것이 보이지 않으므로, 컴
파일러는 Derived 클래스를 감싸고 있는 바로 다음의 유효범위, 즉 Base 클래스의 유효
범위로 옮겨 갑니다. 여기서 컴파일러는 드디어 mf2라는 이름이 붙은 놈을 찾아내고, 탐색
이 비로소 끝납니다. 만약 Base 안에 mf2가 없으면 계속 탐색이 진행되는데, 우선 Base
를 둘러싸고 있는 네임스페이스가 있으면 그쪽부터 탐색을 시작해서, 마지막엔 전역 유효범위
까지 갑니다.

방금 위에서 말씀드린 탐색 과정은 유효범위에서 컴파일러가 이름을 찾을 때 실제로 정확히
일어나는 과정이지만, C++의 이름 탐색 과정을 모두 설명한 것은 아닙니다. 하지만 이름
규칙의 달인이라도 되어서 컴파일러를 만들 수 있을 정도의 공력을 키우는 게 지금 목표는
아니잖아요? 위의 예제처럼 기분 나쁘게 황당한 경우를 피해 가는 데 필요한 만큼만 알아두
어도 됩니다. 지금 말씀드린 정도면 충분한 정보라고 생각하고요.

다시 앞의 예제로 돌아옵시다. 이번에는 mf1 및 mf3을 오버로드하고, mf3의 오버로드 버전
을 Derived에 추가합니다[항목 36을 보시면, Derived에서 mf3 함수(비기상 함수가 상속된
것)를 오버로드하는 클래스 설계는 다른 사람들로 하여금 의혹을 사게 된다는 이야기가 나오지만,
지금은 클래스 상속 시에 이름이 보이느냐 안 보이느냐를 놓고 공부하는 중이니 그냥 넘어가도록
합시다].

class Base{private:	int x;public:	virtual void mf1() = 0;	virtual void mf1(int);	virtual void mf2();	void mf3();	void mf3(double);	...};class Derived: public Base{pubic:	virtual void mf1();	void mf3();	void mf4();	...};--------------------------------Base의 유효 범위xmf1(함수 2개)mf2mf3(함수 2개)	--------------------------	Derived의 유효범위	mf1	mf3	mf4	----------------------------------------------------------*Base의 유효 범위 안에 Derived의 유효범위가 포함된 그림위의 코드가 동작하는 모습을 처음 접하고 나서 놀라지 않는 C++ 프로그래머는 아마 없을
것입니다. 무대가 클래스로 옮겨졌을 뿐, 유효범위에 기반한 이름 가리기 규칙은 전혀 변한
것이 없기 때문에, 기본 클래스에 있는 함수들 중에 mf1 및 mf3이라는 이름이 붙은 것은
모두 파생 클래스에 들어 있는 mf1 및 mf3에 의해 가려지고 맙니다. 이름 탐색의 시점에
서 보면, 어처구나없게도 Base::mf1 과 Base::mf3은 Derived가 상속한 것이 아니게
된단 말입니다!