3장 자원 관리

프로그래멍 분야에서 자원(resource)이란, 사용을 일단 마치고 난 후엔 시스템에 돌려주어야 하는 모든 것을 일걷습니다. 
돌려주지 않는 순간부터 암울한 일들이 뽀송뽀송 피어나기 시 작할 것입니다. c++ 프로그램에서 가장 흔하게 눈에 밟히는 
자원이라면 동적 할당한 메모 리를 들 수 있는데(메모리를 할당하고서 해제하지 않으면 메모리가 누출됩니다), 사실 메모리는 
여러분이 관리해야 하는 많고 많은 자원 중 한 가지일 뿐입니다. 자원에는 파일 서술자(file descriptor)도 있고, 
뮤텍스 짐금(mutex lock)도 있으며, 그래픽 유저 인터페이스(graphical user interface: GUI)에서 쓰이는 폰트(font)와 
브러시(brush)도 자원입니다. 그뿐인가요 데이 터베이스 연결, 네트워크 소켓 역시 자원에 해당됩니다. 뭐 좋습니다. 사실 무엇이 
자원이냐 하는 것은 차차 알아가도 상관없으니까요. 진짜 중요한 것은 "어쨌든 가져와서 다 썼으면 해제해야, 즉 놓아 주어야 한다"는 사실입니다. 

이것을 수작업으로 제대로 해 주기란 어떤 상황에서도 그리 녹녹치 않은 일입니다. 하지만 예외 발생도 고려해야 하고 return 문이 
여러 개 들어 있는 함수도 만들어야 하는데다가, 이런 것들이 바뀔 때 어떤 결과가 만들어지는지 제대로 모르는 유지보수 프로그래머가 
우리 프로그램을 고치는 경우까지 생각하다 보면, "에라 모르겠다. 되는 대로 하지" 식의 자원 관리 방법은 몇 퍼센트 부족한 사람들이 
하는 일이란 점은 분명한 것 같습니다. 

이번 장은 순도 100% 객체 기반 방식의 자원 관리를 보여주는 것으로 시작하겠습니다. c++가 지원하는 생성자, 소멸자 객체 
복사 힘수를 사용하는 방법이지요. 이 방법을 기회가 닿는 대로 써먹는 버릇을 들이면 어지간한 자원 관리 문제는 모두 박멸할 수 
있음은 많은 이들의 경험으로 증명된 바 있습니다. 그 다음에는 몇 개의 항목을 할애해서 메모리 관리를 집중적으로 조명해 봅니다. 
일반적인 메모리 관리 방법을 앞의 항목들에 싣고, 특수 사항에 대해 보충하는 내용을 뒤의 항목들에서 다룰 것입니다. 메모리를 관리하는 
객체가 그 메모 리를 적절히 처리하는 방법을 알아야 하니까요.

항목 13: 자원 관리에는 객체가 그만!
투자(주식이나 채권 등)를 모델링해 주는 클래스 라이브러리를 가지고 어떤 작업을 한다고 가 정합시다. 이 라이브러리는 Investment리는 
최상위 클래스가 있고, 이것을 기본으로 하여 구체적인 형태의 투자 클래스가 파생되어 있습니다.

class Investment { ... }; // 여러 형태의 투자를 모텔링한 클래스 계통의 최상위 클래스 

가정을 하나 더 하지요. 이 라이브러리는 Investment에서 파생된 클래스의 객체를 사용 자가 얻어내는 용도로 팩토리 함수(항목 7 참조)만을 쓰도록 
만들어져 있다고요.

Investment* createlnvestment() ; //Investment 클래스 계통에 속한 클래스의 객체를 통적 할당하고 그 포인터를 반환합니다. 
								// 이 객체의 해제는 호출자 쪽에서 직접 해야 합니다. ( 매개변수는 복잡하니까 생략 ) 

주석문에 나와 있듯이, createInvestment 함수를 통해 얻어낸 객체를 사용할 일이 이 제 없을 때 그 객체를 삭제해야 히는 쪽은 이 함수의 
호출자(caller)입니다. 그렇게 쓰라고 만든 만큼, 따라 주는 것이 당연하겠지요. 아래의 함수 f는 그렇게 만들었습니다.

void f()
{
	Investment *plnv = createlnvestment();	// 팩토리 함수를 호출합니다. 
	...										// plnv를 사용합니다. 
	delete plnv;							// 객체를 해제합니다. 
}

멀쩡해 보이지만, createInvestment 함수로부터 얻은 투자 객체의 삭제에 실패할 수 있는 경우가 세상에 한두 가지가 아닙니다. 첫 번째는 '...' 
부분 어딘가에서 '도중하차' return 문이 들어 있을 가능성입니다. 이 문장이 실행되면 프로그램의 제어가 delete 문까지 도달하지 않게 됩니다. 
비슷한 경우는 또 있습니다. createInvestment 호출문과 delete가 하나의 루프 안에 들어 있고 continue 혹은 goto 문에 의해 갑작스레 루프로부터 
빠져나왔을 때가 그런 경우입니다. 마지막으로, '...' 안의 어떤 문장에서 예외를 던 질 수 있다는 점도 고려해야 합니다. 예외가 던져지면 delete 
문이 실행되지 않게 되지요. delete 문을 건너뛰는 경우는 이렇게 여러 가지이지만, 결과는 똑같습니다. 우선 투자 객체를 담고 있는 메모리가 누출되고, 
그와 동시에 그 객체가 갖고 있던 자원까지 모두 샙니다.

물론, 하나하나 따져 가면서 꼼꼼하게 프로그램을 만들면 이런 종류의 에러는 막을 수 있겠 지만, 오랜 시간 동안 코드를 변경한다면 어떻게 할지 생각해 보세요. 
소프트웨어가 유지보 수라는 컨베이어 벨트에 놓이게 되면, 유지보수를 맡은 누군가는 자신이 하는 일이 이 함수의 자원 관리 전략에 어떤 결과를 가져오는지에 
대해 제대로 파악하지 못한 채로 return 이나 continue 문을 써대는 경우도 있단 말이죠. 상황이 더 안 좋아질 수도 있습니다. f 의 '…' 부분에서 어떤 함수를 
호출하는데, 이 함수는 예외와 전혀 안 친했었다가 "누군가가 고친답시고 어떻게 해둔" 후부터 갑자기 예외를 터뜨려 대기 시작할지는 이무도 모릅니다. 
f가 항상 delete 문으로 가 줄 거라고 믿지 마세요. 오래 못 갑니다.

createlnvestment 함수로 얻어낸 자원이 항상 해제되도록 만들 방법은, 자원을 객체에 넣고 그 자원 해제를 소멸자가 맡도록 하며, 그 소멸자는 실행 
제어가 f를 떠날 때 호출되 도록 만드는 것입니다. 사실 이 부분은 이번 항목에서 소개할 아이디어의 전반부이니 새겨 두세요. 자원을 객체에 넣음으로써, 
C++가 자동으로 호출해 주는 소멸자에 의해 해당 자원 을 저절로 해제할 수 있습니다(후반부는 조금 있다가 보도록 하지요).

소프트웨어 개발에 쓰이는 상당수의 자원이 힙에서 동적으로 할당되교 하나의 블록(block) 혹은 함수 안에서만 쓰이는 경우가 잦기 때문에 그 블록 혹은 
함수로부터 실행 제어가 빠져 나올 때 자원이 해제되는 게 맞습니다. 표준 라이브러리를 보면 auto_ptr이란 것이 있는 데, 바로 이런 용도에 쓰라고 
마련된 클래스입니다. auto_ptr은 포인터와 비슷하게 동작 하는 객체[스마트 포인터(smart poinler)]로서, 가리키고 있는 대상에 대해 소멸자가 
자동으로 delete를 불러주도록 설계되어 있습니다. 그럼, f에서 생길 수 있는 자원 누출을 막기 위해 auto_ptr을 사용하는 방법을 보시겠습니다.

void f()
{
	std::auto_ptr<InveSLment> plnv(createlnvestment()); // 팩토리 함수를 호출합니다. 예전처럼 pInv를 사용합니다.
	...
}
// auto_ptr의 소멸자를 통해 pInv를 삭제합니다.

이주 간단한 예제이지만, 자원 관리에 객체를 사용하는 방법의 중요한 두 가지 특정을 여기서 끄집어낼 수 있습니다.