3장 자원 관리

프로그래멍 분야에서 자원(resource)이란, 사용을 일단 마치고 난 후엔 시스템에 돌려주어야 하는 모든 것을 일걷습니다. 
돌려주지 않는 순간부터 암울한 일들이 뽀송뽀송 피어나기 시 작할 것입니다. c++ 프로그램에서 가장 흔하게 눈에 밟히는 
자원이라면 동적 할당한 메모 리를 들 수 있는데(메모리를 할당하고서 해제하지 않으면 메모리가 누출됩니다), 사실 메모리는 
여러분이 관리해야 하는 많고 많은 자원 중 한 가지일 뿐입니다. 자원에는 파일 서술자(file descriptor)도 있고, 
뮤텍스 짐금(mutex lock)도 있으며, 그래픽 유저 인터페이스(graphical user interface: GUI)에서 쓰이는 폰트(font)와 
브러시(brush)도 자원입니다. 그뿐인가요 데이 터베이스 연결, 네트워크 소켓 역시 자원에 해당됩니다. 뭐 좋습니다. 사실 무엇이 
자원이냐 하는 것은 차차 알아가도 상관없으니까요. 진짜 중요한 것은 "어쨌든 가져와서 다 썼으면 해제해야, 즉 놓아 주어야 한다"는 사실입니다. 

이것을 수작업으로 제대로 해 주기란 어떤 상황에서도 그리 녹녹치 않은 일입니다. 하지만 예외 발생도 고려해야 하고 return 문이 
여러 개 들어 있는 함수도 만들어야 하는데다가, 이런 것들이 바뀔 때 어떤 결과가 만들어지는지 제대로 모르는 유지보수 프로그래머가 
우리 프로그램을 고치는 경우까지 생각하다 보면, "에라 모르겠다. 되는 대로 하지" 식의 자원 관리 방법은 몇 퍼센트 부족한 사람들이 
하는 일이란 점은 분명한 것 같습니다. 

이번 장은 순도 100% 객체 기반 방식의 자원 관리를 보여주는 것으로 시작하겠습니다. c++가 지원하는 생성자, 소멸자 객체 
복사 힘수를 사용하는 방법이지요. 이 방법을 기회가 닿는 대로 써먹는 버릇을 들이면 어지간한 자원 관리 문제는 모두 박멸할 수 
있음은 많은 이들의 경험으로 증명된 바 있습니다. 그 다음에는 몇 개의 항목을 할애해서 메모리 관리를 집중적으로 조명해 봅니다. 
일반적인 메모리 관리 방법을 앞의 항목들에 싣고, 특수 사항에 대해 보충하는 내용을 뒤의 항목들에서 다룰 것입니다. 메모리를 관리하는 
객체가 그 메모 리를 적절히 처리하는 방법을 알아야 하니까요.

항목 13: 자원 관리에는 객체가 그만!

투자(주식이나 채권 등)를 모델링해 주는 클래스 라이브러리를 가지고 어떤 작업을 한다고 가 정합시다. 이 라이브러리는 Investment리는 
최상위 클래스가 있고, 이것을 기본으로 하여 구체적인 형태의 투자 클래스가 파생되어 있습니다.

class Investment { ... }; // 여러 형태의 투자를 모텔링한 클래스 계통의 최상위 클래스 

가정을 하나 더 하지요. 이 라이브러리는 Investment에서 파생된 클래스의 객체를 사용 자가 얻어내는 용도로 팩토리 함수(항목 7 참조)만을 쓰도록 
만들어져 있다고요.

Investment* createInvestment() ; //Investment 클래스 계통에 속한 클래스의 객체를 통적 할당하고 그 포인터를 반환합니다. 
								// 이 객체의 해제는 호출자 쪽에서 직접 해야 합니다. ( 매개변수는 복잡하니까 생략 ) 

주석문에 나와 있듯이, createInvestment 함수를 통해 얻어낸 객체를 사용할 일이 이 제 없을 때 그 객체를 삭제해야 히는 쪽은 이 함수의 
호출자(caller)입니다. 그렇게 쓰라고 만든 만큼, 따라 주는 것이 당연하겠지요. 아래의 함수 f는 그렇게 만들었습니다.

void f()
{
	Investment *pInv = createInvestment();	// 팩토리 함수를 호출합니다. 
	...										// pInv를 사용합니다. 
	delete pInv;							// 객체를 해제합니다. 
}

멀쩡해 보이지만, createInvestment 함수로부터 얻은 투자 객체의 삭제에 실패할 수 있는 경우가 세상에 한두 가지가 아닙니다. 첫 번째는 '...' 
부분 어딘가에서 '도중하차' return 문이 들어 있을 가능성입니다. 이 문장이 실행되면 프로그램의 제어가 delete 문까지 도달하지 않게 됩니다. 
비슷한 경우는 또 있습니다. createInvestment 호출문과 delete가 하나의 루프 안에 들어 있고 continue 혹은 goto 문에 의해 갑작스레 루프로부터 
빠져나왔을 때가 그런 경우입니다. 마지막으로, '...' 안의 어떤 문장에서 예외를 던 질 수 있다는 점도 고려해야 합니다. 예외가 던져지면 delete 
문이 실행되지 않게 되지요. delete 문을 건너뛰는 경우는 이렇게 여러 가지이지만, 결과는 똑같습니다. 우선 투자 객체를 담고 있는 메모리가 누출되고, 
그와 동시에 그 객체가 갖고 있던 자원까지 모두 샙니다.

물론, 하나하나 따져 가면서 꼼꼼하게 프로그램을 만들면 이런 종류의 에러는 막을 수 있겠 지만, 오랜 시간 동안 코드를 변경한다면 어떻게 할지 생각해 보세요. 
소프트웨어가 유지보 수라는 컨베이어 벨트에 놓이게 되면, 유지보수를 맡은 누군가는 자신이 하는 일이 이 함수의 자원 관리 전략에 어떤 결과를 가져오는지에 
대해 제대로 파악하지 못한 채로 return 이나 continue 문을 써대는 경우도 있단 말이죠. 상황이 더 안 좋아질 수도 있습니다. f 의 '…' 부분에서 어떤 함수를 
호출하는데, 이 함수는 예외와 전혀 안 친했었다가 "누군가가 고친답시고 어떻게 해둔" 후부터 갑자기 예외를 터뜨려 대기 시작할지는 이무도 모릅니다. 
f가 항상 delete 문으로 가 줄 거라고 믿지 마세요. 오래 못 갑니다.

createInvestment 함수로 얻어낸 자원이 항상 해제되도록 만들 방법은, 자원을 객체에 넣고 그 자원 해제를 소멸자가 맡도록 하며, 그 소멸자는 실행 
제어가 f를 떠날 때 호출되 도록 만드는 것입니다. 사실 이 부분은 이번 항목에서 소개할 아이디어의 전반부이니 새겨 두세요. 자원을 객체에 넣음으로써, 
C++가 자동으로 호출해 주는 소멸자에 의해 해당 자원 을 저절로 해제할 수 있습니다(후반부는 조금 있다가 보도록 하지요).

소프트웨어 개발에 쓰이는 상당수의 자원이 힙에서 동적으로 할당되교 하나의 블록(block) 혹은 함수 안에서만 쓰이는 경우가 잦기 때문에 그 블록 혹은 
함수로부터 실행 제어가 빠져 나올 때 자원이 해제되는 게 맞습니다. 표준 라이브러리를 보면 auto_ptr이란 것이 있는 데, 바로 이런 용도에 쓰라고 
마련된 클래스입니다. auto_ptr은 포인터와 비슷하게 동작 하는 객체[스마트 포인터(smart poinler)]로서, 가리키고 있는 대상에 대해 소멸자가 
자동으로 delete를 불러주도록 설계되어 있습니다. 그럼, f에서 생길 수 있는 자원 누출을 막기 위해 auto_ptr을 사용하는 방법을 보시겠습니다.

void f()
{
	std::auto_ptr<Investment> pInv(createInvestment()); // 팩토리 함수를 호출합니다. 예전처럼 pInv를 사용합니다.
	...
}// auto_ptr의 소멸자를 통해 pInv를 삭제합니다.

이주 간단한 예제이지만, 자원 관리에 객체를 사용하는 방법의 중요한 두 가지 특정을 여기서 끄집어낼 수 있습니다.

첫째, 자원을 획득한 후에 자원 관리 객체에게 넘깁니다. 
위의 예제를 보면, createInvestment 함수가 만들어 준 자원은 그 자원을 관리할 auto_ptr 객체를 초기화 하는 데 쓰이고 있지요. 실제로 이렇게 자원 
관리에 객체를 사용히는 아이디어에 대한 업계 용어도 자주 통용되고 있는데, 자원 획득 즉, 초기화(Resource Acquisition Is Initialization: RAII)라는 
이름입니다. 이런 이름이 나온 이유는 자원 획득과 자원 관리 객체의 초기화가 바로 한 문장에서 이루어지는 것이 너무나도 일상적이기 때문입니다. 획득된 자원으로 
자원 관리 객체를 초기화하지 않고 그 자원을 그 객체에 대입하는 경우도 종종 있기는 하지만, 어찌 됐든 "자원을 획득하고 나서 바로 자원 관리 객체에 넘 겨 준다"는 
점은 같습니다.

둘째, 자원 관리 객체는 자신의 소멸자를 사용해서 자원이 확실히 해제되도록 합니다. 
소멸자는 어떤 객체가 소멸될 때(유효범위를 벗어나는 경우가 한 가지 예) 자동적으로 호출되기 때문에, 실행 제어가 어떤 경위로 블록을 떠나는가에 상관없이 
자원 해제가 제대로 이루어지게 되는 것입니다. 물론 객체를 해제하다가 예외가 발생될 수 있는 상황에 빠지면 사태가 많이 꼬이기도 하겠지만, 그 문제는 
항목 8에서 해결할 부분이기 때 문에 여기서 걱정할 필요는 없겠습니다.

auto_ptr은 자신이 소멸될 때 자신이 가리키고 있는 대상에 대해 자동으로 delete를 먹이기 때문에, 어떤 객체를 가리키는 auto_ptr의 개수가 둘 이상이면 절대로 안 되겠지요. 
정말 중요합니다. 만에 하나 이러한 사태가 되면 결국 자원이 두 번 삭제되는 결과를 낳게 되고, 프로그램은 미정의 동작의 수렁에 빠지게 될 테니까요. 이런 불상사를 막는답시고 
auto_ptr은 상당히 유별난 특성을 지니게 되었는데, 그게 무엇인고 하니 auto_ptr 객체를 복사하면(복사 생성자 혹은 복사 대입 연산자를 통해) 원본 객체는 null로 만든답니다. 
복사하는(copying) 객체만이 그 자원의 유일한 소유권(ownership)을 갖는다고 가정한다니까요. 세상에나!

std::auto_ptr<Investment> pInv1(createInvestment());// pInv1이 가리키는 대상은 createInvestment 함수에서 반환된 객체입니다.
std::auto_ptr<Investment> pInv2(pInv1);			// pInv2는 현재 그 객체를 가리키고 있는 반면, 이제 pInv1은 null입니다.
pInv1 = pInv2;									// 지금 pInv1은 그 객체를 가리키고 있으며, pInv2는 null입니다.

이렇듯 상식을 살짝 비껴가는 복사 동작도 그렇고, auto_ptr이 관리하는 객체는 두 개 이상의 auto_ptr 객체가 물고 있으면 안 된다는 요구사항까지 깔려 있는 통에, 
동적으로 할당되는 모든 자원에 대한 관리 객체로서 auto_ptr을 쓰는 것은 최선이 아닐 듯하다는 느낌이 아련하게 듭니다. 예를 들어, STL 컨테이너의 경우엔 원소들이 '정상적인' 
복사 동작을 가져야 하기 때문에, auto_ptr은 이들의 원소로 허용되지 않습니다. auto_ptr을 쓸 수 없는 상황이라면 그 대안으로 참조 카운팅 방식 스마트 포인터 
(reference-counting smart pointer: RCSP)가 아주 괜찮습니다. RCSP는 특정한 어떤 자원을 가리키는(참조하는) 외부 객체의 개수를 유지하고 있다가 그 개수가 0이 되면 
해당 자원 을 자동으로 삭제하는 스마트 포인터입니다. 이것만 보면, RCSP의 동작은 가비지 컬렉션 (garbage collection)의 그것과 상당히 흡사합니다. 단, 참조 상태가 고리를 
이루는 경우(예를 들면 다른 두 객체가 서로를 가리키고 있다든지)를 없앨 수 없다는 점은 가비지 컬렉션과 다릅니다. 

TR1에서 제공되는 tr1::shared_ptr(항목 54 참조)이 대표적인 RCSP입니다. 이것을 써서 f 함수를 다시 작성해 보면 다음과 같습니다.
void f()
{
	std::tr1::shared_ptr<Investment> pInv(createInvestment()); // 팩토리 함수를 호출합니다. 예전처럼 pInv를 사용합니다.
	...
} // shared_ptr의 소멸자를 통해 pInv를 자동으로 삭제합니다.

auto_ptr을 사용한 버전과 거의 똑같아 보이는 코드이지만, shared_ptr의 복사가 훨 씬 자연스러워졌습니다.

void f()
{
	...
	std::tr1::shared_ptr<Investment> pInv1(createInvestment()); // pInv1이 가리키는 대상은  createInvestment 함수에서 반환된 객체입니다. 
	stdd::tr1::shared_ptr<Investment> pInv2(pInv1);				// pInv1 및 pInv2가 동시에 그 객체를 가리키고 있습니다. 
	pInv1 = pInv2;						// 마찬가지 변한 것은 하나도 없습니다.
	...
}// pInv1 및 pInv2는 소멸되며, 이들이 가리키고 있는 객체도 자동으로 삭제됩니다.

복사 동작이 '예상대로' 이루어지기 때문에, tr1::shared_ptr은 괴상한 복사 동작으로 인해 auto_ptr을 쓸 수 없는 STL 컨테이너 등의 환경에 딱 맞게 쓸 수 있습니다. 
말을 늘어놓다 보니 주제가 옆으로 많이 샌 느낌입니다. auto_ptr 혹은 tr1::shared_ptr 등 스마트 포인터 이야기를 늘어놓으려고 이번 항목을 준비한 것은 아니거든요. 
자원을 관리하는 객체를 써서 자원을 관리히는 것이 중요하다는 이야기가 진짜입니다. auto_ptr 과 tr1::shared_ptr은 그렇게 하는 여러 가지 벙법들 중 몇 가지일 뿐이고요
(tr1::shared_ptr 클래스에 대한 더 자세한 이야기는 항목 14, 18, 54에서 참고하십시오).

알아두셔야 할 게 하나 더 있습니다. auto_ptr 및 tr1::shared_ptr은 소멸자 내부에서 delete 연산자를 사용합니다. delete [] 연산자가 아닙니다(이 둘의 차이는 항목 16에서 확인하세요). 
말하자면, 동적으로 할당한 배열에 대해 auto_ptr이나 tr1::shared_ptr을 사용하면 대략 난감하다는 이야기입나다. 동적 배열을 썼을 때 컴파일 에러가 났으면 그나마 좋겠는데 애석하게도 
컴파일 에러가 발생하지 않습니다.

std::auto_ptr<std::string> aps(new std::string[10]); // 좋지 않은 발상입니다! 잘못된 delete가 사용됩니다.
std::tr1::shared_ptr<int> spi(new int[1024]);	// 같은 문제가 발생합니다.

이 말을 들으면 더 놀라실 것 같지만, 한 마디 더 하죠. C++ 표준 라이브러리에서는 동적 할당된 배열을 위해 준비된 auto_ptr 혹은 tr1::shared_ptr 같은 클래스가 제공되지 않습니다. 
심지어 tr1에서도요. 왜냐하면 동적으로 할당된 배열은 이제 vector 및 string으로 거의 대체할 수 있기 때문입니다. 배열에 쓸 수 있는 auto_ptr이라든지 tr1::shared_ptr이 있으면 
좋겠다며 밤잠을 못 주무시는 분이라면 부스트(항목 55 참죄에 가보세요. 원하는 기능을 정확히 가지고 있어서 여러분이 반가워할 만한 boost::scoped_array와 boost::shared_array가 
있을 테니까요.

이번 항목에서 "자원 관리에 객체를 쓰자"라는 지침을 통해 펼자가 강조하고 싶은 바는 이것입니다. 자원 해제를 여러분이 일일이 하다 보면(자원 관리 클래스를 쓰지 않고 delete를 쓴다든지 해서) 
언젠가 잘못을 저지르고 만다는 이야기입니다. 이미 널리 쓰이고 있는 auto_ptr 이나 tr1::shared_ptr 같은 자원 관리 클래스를 활용하는 것도 이번 항목의 조언을 쉽게 지킬 수 있는 한 가지 
방법입니다. 다만 이런 클래스로도 제대로 관리할 수 없는 자원도 있다는 사실, 잊지 마세요. 이런 경우엔 여러분만의 자원 관리 클래스를 직접 만들 수밖에 없습니다. 영장류의 능력을 초월해야 할 
만큼 어려운 일은 아니지만, 각별히 신경 써야 할 부분이 많으므로 세심함이 필요한 것은 사실입니다. 이런저런 고려 사항은 항목 14 및 15에 따로 준비해 두었으니 참고하세요.

자, 이제 마지막 잔소리입니다. 앞에서 본 createInvestment 함수의 반환 타입이 포인터로 되어 있는데, 이 부분 때문에 문제가 생길 수 있음을 지적하고 싶습나다. 반환된 포인터에 대한 delete 
호출을 호출자 쪽에서 해야 하는데, 그것을 잊어버리고 넘어가기 쉽기 때문입니다. auto_ptr 혹은 tr1::shared_ptr을 써서 delete를 수행한다고 하더라도, createInvestment의 반환 값을 
스마트 포인터에 저장해야 한다는 점만은 여전히 기억하고 있어야 하거든요. 이 문제를 어떻게든 해결하려면 createInvestment를 수술해서 인터페이스를 고쳐야 히는데, 항목 18에서 해 두었으니 한 
번 보세요.

이것만은 잊지 말자! 
* 자원 누출을 막기 위해, 생성자 안에서 자원을 획득하고 소멸자에서 그것을 해제하는 RAII 객체를 시용함시다 
* 일반적으로 널리 쓰이는 RAII 클래스는 tr1::shared_ptr 그리고 auto_ptr입니다. 이 둘 가운데 tr1::shared_ptr이 복사 시의 동작이 직관적이기 때문에 대개 더 좋습니다. 
반면, auto_ptr은 복사되는 객체(원본 객체)를 null로 만들어 버립니다. 
