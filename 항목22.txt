항목 22: 데이터 멤버가 선언될 곳은 private 영역임을 명심하자

음, 난데없이 생뚱맞지만 제안을 하나 하겠습니다. 이번 항목에서는 먼저 데이터 멤버가 어
째서 public이면 안 되는지에 대한 이유를 알아보고, public 데이터 멤버에 대한 모든
이야기가 protected 데이터 멤버에도 똑같이 적용되는 모습을 함께 확인하도록 하지요.
여기까지 이야기가 끝나면 데이터 멤버는 반드시 private 멤버이어야 한다는 결론을 자
연스럽게 볼 수 있을 것입니다.

그리하여 public 데이터 멤버를 먼저 도마 위에 올리겠습니다. 왜 이게 안 될까요?

우선 문법적 일관성이 첫 번째 이유 되겠습니다(항목 18도 같이 읽어두세요). 데이터 멤버가
public이 아니라면, 사용자 쪽에서 어떤 객체를 접근할 수 있는 유일한 수단은 멤버 함수
일 것입니다. 자, 어떤 클래스의 공개 인터페이스에 있는 것들이 전부 함수뿐이라면, 그 클
래스의 멤버에 접근하고 싶을 때 괄호를 붙여야 하는지 말아야 하는지를 기억하지 못해서
사용자가 고민할 필요도 없을 것이고요. 전부 함수로 되어있으니까 그냥 쓰기만 하면 됩니다. 

문법적 일관성에 대한 이야기가 그리 마음에 다가오지 않는 독자도 분명히 있을 것입니다.
그럼, 함수를 사용하면 데이터 멤버의 접근성에 대해 훨씬 정교한 제어를 할 수 있다는 사
실은 어떻게 생각하세요? 만일 어떤 데이터 멤버를 public으로 내놨다면 모두가 이 멤버
에 대해 읽기 및 쓰기 접근권한을 갖게 되지만, 이 값을 읽고 쓰는 함수가 있으면 접근 불
가, 읽기 전용, 읽기 쓰기 접근을 여러분이 직접 구현할 수 있습니다. 심지어 쓰기 전용 접
근도 필요하면 구현할 수 있다니까요.

class AccessLevels
{
public:
	...
	int getReadOnly() const { return readOnly; }
	void setReadWrite(int Value ) { readWrite = value; }
	int getReadWrite() const { return readWrite; }
	void setWriteOnly(int value) { writeOnly = value; }
private:
	int noAcess;		// 이 int에 대해서는 접근 불가
	int readOnly;		// 이 int에 대해서는 읽기 전용 접근
	int readWrite;		// 이 int에 대해서는 읽기 쓰기 접근
	int writeOnly;		// 이 int에 대해서는 쓰기 전용 접근
};

이렇게 세밀한 접근 제어는 나름대로의 중요성을 갖고 있습니다. 어떤 식으로든 외부에 
노시키면 안 되는 데이터 멤버들이 꽤 많기 때문이죠. 사실 모든 데이터 멤버에 읽기 및
쓰기 함수를 달아 줄 일은 극히 드물잖아요.

아직도 뭔가가 미지근하신가요? 그렇다면 비장의 카드를 보여드릴 때가 된 것 같군요.
다른 게 아니라 캡슐화(encapsulation)입니다. 함수를 통해서만 데이터 멤버에 접근할 
수 있도록 구현해 두면, 데이터 멤버를 나중에 계산식으로 대체할 수도 있을 것이고, 사용자는 
절대로 이 클래스를 넘보는 잘난 사람이 되지 못한다는 것입니다.

예를 하나 들어 보겠습니다. 자동화 장치를 사용해서 자동차가 나가는 속도를 모니터링하
는 프로그램을 만들고 있다고 가정해 봅시다. 이 프로그램이 실행되면, 자동차가 지나갈 때
마다 속도를 계산한 후에 지금까지 수집한 속도 데이터 집합에 그 속도를 추가합니다.

class SpeedDataCollection
{
	...
public:
	void addValue(int speed);	// 새 데이터 값을 추가합니다.
	double averageSoFar() const;	// 평균 속도를 반환합니다.
};