항목 22: 데이터 멤버가 선언될 곳은 private 영역임을 명심하자

음, 난데없이 생뚱맞지만 제안을 하나 하겠습니다. 이번 항목에서는 먼저 데이터 멤버가 어
째서 public이면 안 되는지에 대한 이유를 알아보고, public 데이터 멤버에 대한 모든
이야기가 protected 데이터 멤버에도 똑같이 적용되는 모습을 함께 확인하도록 하지요.
여기까지 이야기가 끝나면 데이터 멤버는 반드시 private 멤버이어야 한다는 결론을 자
연스럽게 볼 수 있을 것입니다.

그리하여 public 데이터 멤버를 먼저 도마 위에 올리겠습니다. 왜 이게 안 될까요?

우선 문법적 일관성이 첫 번째 이유 되겠습니다(항목 18도 같이 읽어두세요). 데이터 멤버가
public이 아니라면, 사용자 쪽에서 어떤 객체를 접근할 수 있는 유일한 수단은 멤버 함수
일 것입니다. 자, 어떤 클래스의 공개 인터페이스에 있는 것들이 전부 함수뿐이라면, 그 클
래스의 멤버에 접근하고 싶을 때 괄호를 붙여야 하는지 말아야 하는지를 기억하지 못해서
사용자가 고민할 필요도 없을 것이고요. 전부 함수로 되어있으니까 그냥 쓰기만 하면 됩니다. 

문법적 일관성에 대한 이야기가 그리 마음에 다가오지 않는 독자도 분명히 있을 것입니다.
그럼, 함수를 사용하면 데이터 멤버의 접근성에 대해 훨씬 정교한 제어를 할 수 있다는 사
실은 어떻게 생각하세요? 만일 어떤 데이터 멤버를 public으로 내놨다면 모두가 이 멤버
에 대해 읽기 및 쓰기 접근권한을 갖게 되지만, 이 값을 읽고 쓰는 함수가 있으면 접근 불
가, 읽기 전용, 읽기 쓰기 접근을 여러분이 직접 구현할 수 있습니다. 심지어 쓰기 전용 접
근도 필요하면 구현할 수 있다니까요.

class AccessLevels
{
public:
	...
	int getReadOnly() const { return readOnly; }
	void setReadWrite(int Value ) { readWrite = value; }
	int getReadWrite() const { return readWrite; }
	void setWriteOnly(int value) { writeOnly = value; }
private:
	int noAcess;		// 이 int에 대해서는 접근 불가
	int readOnly;		// 이 int에 대해서는 읽기 전용 접근
	int readWrite;		// 이 int에 대해서는 읽기 쓰기 접근
	int writeOnly;		// 이 int에 대해서는 쓰기 전용 접근
};

이렇게 세밀한 접근 제어는 나름대로의 중요성을 갖고 있습니다. 어떤 식으로든 외부에 
노시키면 안 되는 데이터 멤버들이 꽤 많기 때문이죠. 사실 모든 데이터 멤버에 읽기 및
쓰기 함수를 달아 줄 일은 극히 드물잖아요.

아직도 뭔가가 미지근하신가요? 그렇다면 비장의 카드를 보여드릴 때가 된 것 같군요.
다른 게 아니라 캡슐화(encapsulation)입니다. 함수를 통해서만 데이터 멤버에 접근할 
수 있도록 구현해 두면, 데이터 멤버를 나중에 계산식으로 대체할 수도 있을 것이고, 사용자는 
절대로 이 클래스를 넘보는 잘난 사람이 되지 못한다는 것입니다.

예를 하나 들어 보겠습니다. 자동화 장치를 사용해서 자동차가 나가는 속도를 모니터링하
는 프로그램을 만들고 있다고 가정해 봅시다. 이 프로그램이 실행되면, 자동차가 지나갈 때
마다 속도를 계산한 후에 지금까지 수집한 속도 데이터 집합에 그 속도를 추가합니다.

class SpeedDataCollection
{
	...
public:
	void addValue(int speed);	// 새 데이터 값을 추가합니다.
	double averageSoFar() const;	// 평균 속도를 반환합니다.
};

이제 averageSoFar 멤버 함수를 어떻게 구현할지 생각해 보도록 합시다. 한 가지 방법
으로, 지금까지 수집한 속도 데이터 전체의 평균값을 담는 어떤 데이터 멤버를 클래스 안에
넣어두는 방안이 있겠네요. averageSoFar 함수는 호출될 때마다 그 데이터 멤버의 값을
반환하기만 하면 됩니다. 또 다른 방법으로는 호출될 때마다 평균값을 계산하는 방법이 있
습니다. 수집한 데이터를 매번 죽 훑어가는 코드가 들어가게 되겠지요.

첫 번째 방법(현재의 평균값 유지하기)을 시용하면, SpeedDataCollection 객체 하나의
크기가 좀 커집니다. 평균값을 유지하기 위한 공간 할당이 필요할 테니까요. 현재의 평균값,
누적 총합, 데이터의 개수 등이 데이터 멤버로 들어가야 할 것입니다. 하지만 이런 방법으로
구현한 averageSoFar 함수는 효율 면에서 꽤 짭짤할 수 있습니다. 현재의 평균값을 반환
하기만 하는 인라인 함수(항목 30 참조)인데 느릴 리가 없잖아요. 이와 반대로 호출될 때마다
평균값을 계산하는 방법을 쓰면 함수 자체의 속도는 느려지지만, SpeedDataCollection
객체 하나의 크기는 첫 번째 방법보다 작아질 것입니다.

어느 방법이 최고인지, 정답이 있겠습니까? 쓸 수 있는 메모리가 빡빡한 환경이고[노변장치
(roadside device)용 임베디드 기계라든지], 평균값이 그다지 자주 필요하지 않은 응용프로그램
을 만드는 경우에는 평균값 계산을 매번 히는 편이 아마 더 좋을 것입니다. 평균값을 빈번
하게 사용해야 하고 속도가 이주 중요하며, 메모리 크기에 많이 구애받지 않는 환경이라면
평균값을 유지하는 방법이 바람직할 것이고요. 어쨌든 중요한 포인트는 "평균값 접근에 멤
버 함수를 통하게 한다."(다른 말로 평균값을 캡슐화한다)라는 점인데, 이렇게 함으로써 내부
구현을 이렇게 혹은 저렇게(여러분이 생각하는 다른 방법도 있겠지요) 바꿀 수 있게 되고 사용
자 쪽에서는 기껏 해 봤자 컴파일만 다시 하면 끝납니다(그리고 항목 31에 나온 방법을 쓰면
이런 약간의 불편함까지 없앨 수 있습니다).

데이터 멤버를 함수 인터페이스 뒤에 감추게 되면 구현상의 융통성을 전부 누릴 수 있습니다. 
예를 들면 이런 것들이 간편해집니다. 데이터 멤버를 읽거나 쓸 때 다른 객체에 알림 메
시지를 보낸다든지, 클래스의 불변속성 및 사전조건(precondition), 사후조건(postcondition)
을 검증한다든지, 스레딩 환경에서 동기화를 건다든지 히는 일이죠. 델파이(Delphi) 및 C#
등의 언어를 쓰다가 C++로 오신 프로그래머들이 이 이야기를 들으면 '프로퍼티(property)'와
똑같은 것이라고 말할 것입니다. 비록 C++에서는 괄호쌍을 더 붙여 주어야 한다는 점이 다
르지만요.

캡슐화에 대해 위에서 말씀드린 부분은 여러분이 처음 들었을 때 어떻게 느끼셨는지 몰라도
그보다 훨씬 중요하다고 힘주어 외치고 싶습니다. 사용자로부터 데이터 멤버를 숨기면(캡슐화하면), 
클래스의 불변속성을 항상 유지하는 데 절대로 소홀해질 수 없게 됩니다.

불변속성을 보여줄 수 있는 통로가 멤버 함수밖에 없으니까요. 그뿐 아니라 캡슐화는 현재
의 구현을 나중에 수정할 수 있는 권한을 예약하는 셈입니다. 이러한 결정을 숨기지 않으면, 
여러분이 클래스의 소스 코드를 갖고 있더라도 public 데이터 멤버에는 손을 대기가 힘들다
는 사실에 속이 상할 수도 있습니다. 손댔다가는 사용자 코드가 깨질테니까요. 무릇 C++ 
세상에서 public이란 '캡슐화되지 않았다'는 뜻이며, 실질적인 측면에서 이야기할 때 
'캡슐화되지 않았다'라는 말은 '바꿀 수 없다'라는 의미를 담고 있습니다.
(널리 쓰이는 클래스일 수록 'public 데이터 멤버 = 캡슐화되지 않았다 = 바꿀 수없다', 
왜냐하면 사용자 코드가 깨지니까?)
널리 쓰이는 클래스일수록 특히 그렇죠 사실, 널리 쓰이는 클래스들이야말로 캡슐화가 가장
필요하지 않을까요. 내부 구현을 더 좋은 쪽으로 개선할 수 있는 기능의 혜택을 가장 많이
볼 수 있는 것들이니 말입니다.

protected 데이터 멤버의 경우도 앞서 말한 사정과 비슷합니다. 솔직히 말해서 똑같습니
다. 처음엔 안 믿기실지 몰라도 결국 똑같게 됩니다. 문법적 일관성과 세밀한 접근 제어에 관
한 이야기라면 public 데이터 멤버처럼 protected 데이터 멤버에도 그대로 적용할 수
있습니다. 그러나 캡슐화는 어떻게 되는 걸까요? 어쨌든 public 데이터 멤버보다는 더 많
이 가려져 있지 않습니까? 실질적인 측면에서 말씀드리면, 충격적인 대답으로 들릴 수 있겠지
만 아닙니다.

항목 23을 보시면 이런 내용이 나와 있습니다. 어떤 것을 바꿔서 깨질 가능성을 가진 코드
가 늘어날 때 캡슐화의 정도는 그에 반비례해서 작아진다고요. 그러니까 데이터 멤버가 바
뀌면, 다시 말해 클래스에서 제거되면(계산 효율을 위해서라면 충분히 가능성 있습니다. 위의
averageSoFar 함수처럼 말이죠) 깨질 수 있는 코드의 양에 반비례해서 그 데이터 멤버는
캡슐화 정도가 감소한다는 것입니다.

어떤 클래스에 public 데이터 멤버가 있고, 이것을 제거한다고 가정합시다. 이 멤버에 매
달려 있는 얼마나 많은 코드가 망가질까요? 이것을 사용하는 사용자 코드는 전부 무사할 수
없을 것입니다. 모르긴 해도 파악조차 힘들만큼 엄청 많겠지요. 그렇기 때문에 public 데이
터 멤버는 완전히 사용자에게 누드쇼를 한 거나 다름없습니다. 자 이젠 어떤 protected
데이터 멤버를 제거한다고 가정해 봅시다. 이번엔 코드가 얼마나 망가질까요? 이것을 사용하
는 파생 클래스는 전부... 짐작하시겠죠? 역시 파악조차 힘들만큼 많겠죠. 조금 가렸다고 가린
게 아닙니다. protected 데이터 멤버나 public 멤버나 오십보 백보란 말입니다. 이
데이터 멤버가 바뀌면 이 멤버에 의존하는 다른 코드들이 헤아릴 수 없으리만치 망가지는 것은
마찬가지이기 때문입니다. 아무리 생각해도 직관적으로 말이 안 될 겁니다. 하지만 라이브러
리 구현 경험이 굉장히 많은 개발자가 말하는 것을 한 번 들어 보세요. 정말입니다. 어떤 데
이터 멤버를 일단 public 혹은 protected로 선언했으며 사용자가 그것을 사용하기 시
작했으면, 그때부터 그 멤버는 완전히 코 꿰인 겁니다. 그 멤버에 대해 무엇을 바꾸기란 무
척 힘들어진단 말씀입니다(혹시 바꿨다면). 엄청난 양의 코드를 다시 써야 할 것이고, 테스트
도 다시 해야 하고, 문서도 바꿔야 하고, 컴파일도 다시 해야 할 것입니다. 캡슐화의 관점에
서 쓸모 있는 접근 수준은 private(캡슐화 제공)와 private가 아닌 나머지(캡슐화 없음),
이렇게 둘뿐이라고 이 필자 목 놓아 외치는 바입니다.

이것만은 잊지 말자!
*	데이터 멈버는 private 멤버로 선언합시다. 이를 통해 클래스 제작자는 문법적으로
	일관성 있는 데이터 접근 통로를 제공할 수 있고, 필요에 따라서는 세밀한 접근 제어도
	가능하며, 클래스의 불변속성을 강화할 수 있을 뿐 아니라, 내부 구현의 융통성도 발휘할
	수있습니다.
*	protected는 public보다 더 많이 '보호'받고 있는 것이 절대로 아닙니다.