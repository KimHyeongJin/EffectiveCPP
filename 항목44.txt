항목 44: 매개변수에 독립적인 코드는 템플릿으로부터 분리시키자

템플릿은 코딩 시간 절약, 코드 중복 회피의 두 마리 토끼를 한꺼번에 잡아 주는 참으로 기 막힌 물건입니다. 
이를테면 멤버 함수가 15개나 되면서 생김새나 하는 일 모두 비슷비슷한 클래스 20개를 하나씩 손으로 타이
핑해야 하는 끔찍한 상상은 이제 안녕입니다. 클래스 템플릿 하나 써 놓고 나머지는 컴파일러에게 맡기면 여러
분에게 필요한 클래스 20개와 함수 300개가 인스턴스화되니까요(정확히 말하면, 클래스 템플릿의 멤버 함수는
이들이 실제로 시용될 때만 암시적으로 인스턴스회되기 때문에, 멤버 함수 300개를 손에 넣는다는 건 모든 함
수가 진짜로 쓰여야만 가능한 일입니다. 함수 템플릿은 또 어떻고요. 많고 많은 비슷한 함수를 다 작성할 필요
없이, 함수 템플릿 하나만 만들어 놓으면 이후는 컴파일러가 알아서 하는 것입니다. 정 말이지 과학기술의 승
리 아닙니까?

뭐, 승리는 승리입니다. 이따금 승리라서 그렇죠 아무 생각 없이 템플릿을 사용하면 템플릿의 적, 코드 비대화
(code bloat)가 초래될 수 있거든요. 똑같은(혹은 거의 똑같은) 내용의 코드와 데이터가 여러 벌로 중복되어 
이진 파일로 구워진다는 뜻입니다. 소스 코드만 보면 단정 하고 깔끔해 보이겠지만, 목적 코드의 모양새는 쭉쭉
빵빵이 아니라 뚱뚱흐느적 그 자체란 말씀이죠. 뚱뚱흐느적한 몸매의 코드가 각광 받을 날은 딸기덩굴에 수박이 
열린다 해도 오지 않을 것입니다. 그렇기 때문에 여러분은 이진 코드가 템플릿으로 인해 불어 터지는 불상사를 
미연에 방지할 방법을 알아둬야 한다, 이 말씀입니다.

우선적으로 써 볼 수 있는 방법이라면 글자만으로도 부담감이 꽃미남기수 팬클럽 언니들처럼 폭주해 올 것만 같
은 그 이름, 공통성 및 가변성 분석(commonality and variability analysis)이 있습니다. 그렇지만 사
실 이 아이디어가 부담스러울 건 하나도 없습니다. 템플릿을 전혀 쓰지 않았던 여러분의 지난 인생을 돌이켜 
보세요. 거창한 이름만 안 붙었을 뿐, 이미 여러분은 이런 분석을 항상 해 왔습니다.

여러분이 어떤 함수를 만들고 있다가 무심코 다른 함수를 봤는데, 지금 만들고 있는 함수의 구현 중 일부가 다
른 함수의 구현에도 똑같이 있더라는 사실을 알아챗다고 가정해 봅시다. 여러분은 지금 코드를 복제한 건가요? 
당연히 아닐 것입니다. 이제 여러분은 두 함수로부터 공통 코드를 뽑아내고, 이것을 별도의 새로운 함수에 넣은 
후, 이 함수를 기존의 두 함수가 호출하도록 코드를 수정하겠지요. 이 이야기를 '공통성 및 가변성 분석'에 빗
대어 다시 구성 하면, 여러분은 두 함수를 분석해서 공통적인 부분과 디른 부분을 찾은 후에 공통 부분은 새로
운 함수에 옮기고 다른 부분은 원래의 함수에 남겨둔 것입니다. 클래스의 경우도 비슷 합니다. 지금 만들고 있
는 클래스의 어떤 부분이 다른 클래스의 어떤 부분과 똑같다는 사실 을 발견한다면, 그 공통 부분을 양쪽에 두
지 않는 것이 맞는 코딩이겠지요. 즉, 공통 부분을 별도의 새로운 클래스에 옮긴 후, 클래스 상속 혹은 객체 
합성(항목 32, 38, 39 참조)을 사용 해서 원래의 클래스들이 공통 부분을 공유하도록 합니다. 원래의 두 클래
스가 제각기 갖고 있는 다른 부분[고유 부분(varying part)]은 원래의 위치에 남아 있게 됩니다.

템플릿을 작성할 경우에도 똑같은 분석을 하고 똑같은 방법으로 코드 중복을 막으면 됩니다만, 여러분의 뒤통수
를 노리는 뜻밖의 전개가 하나 있습니다. 템플릿이 아닌 코드에서는 코드 중복이 명시적입니다. 두 함수 혹은 
두 클래스 사이에 똑같은 부분이 있으면 눈으로 찾아낼 수 있디는 거죠. 반변, 템플릿 코드에서는 코드 중복이 
암시적입니다. 소스 코드에는 템플릿이 하나밖에 없기 때문에, 어떤 템플릿이 여러번 인스턴스화될 때 발생할 
수 있는 코드 중복을 여러분의 감각으로 알아채야 한다는 거죠. 따라서 피나는 수련은 필수이겠습니다.

설명이 너무 길었죠? 이제 예제입니다. 고정 크기의 정방행렬을 나타내는 클래스 템플릿을 하나 만들고 싶습니
다. 다른 기능들도 있긴 하지만 특히 이 클래스 템플릿은 역행렬 만들기 연산을 지원합니다.

template<typename T,	// T 타입의 객체를 원소로 하는 n행 n열의 행렬을 나타내는
		std::size_t n> // 템플릿 size_t 매개변수에 대한 이야기는 아래에서 확인하세요.
class SquareMatrix
{
public:
	...
	void invert();		// 주어진 행렬을 그 저장공간에서 역행렬로 만듭니다.
};

이 템플릿은 T라는 타입 매개변수도 받지만 size_t 타입의 비타입 매개변수(non-type parameter)인 n도 
받도록 되어 있습니다. 비타입 매개변수는 타입 매개변수보디는 덜 흔하 지만, C++에서 적법하게 인정되는 매
개변수입니다. 그리고 이 예제에서도 보셨듯이 무척 자연스럽게 쓸 수 있습니다.

자, 이제는 다음의 코드를 봐 주세요.

SquareMatrix<double, 5> sm1; 
...
sm1.invert(); // SquareMatrix<double, 5>::invert를 호출합니다.
SquareMatrix<double, 10> sm2;
...
sm2.invert(); // SquareMatrix<double, 10>::invert를 호출합니다.

이때 invert의 사본이 인스턴스화되는데, 만들어지는 사본의 개수가 두 개입니다. 이 둘은 같은 함수일 수가 
없습니다. 그도 그럴 것이, 한쪽은 5 x 5 행렬에 대해 동작할 함수이고, 다른 쪽은 10 x 10 행렬에 대해 
동작할 함수이기 때문이죠. 그렇지만 행과 열의 크기를 나타내는 상수만 빼면 두 함수는 완전히 똑같습니다. 
이런 현상이 바로 템폴릿을 포함한 프로그램이 코드 비대화를 일으키는 일반적인 형태 중 하나라고들 하죠.

사용하는 값이 5와 10인 것만 다르고 나머지는 한 글자 한 글자까지 빼다 박은 듯이 똑같은 두 함수가 눈에 
띈다면 여러분은 어떻게 하시겠어요? 그 값을 매개변수로 받는 별도의 함수를 만들고, 그 함수에 5와 10을 
매개변수로 넘겨서 호출하게 만들려는 자세가 진정한 개발자의 흔일 테지요. 그 혼이 바로 정답입니다. 
SquareMatrix 클래스에도 이것이 가능한데, 일단 다음과 같이 만듭니다.

template<typename T>		// 정방행렬에 대해 쓸 수 있는 크기에 독립적인 기본 클래스 
class SquareMatrixBase 
{ 
protected:
	...
	void invert(std::size_t matrixsize); // 주어진 크기의 행렬을 역행렬로 만듭니다. 
	...
};

template<typename T, std::size_t n> 
class SquareMatrix: private SquareMatrixBase<T> 
{ 
private: 
	using SquareMatrixBase<T>::invert; // 기본 클래스의 invert가 가려지는 것을 
										// 막기 위한 문장입니다. 항목 33을 보세요.
public:
	...
	void invert() { this->invert(n); } // invert의 기본 클래스 버전에 대해 
										// 인라인 호출을 수행합니다. "this->" 가 
										// 왜 여기에 있는지 궁금하시면 아래를 보세요.
};

행렬의 크기를 매개변수로 받도록 바뀐 invert 함수가 기본 클래스인 SquareMatrixBase에 들어 있는 것이 
여러분 눈에도 보일 것입니다. SquareMatrixBase가 템플릿인 것은 SquareMatrix와 마찬가지이지만, 행렬의 
원소가 갖는 타입에 대해서만 템플릿화 되어 있을 뿐이고 행렬의 크기는 매개변수로 받지 않는다는 것은 
SquareMatrix와 다릅니다. 따라서 같은 타입의 객체를 원소로 갖는 모든 정방행렬은 오직 한 가지의 
SquareMatrixBase 클래스를 공유하게 되는 것입니다. 다시 말해, 같은 원소 타입의 정방행렬이 사용하는 기본
클래스 버전의 invert 함수도 오직 한 개의 사본이란 말씀입니다.

SquareMatrixBase::invert 함수는 파생 클래스에서 코드 복제를 피할 목적으로만 마련한 장치이기 때문에, 
public 멤버가 아니라 protected 멤버로 되어 있다는 점도 일러둡니다. 참고로, 이 함수의 호출에 드는 추가 
비용은 하나도 없어야 합니다. 기본 클래스의 invert 함수를 호출하도록 구현된 파생 클래스의 invert 함수가
바로 인라인 함수이니까요(이 경우에는 암시적 인라인 함수입니다. 항목 30 참조). 또 이 함수의 본문을 보시면 
"this->" 표기가 붙어 있습니다. 항목 43에서 이야기한, 템플릿화된 기본 클래스(지금 보시는 
SquareMatrixBase<T> 같은)의 멤버 함수 이름이 파생 클래스에서 가려지는 문제를 피해 가기 위한 것인데, 
이미 그런 역할을 해주는 using 선언이 위쪽에 있으므로 불필요 한 부분이기도 합니다. 참, SquareMatrix와 
SquareMatrixBase 사이의 상속 관계가 private인 점도 놓치지 마세요. 기본 클래스를 사용한 데는 순전히 
파생 클래스의 구현을 돕기 위한 것 외엔 아무 이유도 없다는 사실을 콕 집어 드러내는 부분이 private 키워드
이니까요. SquareMatrixBase와 SquareMatrix의 어떤 개념적인 is-a 관계를 나타내려 했다면 private 상
속을 쓰지 않았겠지요(private 상속에 대한 자세한 이야기는 항목 39에서 읽으실 수 있습니다). 

좀 전에 '일단'이라고 말했듯이, 일단은 됐습니다. 아직 해결하지 못한 채로 들러붙어 있는 문제가 하나 남았는데, 
이제 살펴보도록 합시다. SquareMatrixBase::invert 함수는 자신이 상대할 데이터가 어떤 것인지를 어떻게 알 
수 있을까요? 정방행렬의 크기야 뭐 매개 변수로 받으니까 쉽게 알 수 있지만, 진짜 행렬을 저장한 데이터가 어디
에 있는지는 어떻게 아느냔 말입니다. 지금 이 정보를 아는 쪽은 파생 클래스밖에 없을 텐데요. 좋습니다. 그렇다
면, 기본 클래스 쪽에서 역행렬을 만들 수 있도록 '정방행렬의 메모리 위치'를 파생 클래스가 기본 클래스로 넘겨
주면 될 것 같은데요. 어떻게 할까요?

한 가지 방법은 SquareMatrixBase::invert 함수가 매개변수를 하나 더 받도록 만드는 것입니다. 이 매개변수
는 아마도 행렬 데이터가 들어있는 메모리 덩어리의 시작주소를 가리키는 포인터일 것이고요. 길게 생각할 필요도 
없이 이 방법은 아주 잘 돌아갈 것입니다. 하지만 SquareMatrix의 함수 중에 invert처럼 행렬 크기에 상관없는 
동작방식을 갖기 때문에 SquareMatrixBase에 옮겨 놓아야 하는 함수가 invert 하나만 있지는 않을 거라고요. 
이런 함수가 진짜로 몇 개 있다면, 이들 함수에는 행렬 내의 값을 담고 있는 메모리를 찾아낼 수단이 전부 필요하
겠지요. 각 함수마다 매개변수를 하나씩 더 달아 주면 어떻게든 해결은 되겠지만, 결국 이것은 
SquareMatrixBase에게 똑같은 정보를 되풀이 해서 알려 주는 꼴이란 말이죠. 암만 생각해도 이쯤 되면 이건 
아닌 듯합니다. 

다른 방법을 하나 더 궁리해 봅시다. 행렬 값(들)을 담는 메모리에 대한 포인터를 SquareMatrixBase가 저장하게 
하는 것입니다. 그리고 이 클래스 템플릿에 포인터도 저장하는 마당에 행렬 크기도 저장하지 않을 이유가 없죠. 이
것도 저장합니다. 결과적으로 다음과 같은 설계가 나올 것입니다.

template<typename T> 
class SquareMatrixBase 
{ 
protected:
SquareMatrixBase(std::size_t n, T *pMcm)	// 행렬 크기를 저장하고I 행렬 값에
			:size(n), pData(pMem) {}		// 대한 포인터를 저장합니다.
	void setDataPtr(T *ptr) { pDaLa = ptr; }		// pData에 다시 대입합니다. 
	...
private:
	std::size_t size;	// 행렬의 크기 
	T *pData;			// 행렬 값에 대한 포인터
};

이렇게 설계해 두면, (행렬 값을 담을) 메모리 할당 방법의 결정 권한이 파생 클래스 쪽으로 넘어가게 됩니다. 파생 
클래스를 만드는 사람에 따라, 행렬 데이터를 SquareMatrix 객체 안에 데이터 멤버로 직접 넣는 것으로 결정할 수
도 있겠지요.

template<typename T, std::size_t n> 
class SquareMatrix: private SquareMatrixBase<T>
{ 
public:
SquareMatrix():SquareMatrixBase<T>(n, data){}// 행렬 크기(n) 및 데이터 포인터를 기본 클래스로 올려보냅니다.
	...
private:	
	T data[n*n];
};

이렇게 파생 클래스를 만들면 동적 메모리 할당이 필요 없는 객체가 되지만, 객체 자체의 크기가 좀 커질 수 있습니다. 
이 방법이 마음에 들지 않는 사람은 각 행렬의 데이터를 힘에 둘 수도 있습니다.
