항목 44: 매개변수에 독립적인 코드는 템플릿으로부터 분리시키자

템플릿은 코딩 시간 절약, 코드 중복 회피의 두 마리 토끼를 한꺼번에 잡아 주는 참으로 기 막힌 물건입니다. 
이를테면 멤버 함수가 15개나 되면서 생김새나 하는 일 모두 비슷비슷한 클래스 20개를 하나씩 손으로 타이
핑해야 하는 끔찍한 상상은 이제 안녕입니다. 클래스 템플릿 하나 써 놓고 나머지는 컴파일러에게 맡기면 여러
분에게 필요한 클래스 20개와 함수 300개가 인스턴스화되니까요(정확히 말하면, 클래스 템플릿의 멤버 함수는
이들이 실제로 시용될 때만 암시적으로 인스턴스회되기 때문에, 멤버 함수 300개를 손에 넣는다는 건 모든 함
수가 진짜로 쓰여야만 가능한 일입니다. 함수 템플릿은 또 어떻고요. 많고 많은 비슷한 함수를 다 작성할 필요
없이, 함수 템플릿 하나만 만들어 놓으면 이후는 컴파일러가 알아서 하는 것입니다. 정 말이지 과학기술의 승
리 아닙니까?

뭐, 승리는 승리입니다. 이따금 승리라서 그렇죠 아무 생각 없이 템플릿을 사용하면 템플릿의 적, 코드 비대화
(code bloat)가 초래될 수 있거든요. 똑같은(혹은 거의 똑같은) 내용의 코드와 데이터가 여러 벌로 중복되어 
이진 파일로 구워진다는 뜻입니다. 소스 코드만 보면 단정 하고 깔끔해 보이겠지만, 목적 코드의 모양새는 쭉쭉
빵빵이 아니라 뚱뚱흐느적 그 자체란 말씀이죠. 뚱뚱흐느적한 몸매의 코드가 각광 받을 날은 딸기덩굴에 수박이 
열린다 해도 오지 않을 것입니다. 그렇기 때문에 여러분은 이진 코드가 템플릿으로 인해 불어 터지는 불상사를 
미연에 방지할 방법을 알아둬야 한다, 이 말씀입니다.

우선적으로 써 볼 수 있는 방법이라면 글자만으로도 부담감이 꽃미남기수 팬클럽 언니들처럼 폭주해 올 것만 같
은 그 이름, 공통성 및 가변성 분석(commonality and variability analysis)이 있습니다. 그렇지만 사
실 이 아이디어가 부담스러울 건 하나도 없습니다. 템플릿을 전혀 쓰지 않았던 여러분의 지난 인생을 돌이켜 
보세요. 거창한 이름만 안 붙었을 뿐, 이미 여러분은 이런 분석을 항상 해 왔습니다.

여러분이 어떤 함수를 만들고 있다가 무심코 다른 함수를 봤는데, 지금 만들고 있는 함수의 구현 중 일부가 다
른 함수의 구현에도 똑같이 있더라는 사실을 알아챗다고 가정해 봅시다. 여러분은 지금 코드를 복제한 건가요? 
당연히 아닐 것입니다. 이제 여러분은 두 함수로부터 공통 코드를 뽑아내고, 이것을 별도의 새로운 함수에 넣은 
후, 이 함수를 기존의 두 함수가 호출하도록 코드를 수정하겠지요. 이 이야기를 '공통성 및 가변성 분석'에 빗
대어 다시 구성 하면, 여러분은 두 함수를 분석해서 공통적인 부분과 디른 부분을 찾은 후에 공통 부분은 새로
운 함수에 옮기고 다른 부분은 원래의 함수에 남겨둔 것입니다. 클래스의 경우도 비슷 합니다. 지금 만들고 있
는 클래스의 어떤 부분이 다른 클래스의 어떤 부분과 똑같다는 사실 을 발견한다면, 그 공통 부분을 양쪽에 두
지 않는 것이 맞는 코딩이겠지요. 즉, 공통 부분을 별도의 새로운 클래스에 옮긴 후, 클래스 상속 혹은 객체 
합성(항목 32, 38, 39 참조)을 사용 해서 원래의 클래스들이 공통 부분을 공유하도록 합니다. 원래의 두 클래
스가 제각기 갖고 있는 다른 부분[고유 부분(varying part)]은 원래의 위치에 남아 있게 됩니다.

템플릿을 작성할 경우에도 똑같은 분석을 하고 똑같은 방법으로 코드 중복을 막으면 됩니다.