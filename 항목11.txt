항목11: operator에서는 자기대입에 대한 처리가 빠지지 않도록 하자

자기대입(self assignment)이란, 어떤 객체가 자기 자신에 대입 연산자를 적용하는 것을 말합니다.

class Widget{...};
Widget w;
...
w = w;//자기에 대한 대입

바보 같은 사람의 눈에나 문제가 없을 법한 코드 같지만, 이 코드는 적법한(legal) 코드 입니다.
즉, 제정신일 확률이 높은 사용자 쪽에서도 이렇게 할 수 있다는 소리죠. 
게다가 이 대입이란 연산이 그렇게 눈에 잘 띄는가 하면 그것도 아니라는 것이 더 큰 문제입니다. 
예를 들어, 

a[i] = a[j];//자기대입의 가능성을 아름드리 품은 문장

위의 문장은 i 몇 j가 같은 값을 갖게 되면 자기대입문이 됩니다.
또 아래 문장을 보시죠.

*px = *py;//자기대입의 가능성을 하나 가득 품은 문장

이 문장의 경우, px 및 py가 가리키는 대상이 같으면 자기대입이 되고 맙니다. 언뜻 보기에 명확하지 않은 이러한 자기대입이 생기는 이유는
여러 곳에서 하나의 객체를 참조하는 상태, 다시 말해 중복참조(aliasing)라고 불리는 것 때문입니다. 같은 타입으로 만들어진 객체 여러 개를 참조자 혹은
포인터로 물어 놓고 동작하는 코드를 작성할 때는 같은 객체가 사용될 가능성을 고려하는 것이 일반적으로 바람직한 자세가 되겠습니다.
사실, 같은 클래스 계통에서 만들어진 객체라 해도 굳이 똑같은 타입으로 선언할 필요까지는 없습니다. 파생 클래스 타입의 객체를 참조하거나 가리키는 용도로
기본 클래스의 참조자나 포인터를 사용하면 되니까요.

class Base {...};
class Derived : public Base {...};
void doSomthing(const Base& rb, Derived* pd);//rb 및 *pd 는 원래 같은 객체였을 수도 있습니다.

항목13 및 14에 나온 조언을 따른다면 여러분은 자원 관리 용도로 항상 객체를 만들어야 할 것이고, 이렇게 만든 자원 관리 객체들이 복사될 때 나름대로 잘 동작하도록 코딩할 게 분명합니다.
바로 이때 조심해야 하는 것이 대입 연산자입니다. 이 연산자는 여러분이 신경쓰지 않아도 자기대입에 대해 안전하게 동작해야 합니다. 하지만 자원 관리를 여러분의 가녀린 섬섬옥수로 완벽하게
하기란 참으로 거친 일이죠(여러분이 직접 자원 관리 클래스를 작성하고 있따면 어쩔 수 없이 해야 됩니다).
어쩌다 보면 자원을 사용하기 전에 덜컥 해제해 버릴 수도 있을지 모릅니다. 
예를 하나 들겠습니다. 동적 할당된 비트맵을 가리키는 원시 포인터를 데이터 멤버로 갖는 클래스를 하나 만들었다고 가정해 봅시다.

class Bitmap { . .. }; 
class Widget 
{ 
		...
	private: 
		Bitmap *pb; // 힙에 할당한 객체를 가리키는 포인터 
};

자, 이젠 겉보기에 멀쩡해 보이는 operator=의 구현 코드를 보시겠습니다. 의미적으로는 문제가 없을 것 같지만 자기 참조의 가능성이 있는 위험천만의 코드입니다(사실 예외에도 안 전하지 않지만, 이 부분은 조금 있다가 언급하겠습니다). 

Widget& Widget::operator=(const Widget& rhs) // 안전하지 않게 구현된 operator=
{
	delete pb;					// 현재의 비트맵 사용을 중지합니다. 
	pb = new Bitmap(*rhs.pb);	// 이제 rhs의 비트맵을 사용하도록 만듭니다. 
	return *this;				// 이 부분에 대해서는 항목 10을 참고하세요.	
}

여기서 찾을 수 있는 자기 참조 문제는 operator= 내부에서 *this(대입되는 대상)와 rhs가 같은 객체일 가능성이 있디는 것입니다. 
이것이 어째서 좋지 않을까요? 이 둘이 같은 객체이면, delete 연산자가 *this 객체의 비트맵에만 적용되는 것이 아니라 rhs의 객체까지 적용되어 버립니다. 
그러니까, 이 함수가 끝나는 시점이 되면 해당 Widget(자기 참조에 의해 변경되면 큰일 나는 바로 그 Widget) 객체는 자신의 포인터 멤버를 통해 물고 있던 객체가 어처구니없게도 삭제된 상태가 되는 불상사를 당하게 됩니다. 

이런 에러에 대한 대책은 예전부터 있어 왔습니다. 전통적인 방법은 operator=의 첫머리 에서 일치성 검사(identity test)를 통해 자기대입을 점검하는 것이죠.

Widget& Widget::operator=(const Widget& rhs)
{
	if(this == &rhs) return *this;//객체가 같은지, 즉 자기대입인지를 검사합니다.
									//자기대입이면 아무것도 안 합니다.
	delete pb;					
	pb = new Bitmap(*rhs.pb);	 
	return *this;					
}

어쨌든 이렇게 하면 되기는 하지만, 이전 버전의 operator= 이 자기대입에 안전하지 못할 뿐만 아니라 예외에도 안전하지 않다는 이야기를 필자가 써 놓은 게 혹시 기억나십니까? 
예외 안전성에 대해서는 이번 것도 여전히 문젯거리를 안고 있습니다. 특히 신경 쓰이는 부분 이 'new Bitmap' 표현식입니다. 
이 부분에서 예외가 터지게 되면(동적 할당에 필요한 메모 리가 부족하다든지 Bitmap 클래스 복사 생성자에서 예외를 던진다든지 해서), Widget 객체는 결국 삭제된 Bitmap을 가리키는 포인터를 껴안고 홀로 남고 맙니다. 
이런 포인터가 멋대로 떠다니게 놔두면 제대로 쥐약이겠죠? 이런 포인터는 delete 연산자를 안전하게 적용할 수도 없고, 안전하게 읽는 것조차 불가능합니다. 
단, 안전한 일이 하나 있긴 합니다. 이들이 대체 어느 구석에서 나온 건지 알아내는 데 속절없는 시간을 약속하는 무한 짜증 디버깅이죠.

우울한 이야기는 이것으로 마치죠 전부는 아니지만, 다행스럽게도 operator=을 예외에 안전하게 구현하면 대개 자기대입에도 안전한 코드가 나오게 되어 있습니다. 
그러니까, 예외 안전성에만 집중하면 자기대입 문제는 무시하더라도 무사히 넘어갈 확률이 높아진다는 것입니다. 
예외 안전성 이야기는 항목 29에서 지겹게 공부하실 수 있고요, 일단 이번 항목에서는 "많은 경우에 문장 순서를 세심하게 바꾸는 것만으로 예외에 안전한(동시에 자기대입에 안전한) 코드가 만들어진다"라는 법칙 한 가지를 여기서 써먹어 보도록 하겠습니다. 
지금의 코드는, pb를 무턱대고 삭제하지 말고 이 포인터가 가리키는 객체를 복사한 직후에 삭제하면 깔끔히 해결될 것 같습니다. 아래를 보시죠

Widget& Widget::operator=(const Widget& rhs)
{
	Bitmap* pOrig = pd;			//원래의 pb를 어딘가에 저장해 둡니다.
	pb = new Bitmap(*rhs.pb);	//다음 pb가 *pb의 사본을 가리키게 만듭니다.
	delete pOrig;				//원래의 pb를 삭제합니다.

	return *this;					
}

이 코드는 이제 예외에 안전합니다 'new Bitmap' 부분에서 예외가 발생하더라도 pb(그리고 이 포인터가 들어 있는 Widget)는 변경되지 않은 상태가 유지되기 때문이죠. 
게다가 일치성 검사 같은 것이 없음에도 불구하고 이 코드는 자기대입 현상을 완벽히 처리하고 있습나다. 
원본 비트랩을 복사해 놓고, 복사해 놓은 사본을 포인터가 가리키게 만든 후, 원본을 삭제하는 순서로 실행되기 때문입니다. 
물론 이 방법이 자기대입을 처리하는 가장 효율적인 방법이라고는 할 수 없겠지만, 동작에는 이무 문제가 없습니다.

효율이 너무나 신경 쓰인 나머지, 일치성 테스트를 함수 앞단에 도로 붙여 놓고 싶은 분도 계실 겁니다. 
그런데 잠시만요 행동으로 옮기기 전에 곰곰이 생각해 보세요. 여러분 프로그 램에서 자기대입이 얼마나 지주 일어날까요? 이런 이야기를 하는 이유는, 일치성 테스트 역시 공짜가 아니기 때문입니다. 
일치성 검사 코드가 들어가면 그만큼 코드(소스 코드와 목적 코드 둘 다)가 커지는데다가， 처리 흐름에 분기를 만들게 되므로 실행 시간 속력이 덜컥덜컥 줄어들 수 있습니다. 
CPU 명령어 선행인출(instruction prefetch), 캐시, 파이프라이닝 등의 효과도 떨어질 수 있고요.

예외 안전성과 자기대입 안전성을 동시에 가진 operator=을 구현히는 방법으로, 방금 본 예처럼 문장의 실행 순서를 수작업으로 조정하는 것 외에 다른 방법을 하나 더 알려드리겠 습니다. 
'복사 후 맞바꾸기(copy and swap)'라고 알려진 기법인데, 이 기법은 사실 예외 안전성과 아주 밀접한 관계에 있기 때문에 항목 29에 자세히 설명되어 있습니다. 
하지만 이 기법은 operator= 작성에 아주 자주 쓰이기 때문에 어떤 식으로 구현하는지만 여기서 보셔도 굉장히 도움이 될 것입니다.

class Widget 
{ 
	...
	void swap(Widget& rhs);//*this의 데이터 및 rhs의 데이터를 맞바꿉니다. 자세한 내용은 항목 29에서 확인하세요.
	...
};
Widget& Widget::operator=(const Widget& rhs)
{
	Widget temp(rhs);					// rhs의 데이터에 대해 사본을 하나 만듭니다.
	swap(temp);							// *this의 데이터를 그 사본의 것과 맞바꿉니다.
	return *this;
}

이 방법은 C++가 가진 두 가지 특정을 활용해서 조금 다르게 구현할 수도 있습니다. 
1.클래스의 복사 대입 연산자는 인자를 값으로 취하도록 선언하는 것이 가능하다는 점과 2.값에 의한 전달을 수행하면 전달된 대상의 사본이 생긴다는 점(항목 20 참조)을 이용하는 것이죠 보세요.

Widget& Widget::operator=(const Widget& rhs)//rhs는 넘어온 원래 객체의 사본입니다.
{											//-'값에 의한 전달'이라고 했죠?
	swap(temp);							// *this의 데이터를 그 사본의 데이터와 맞바꿉니다.
	return *this;
}

개인적으로 이 코드는 조금 걱정되기도 합니다. '솜씨'라는 이름의 제단에서 명확성을 제물로 바치는 격이니까요.
하지만 객체를 복사하는 코드가 함수 본문으로부터 매개변수의 생성자로 옮겨졌기 때문에, 컴파일러가 더 효율적인 코드를 생성할 수 있는 여지가 만들어지는 것은 사실입니다.

이것만은 잊지 말자! 
1. operator=을 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만듭시다. 원본 객체와 복사대상 객체의 주소를 비교해도 되고 문장의 순서를 적절히 조정할 수도 있으며, 복사 후 맞비꾸기 기법을 써도 됩니다. 
2. 두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 합수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인해 보세요.