항목11: operator에서는 자기대입에 대한 처리가 빠지지 않도록 하자

자기대입(self assignment)이란, 어떤 객체가 자기 자신에 대입 연산자를 적용하는 것을 말합니다.

class Widget{...};
Widget w;
...
w = w;//자기에 대한 대입

바보 같은 사람의 눈에나 문제가 없을 법한 코드 같지만, 이 코드는 적법한(legal) 코드 입니다.
즉, 제정신일 확률이 높은 사용자 쪽에서도 이렇게 할 수 있다는 소리죠. 
게다가 이 대입이란 연산이 그렇게 눈에 잘 띄는가 하면 그것도 아니라는 것이 더 큰 문제입니다. 
예를 들어, 

a[i] = a[j];//자기대입의 가능성을 아름드리 품은 문장

위의 문장은 i 몇 j가 같은 값을 갖게 되면 자기대입문이 됩니다.
또 아래 문장을 보시죠.

*px = *py;//자기대입의 가능성을 하나 가득 품은 문장

이 문장의 경우, px 및 py가 가리키는 대상이 같으면 자기대입이 되고 맙니다. 언뜻 보기에 명확하지 않은 이러한 자기대입이 생기는 이유는
여러 곳에서 하나의 객체를 참조하는 상태, 다시 말해 중복참조(aliasing)라고 불리는 것 때문입니다. 같은 타입으로 만들어진 객체 여러 개를 참조자 혹은
포인터로 물어 놓고 동작하는 코드를 작성할 때는 같은 객체가 사용될 가능성을 고려하는 것이 일반적으로 바람직한 자세가 되겠습니다.
사실, 같은 클래스 계통에서 만들어진 객체라 해도 굳이 똑같은 타입으로 선언할 필요까지는 없습니다. 파생 클래스 타입의 객체를 참조하거나 가리키는 용도로
기본 클래스의 참조자나 포인터를 사용하면 되니까요.

class Base {...};
class Derived : public Base {...};
void doSomthing(const Base& rb, Derived* pd);//rb 및 *pd 는 원래 같은 객체였을 수도 있습니다.

항목13 및 14에 나온 조언을 따른다면 여러분은 자원 관리 용도로 항상 객체를 만들어야 할 것이고, 이렇게 만든 자원 관리 객체들이 복사될 때 나름대로 잘 동작하도록 코딩할 게 분명합니다.
바로 이때 조심해야 하는 것이 대입 연산자입니다. 이 연산자는 여러분이 신경쓰지 않아도 자기대입에 대해 안전하게 동작해야 합니다. 하지만 자원 관리를 여러분의 가녀린 섬섬옥수로 완벽하게
하기란 참으로 거친 일이죠(여러분이 직접 자원 관리 클래스를 작성하고 있따면 어쩔 수 없이 해야 됩니다.)