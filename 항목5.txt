항목 5: C++가 은글슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자

클래스가 비어 있지만(empty) 비어 있는 게 아닌 때가 있습니다. 언제일까요? 일단은 C++
(컴파일러)가 빈 클래스를 훑고 지나갈 때라고 말씀드릴 수 있겠네요. C++의 어떤 멤버 함
수는 여러분이 클래스 안에 직접 선언해 넣지 않으면 컴파일러가 저절로 선언해 주도록 되
어 있습니다. 바로 복사 생성자(copy constructor), 복사 대입 연산자(copy assignment
operator), 그리고 소멸자(destructor) 인데, 좀더 자세히 말하면 이때 컴파일러가 만드는 함수
의 형태는 모두 기본형입니다. 게다개 생성자조차도 선언되어 있지 않으면 역시 컴파일러가
여러분 대신에 기본 생성자를 선언해 놓습니다. 이들은 모두 public 멤버 이며 inline 
함수입니다(항목 30 참조). 그러니까, 여러분이 다음과 같이 썼다면

class Empty {};

다음과 같이 쓴 것과 근본적으로 대동소이하다는 이야기입니다.

class Empty
{
public:
	Empty(){...}				// 기본 생성자
	Empty(const Empty&rhs){...}	// 복사 생성자
	~Empty(){...}				// 소멸자: 가상 함수 여부에 대해서는
								// 아래에서 더 자세히 설명하겠습니다.
	Empty& operator=(const Empty& rhs){...} // 복사 대입 연산자 };

이들은 꼭 필요하다고 컴파일러가 판단할 때만 만들어지도록 되어 있지만, 요한 건이
그리 대단한 것도 아닙니다 이들이 만들어지는 조건을 만족하는 코드는 다음과 같습니다 

Empty e1 ;		// 기본 생성자, 그리고
				// 소멸자

Empty e2(e1);	// 복사 생성자

e2 = e1;		// 복사 대입 연산자 

이렇게 여러분 대신 컴파일러가 함수를 만들어 주기는 하나 봅니다. 그렇다면 컴파일러가
만드는 함수가 하는 일이 대체 무엇이기에 저절로 만들어지기까지 하는 걸까요? 기본 생성
자와 소멸자가 하는 일은 일차적으로 컴파일러에게 "배후의 코드"를 깔 수 는 자리를 마
련하는 것입니다. 기본 클래스 및 비정적 데이터 멤버의 생성자와 소멸자를 호출하는 코드
가 여기서 생기는 거지요. 이때 소멸자는 이 클래스가 상속한 기본 클래스의 소멸자가 가상
소멸자로 되어 있지 않으면 역시 비가상 소멸자로 만들어진다는 점(항목 7 )을 꼭 짚고
가야겠습니다(소멸자의 가상성을 기본 클래스로부터 물려받는 경우에 말이죠).

복사 생성자와 복사 대입 연산자의 경우에는 어떨까요? 컴파일러가 몰래 만들어낸 복사 생
성자 복사 대입 연산자가 하는 일은 아주 단순합니다. 원본 객체의 비정적 데이터를 사본
객체 쪽으로 그냥 복사하는 것이 전부이지요. 이해를 돕논 의미에서, 임의의 이름을 T 타입
의 객체에 연결시켜 주는 NamedObject 라는 템플릿을 예제로 준비해 보았습니다.

