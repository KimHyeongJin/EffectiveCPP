항목 52: 위치지정 new를 작성한다면 위치지정 delete도 같이 준비하자.

위치지정 new와 위치지정 delete로 말할 것 같으면, C++ 대공원 안에서 시도 때도 없
이 관람차에 엉겨 붙는 흔한 맹수류는 절대로 아닙니다. 이들에 대해서 이 항목을 일기 전
까지 잘 모르고 있었다 해도 그다지 걱정할 것은 없다는 이야기죠. 그 대신, 다음과 같은
new 표현식을 썼을 때 호출되는 함수가 두 개라고 이야기한 항목 16 및 항목 17의 내용부
터 머리에 올려놓고 시작합시다.

Widget* pw = new Widget;

말씀드린 대로, 위에서는 함수 두 개가 호출됩니다. 우선 메모리 할당을 위해 operator new
가 호출되고, 그 뒤를 이어 Widget의 기본 생성자가 호출되지요.

여기서, 첫 번째 함수 호출은 무사히 지나갔는데 두 번째 함수 호출이 진행되다가 예외가
발생했다고 가정해 봅시다. 이렇게 사고가 나 버렸을 경우, 첫 단계에서 이미 끝난 메모리
할당을 어떻게 해서든 취소하지 않으면 안 됩니다. 그냥 뒀다간 메모리 누수은 불 보듯 뻔
하니까요. 사용자 코드에서는 이 메모리를 해제할 수 없습니다. Widget 생성자에서 예외가
튀어나오면 pw에 포인터가 대입될 일은 절대로 안 생기기 때문입니다. 어떻게든 해제해야
하는 이 메모리에 대한 포인터를 사용자 코드에서 물어 올릴 방법은 마땅히 없을 것 같습니
다. 따라서 1단계의 메모리 할당을 안전하게 되돌리는 중대 임무는 C++ 런타임 시스템께서
맡아 주시게 됩니다.

이때 C++ 런타임 시스템이 해 주어야 하는 일은 1단계에서 자신이 호출한 operator new
함수와 짝이 되는 버전의 operator delete 함수를 '즐겁게' 호출하는 것인데, 하지만
이게 제대로 되려면 operator delete 함수들 가운데(경우에 따라선 많이 있을 수 있죠)
어떤 것을 호출해야 하는지를 런타임 시스템이 제대로 알고 있어야만 가능합니다. 하지만
여러분이 상대하고 있는 new/delete가 기본형(우리가 지금까지 앞에서 본 바 있는) 시그
너처로 되어 있는 한 이 부분은 그다지 대수로운 사안은 아닙니다. 왜냐하면 기본형
operator new는

void* operator new(std::size_t) throw(std::bad_alloc);

역시 기본형 operator delete와 짝을 맞추기 때문입니다.

// 전역 유효범위에서의 기본형 시그너처
void* operator delete(void* rawMemory) throw();	

// 클래스 유효범위에서의 전형적인 기본형 시그너처
void* operator delete(void* rawMemory, std::size_t size) throw();

따라서 표준 형태의 new 및 delete만 사용하는 한, 런타임 시스템은 new의 동작을 되돌
릴 방법을 알고 있는 delete를 찾아내는 데 있어서 아무런 고민을 하지 않습니다. 그런데
operator new의 기본형이 아닌 형태를 선언하기 시작하면 이른바 '이 new에 어떤 delete
를 짝맞춰야 되지?' 문제가 발생하게 됩니다. 비기보녕이란 바로 다른 매개변수를 추가로
갖는 operator new를 뜻합니다.