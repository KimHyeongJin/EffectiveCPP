항목 52: 위치지정 new를 작성한다면 위치지정 delete도 같이 준비하자.

위치지정 new와 위치지정 delete로 말할 것 같으면, C++ 대공원 안에서 시도 때도 없
이 관람차에 엉겨 붙는 흔한 맹수류는 절대로 아닙니다. 이들에 대해서 이 항목을 일기 전
까지 잘 모르고 있었다 해도 그다지 걱정할 것은 없다는 이야기죠. 그 대신, 다음과 같은
new 표현식을 썼을 때 호출되는 함수가 두 개라고 이야기한 항목 16 및 항목 17의 내용부
터 머리에 올려놓고 시작합시다.

Widget* pw = new Widget;

말씀드린 대로, 위에서는 함수 두 개가 호출됩니다. 우선 메모리 할당을 위해 operator new
가 호출되고, 그 뒤를 이어 Widget의 기본 생성자가 호출되지요.

여기서, 첫 번째 함수 호출은 무사히 지나갔는데 두 번째 함수 호출이 진행되다가 예외가
발생했다고 가정해 봅시다. 이렇게 사고가 나 버렸을 경우, 첫 단계에서 이미 끝난 메모리
할당을 어떻게 해서든 취소하지 않으면 안 됩니다. 그냥 뒀다간 메모리 누수은 불 보듯 뻔
하니까요. 사용자 코드에서는 이 메모리를 해제할 수 없습니다. Widget 생성자에서 예외가
튀어나오면 pw에 포인터가 대입될 일은 절대로 안 생기기 때문입니다. 어떻게든 해제해야
하는 이 메모리에 대한 포인터를 사용자 코드에서 물어 올릴 방법은 마땅히 없을 것 같습니
다. 따라서 1단계의 메모리 할당을 안전하게 되돌리는 중대 임무는 C++ 런타임 시스템께서
맡아 주시게 됩니다.

이때 C++ 런타임 시스템이 해 주어야 하는 일은 1단계에서 자신이 호출한 operator new
함수와 짝이 되는 버전의 operator delete 함수를 '즐겁게' 호출하는 것인데, 하지만
이게 제대로 되려면 operator delete 함수들 가운데(경우에 따라선 많이 있을 수 있죠)
어떤 것을 호출해야 하는지를 런타임 시스템이 제대로 알고 있어야만 가능합니다. 하지만
여러분이 상대하고 있는 new/delete가 기본형(우리가 지금까지 앞에서 본 바 있는) 시그
너처로 되어 있는 한 이 부분은 그다지 대수로운 사안은 아닙니다. 왜냐하면 기본형
operator new는

void* operator new(std::size_t) throw(std::bad_alloc);

역시 기본형 operator delete와 짝을 맞추기 때문입니다.

// 전역 유효범위에서의 기본형 시그너처
void* operator delete(void* rawMemory) throw();	

// 클래스 유효범위에서의 전형적인 기본형 시그너처
void* operator delete(void* rawMemory, std::size_t size) throw();

따라서 표준 형태의 new 및 delete만 사용하는 한, 런타임 시스템은 new의 동작을 되돌
릴 방법을 알고 있는 delete를 찾아내는 데 있어서 아무런 고민을 하지 않습니다. 그런데
operator new의 기본형이 아닌 형태를 선언하기 시작하면 이른바 '이 new에 어떤 delete
를 짝맞춰야 되지?' 문제가 발생하게 됩니다. 비기보녕이란 바로 다른 매개변수를 추가로
갖는 operator new를 뜻합니다.

예를 하나 들어 볼까요? 어떤 클래스에 대해 전용으로 쓰이는 operator new를 만들고
있는데, 메모리 할당 정보를 로그로 기록해 줄 ostream을 지정받는 꼴로 만든다고 가정합
시다. 그리고 클래스 전용 operator delete는 기본형으로 만든다고 가정하죠.

class Widget
{
	public:
		...
		// 비표준 형태의 operator new
		static void* operator new(std::size_t size, 
						std::ostream& logStream) throw(std::bad_alloc);
		// 클래스 전용 operator delete의 표준 형태
		static void operator delete(void* pMemory, 
									std::size_t size) throw();
		...
};

이미 예상하신 분도 계시겠지만 이 설계에는 문제가 있습니다. 그렇지만, 어째서 문제가 있
는 것인지는 조금 뒤에 알아보기로 해요. 우선 살짝만 옆길로 빠쪄서 용어를 정리해 보는 
시간이 필요할 것 같습니다.

operator newg 함수는 기본형과 달리 매개변수를 추가로 받는 형태로도 선언할 수 있습
니다. 이런 형태의 함수를 가리키는 말이 따로 있는데, 이것이 바로 위치지정(placement)
new입니다. 위에서 보신 operator new는 그러니까 위치지정 버전이라 부르면 되겠습
니다. 말씀드렸듯이 위치지정 new는 개념적으로 그냥 '추가 매개변수를 받는 new'이므로
위치지정 new는 가지각색일 수 있지만, 이들 중 특히 유용한 놈이 하나 있습니다. 어떤 객
체를 생성시킬 메모리 위치를 나타내는 포인터를 매개변수로 받는 것이 바로 그 주인공인데,
생김새는 다음과 같습니다.

// 위치지정 new
void* operator new(std::size_t, void* pMemory) throw();

이렇게 포인터를 추가로 받는 형태의 위치지정 new는 그 유용성을 인정받아 이미 C++ 표
준라이브러리의 일부로도 들어가 있습니다. #include <new>만 하면 여러분도 바로 쓰실
수 있어요. 이 버전의 new 함수는 표준 라이브러리의 여러 군데에서 쓰이고 있는데, 특히
vector의 경우에는 해당 벡터의 미사용 공간에 원소 객체를 생성할 때 이 위치지정 new
를 쓰고 있습니다. 또한 위치지정 new의 원조이기도 합니다. 매개변수를 추가로 받는
new를 위치지정 new라고 부르게 된 것도 사실 이 원조 버전 때문입니다. 어떻게 보면 이
"위치지정 new"라는 용어도 '오버로딩'된 셈이네요. 사람들이 위치지정 new를 이야기 주제
로 꺼낸다면 아마도 원조 버전, 그러니까 void* 타입의 매개변수 하나를 추가로 받는 
operator new를 뜻하는 경우가 대부분일 것입니다. 원조 버전 이야기인지 아닌지는 전
후관계로 쉽게 알 수 있으니 헷갈리진 않을 테지만, 어쨌든 일반적인 의미의 "위치지정
new"라는 용어는 어떤 매개변수라도 추가로 받아들이는 operator new를 나타낸다는 사
실은 유념해 두셔야 하겠습니다. 왜냐하면 "위치지정 delete"(조금 뒤에 보게 될 거예요.)
가 또 이 개념에서 갈라져 나오거든요.

긴 이야기 듣느라 수면뇌파가 가득한 머리를 추스르고 다시 Widget 클래스로 되돌아옵시
다. 기억나시죠? 설계에 문제가 많다고 말씀드린 바로 그 Widget 클래스 말입니다. 이 클
래스는 나중에 해결해 보려면 몇 가닥 남지도 않은 머리털을 쥐어뜯어야 할지도 모르는 메
모리 누출을 유발할 수 있습니다. 이 클래스를 사용한 사용자 코드를 하나 보시죠. Widget
객체 하나를 동적 할당할 때 cerr에 할당할 정보를 로그로 기록하는 코드입니다.

// operator new를 호출하는 데 cerr을 ostream 인자로 넘기는데, 이때 Widget
// 생성자에서 예외가 발생하면 메모리가 누출됩니다.
Widget* pw = new (std::cerr) Widget;	

자, 다시 시작합니다. 메모리 할당은 성공했지만 Widget 생성자에서 예외가 발생했을 경
우, 앞에서 말씀드린 대로 operator new에서 저지른 할당을 되돌리는 일은 C++ 런타임
시스템이 책임지고 해야 합니다. 그런데 런타임 시스템 쪽에는 호출된 operator new가
어떻게 동작하는지를 알아낼 방법이 없으므로, 자신이 할당 자체를 되돌릴 수는 없습니다.
그 대신, 런타임 시스템은 호출된 operator new가 받아들이는 매개변수의 개수 및 타입이
똑같은 버전의 operator delete를 찾고, 찾아냈으면 그 녀석을 호출합니다. 지금 경우
에 호출된 operator new는 ostream& 타입의 매개변수를 추가로 받아들이므로, 이것
과 짝을 이루는 operator delete 역시 똑같은 시그너처를 가진 것이 마련되어 있어야
하겠지요.

// 위치지정 delete
void* operator delete(void*, std::ostream&) throw();