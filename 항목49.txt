8 new와 delete를 내 맘대로

가비지 컬렉션(garbagc collection) 기능을 아예 하단에 놓고 기본적으로 지원하는 프로그래밍 
환경들(예를 들면 자바나 닷넷 등)이 저마다의 매력을 뿜어내는 요즘, 여전히 "수동"만을 고수하는 
C++의 메모리 관리 방법은 어떻게 보면 구닥다리로 보일 수 있습니다. 그 럼에도 불구하고 이주 
중요한 시스템 응용프로그램을 제작하는 전 세계의 수많은 개발자들은 메모리를 수동으로 관리할 수 
있다는 점 때문에 주저 없이 C++를 선택하고 있죠. 이쪽 개발자들은 일단 자신들이 만들 소프트웨
어의 메모리 사용 성향을 연구한 후에, 그 연구 결 과에 맞추어 메모리 할당 루틴과 해제 루틴을 
다듬음으로써 가능한 최대의 수행 성능(시간 및 공간 모두에서)을 제공하려고 애쓰고 있습니다.

개발자로서 이런 작업이 가능하려면 일단 C++의 메모리 관리 루틴이 어떻게 동작하는지를 변밀히 
파악해 두는 것이 착한 자세라 할 수 있겠는데요, 그 '어떻게'가 바로 이 장의 초점입니다. 이번 
항목에서 벌어질 각종 경기에서 열심히 뛰어 줄 주전 선수는 메모리 할당 및 해제 루틴(operator 
new 및 operator delete)입니다. 여기에 new 처리자(new-handler)의 불꽃 튀는 도움도 예
상되는데요, 이 함수는 사용자의 메모리 요구를 operator new가 맞추어 주지 못했을 때 호출되
는 함수입니다.

다중스레드 환경에서의 메모리 관리는 단일 스레드 시스템에서는 경험할 수 없는 화끈한 맛을 느끼
게 하는 여러 가지 문제거리를 안고 있습니다. 힙은 수정이 가능한 전역 자원으로 분류되거든요. 
다중스레드 시스템에서는 스레드들이 이런 전역 자원에 미친듯이 접근하면서 경쟁 상태가 생길 소
지가 많다고 생각하시면 되겠습니다. 이번 장을 보시면 수정 가능한 정적 데이터의 사용법에 대해 
이야기한 항목을 꽤 많이 만나게 되는데, 스레드를 좀 아는 프로그래머에게 있어서 수정 가능한 정
적 데이터는 항상 머리털이 바짝 설 정도로 중요한 존재입니다. 이 부분에 적절한 동기화를 걸지 
않으면, 스레드 잠금에 영향을 받지 않는 어떤 알고리즘을 쓰든, 동시 접근을 막는 어떤 세심한 설
계를 적용하든, 아무런 소용이 없습니다. 언제라도 메모리 루틴을 호출하는 순간이 오면 힙으로 관
리되는 자료구조에 흙탕물을 튀기는 물줄기가 활짝 열릴 수 있으나 말입니다. 제 머리에 떠오를 때
마다 이런 살별한 현실을 여러분 귀에다 대고 목 아프게 울부짖느니, 차라리 여기서 딱 부러지게 
이야기를 끝내고 이후에는 여러분이 알아서 뱃속에 새겼거니 하고 생각하렵니다.

여러분이 C++로 밥을 먹고 사는 이상 잊지 말아야 할 부분이 또 있습니다. operator new 및 
operator delete는 객체 한 개를 할당할 때만 적용되는 함수라는 점입니다. 배열을 담을 메모리
의 경우, 할당할 때는 operator new [] 를 쓰고 해제할 때는 operator delete [] 를 씁니다
(할당 및 해제용 함수 이름에 모두 "[]" 부분이 있다는 점, 놓치지 마세요). 다른 경우를 특별히 
지정하지 않는 한, operator new 및 operator delete에 대해 이야기한 것은 operator new[] 
및 operator delete[] 에도 똑같 이 적용됩니다.

끝으로, STL 컨테이너에 대한 힙 메모리 관리에 대한 이야기입니다. 이 부분은 해당 컨테이 너의 
할당자 객체의 소관이며, new와 delete는 직접 개입하지 않습니다. STL 할당자에 대해서는 이 
장에서 드릴 이야기가 없다는 점도 미리 일러두고 싶네요1)

::1)STL 할당자에 관한 이야기는 같은 지은이의 "ESTL"에서 참고하기 바란다-옮긴이




항목 49: new 처리자의 동작 원리를 제대로 이해하자 

사용자가 보낸 메모리 할당 요청을 operator new 함수가 맞추어 주지 못할 경우에(즉, 할당할 
메모리가 없을 때) operator new 함수는 예외를 던지게 되어 있습니다. 옛날에는 널 포인터를 반
환했었죠. 구닥다리 컴파일러를 쓰는 환경에서는 여전히 경험하실 수 있을 것입니다. 사실 요즘도 
옛날 스타일의 동작을 사용할 수 없는 것은 아니지만, 이 부분 에 대한 이야기는 이번 항목이 끝날 
즈음으로 미루어 둡시다.

메모리 할당이 제대로 되지 못한 상황에 대한 반응으로 operator new가 예외를 던지기 전에, 이 
함수는 사용자 쪽에서 지정할 수 있는 에러 처리 함수를 우선적으로 호출하도록 되어 있는데, 이 에러 
처리 함수를 가리켜 new 처리자(new-handler, 할당에러 처리자)라고 합니다(사실 완전히 맞는 것은 
아닙니다. operator new의 동작은 이보다 좀더 복잡하거든요. 자 세한 이야기는 항목 51에서 보실 
수 있습니다). 이와 같은 메모리 고갈 상황을 처리할 함수를 사용자 쪽에서 지정할 수 있도록, 표준 
라이브러리에는 set_new_handler라는 함수가 준비되어 있습니다. 이 함수는 <new>에 선언되어 있
고요.

namespace std
{
	typedef void(*new_handler)();
	new_handler set_new_handler(new_handler p) thorw();
}

여러분도 보셨겠지만 new_handler는 받는 것도 없고 반환하는 것도 없는 함수의 포인터에 대해 
typedef를 걸어 놓은 타입동의어입니다. 그리고 set_new_handler는 new_handler를 받고 
new_handler를 반환하는 함수이죠[set_new_handler의 선언문 끝에 있는 "throw()"는 예외 지정
(exception specification)이라고 불리는 부분입니다. 풀이하면 이 함수는 어떤 예외도 던지지 
않을 것이라는 뜻입니다. 실상은 좀더 재미있지만 말이죠 궁금하신 분 은 항목 29를 읽어 보세요].

set_new_handler가 받아들이는 new_handler 타입의 매개변수는 요구된 메모리를 operator new가 
할당하지 못했을 때 operator new가 호출할 함수의 포인터입니다. 반환 값은 지금의 set_new_handler
가 호출되기 바로 전까지 new 처리자로 쓰이고 있던 함수의 포인터입니다. 

// 충분한 메모리를 operator new가 할당하지 못했을 때 호출할 함수
void outOfMem()
{
	std::cerr<<"Unable to satisfy request for memory\n";
	std::abort();
}

int main()
{
	std::set_new_handler(outOfMem);
	int* pBigDataArray = new int[100000000L];
	...
}

만약 operator new가 1억 개의 정수 할당에 실패하면 outOfMem 함수가 호출될 것이 고, 이 함수는 
에러 메시지를 출력하면서 프로그램을 강제로 끝내 버릴 것입니다(그런데 cerr에 에러 메시지를 쓰는 
과정에서 또 메모리가 동적으로 할당되어야 한다면 어떻게 될까요? 잠깐만 생각해 보세요).

사용자가 부탁한 만큼의 메모리를 할당해 주지 못하면, operator new는 충분한 메모리를 찾아낼 때
까지 new 처리자를 되풀이해서 호출합니다. new 처리자를 반복 호출하는 코드는 항목 51에서 그 자
세한 모양새를 보게 되겠지만, 응용프로그램 개발자 입장에서는 굳이 이 부분까지는 내려가지 않아도 
됩니다. 어쨌든 이를 통해 호출'되는' new 처리자 함수가 프로그램의 동작에 좋은 영향을 미치는 쪽
으로 설계되어 있다면 다음 동작 중 하나를 꼭 해 주어야 한디는 점만 잘 알아두십시오.

* 사용할 수 있는 메모리를 더 많이 확보합니다.
operator new가 시도하는 이후의 메모리 확보가 성공할 수 있도록 하자는 전략입니다. 구현 방법은 
여러 가지가 있지만, 프로그램이 시작할때 메모리 블록을 크게 하나 할당해 놓았다가 new 처리자가 
가장 처음 호출될 때 그 메모리를 쓸 수 있도록 허용하는 방법이 그 한 가지입니다.

* 다른 new 처리자를 설치합니다.
현재의 new 처리자가 더 이상 가용 메모리를 확보할 수 없다 해도 이 경우에 자기 몫까지 해 줄 다른 
new 처리자의 존재를 알고 있을 가능성도 있겠지요. 만약 그렇다면 현재의 new 처리자는 제자리에서 다른 
new 처리자를 설치할 수 있습니다(현재의 new 처리자 안에서 set_new_handler를 호출합니다). 
operator new 함수가 다시 new 처리자를 호출할 때가 되면, 새로 설치된(가장 마지막으로 설치된) 
new 처리자가 호출되는 것입니다(이 방법을 살짝 비틀어, new 처리자가 자기 자신의 동작 원리를 변경
하도록 만들 수도 있습니다. 다음에 이 함수가 호출될 때는 지금과 다른 방식으로 동작하게 되겠지요. 
이렇게 만드는 한 가지 방법은 new 처리자의 동작을 조정하는 데이터를 정적 데이터 혹은 네임스페이스 
유효범위 안의 데이터, 아니면 전역 데이터로 마련해 둔 후에 new 처리자가 이 데이터를 수정하게 만드는 
것입니다).

* new 처리자의 설치를 제거합니다. 
다시 말해 set new_handler에 널 포인터를 넘깁니다. new 처리자가 설치된 것이 없으면, operator new
는 메모리 할당이 실패했을 때 예외를 던지게 됩니다.