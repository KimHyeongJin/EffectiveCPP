항목 20: '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달' 방식을 택하는 편이 대개 낮다.

기본적으로 C++는 함수로부터 객체를 전달받거나 함수에 객체를 전달할 때 '값에 의한 전달(pass
-by-value)' 방식을 사용합니다(C에서 물려받은 특성 중 하나죠). 특별히 다른 방식을 지정하지 
않는 한, 함수 매개변수는 실제 인자의 '사본'을 통해 초기화되며, 어떤 함수를 호출 한 쪽은 그 
함수가 반환한 값의 '사본'을 돌려받습니다. 이들 사본을 만들어내는 원천이 바로 복사 생성자인데
요. 이점 때문에 '값에 의한 전달'이 고비용의 연산이 되기도 합니다. 어째서 그럴까요? 
예를 들어, 아래의 클래스 계통을 보고 생각해 보도록 합시다.

class Person
{
public:
	Person();			// 매개변수는 간결함을 위해 생략함
	virtual ~Person();	// 가상 소멸자인 이유는 항목 7에서 확인하세요.
	...
private:
	std::string name;
	std::string address;
};

class Student: public Person
{
public:
	Student();		// 역시 비슷한 이유로 매개변수 생략
	~Student();
	...
private:
	std::string schollName;
	std::string schoolAddress;
};

이제 아래의 코드를 봐주세요 validateStudent라는 함수를 호출하고 있는데, 이 함 수는 Student 
인자를 전달받고(값으로) 이 인자가 유효화됐는가를 알려 주는 값을 반환합니다.

bool validateStudent(Student s) ; // Student를 값으로 전달받는 함수 
Student plato;					// 소크라테스의 제자 플라톤 
bool platoIsOK = validateStudent(plato) ; // 이제 함수를 호출합니다.

이 함수가 호출될 때 어떤 일이 일어날까요?

확실한 것부터 뽑아 봅시다. plato로부터 매개변수 s를 초기화시키기 위해 Student의 복사 생성자가 
호출될 것입니다. 게다가 s는 validateStudent가 복귀할 때 소멸될 것이고요. 정리하면, 이 함수의 
매개변수 전달 비용은 Student의 복사 생성자 호출 한 번, 그리고 Student의 소멸자 호출 한 번입니다.

이야기가 이렇게 끝나면 얼마나 큰 기쁨이겠습니까만, 끝나려면 좀 멀었습니다. Student 객체에는 
String 객체 두 개가 멤버로 들어 있기 때문에, Student 객체가 생성될 때마다 이들 String 형제도 
덩달아 생성되어야 합니다. 게다가 Student 객체는 Person 객체로부터 파생되었기 때문에, Student 객
체가 생성되면 Person 객체도 (먼저) 생성 되어야 합니다. Person 객체 안에는 또 String 객체 두 개
가 들어 있기 때문에, Person 객체가 매번 생성될 때 String 생성자가 두 번 더 불리게 되겠지요. 최종 
결과는 갑갑합니다. 단지 Student 객체 하나를 값으로 전달했을 뿐인데 Student 복사 생성자 호출 한 번, 
Person 복사 생성자 호출 한 번에 추가로 String 복사 생성자 호출이 네 번 일 어납니다. Student 객
체의 사본이 소멸될 때도 암담하기는 마찬가지입니다. 앞에서 호출 된 생성자들 각각이 소멸자 호출과 대응되는 
거죠 세상에나, Student 객체를 값으로 전달하는 데 날아간 비용을 계산해 보니 생성자 여섯 번에 소멸자 
여섯 번입니다!

뭐 좋습니다. 틀린 것도 아니며 또 바라지 않았던 동작도 아닙니다. 어쨌든 여러분이 원한 대로 제대로 생성
되고 소멸되고 있지요. 그렇지만, 가끔 위쪽도 바라보며 살면 좋잖아요? 생성자 소멸자 호출을 몇 번씩 거치지 
않고 넘어갈 수 있는 방법이 있다변 인생이 조금 더 반질반질할 텐데 말이에요. 그런데 그런 방법이 있습니다. 
상수객체에 대한 참조자(reference-to-const)로 전달히게 만드는 것입니다.

bool validateStudent(const Student& s);

이렇게 하면 순식간에 훨씬 효율적인 코드로 바뀝니다. 새로 만들어지는 객체 같은 것이 없기 때문에, 생성
자와 소멸자가 전혀 호출되지 않거든요. 여기서 새겨둬야 할 부분이 매개변수 선언문에 있는 const입니다. 
이것이 아주 중요합니다. 원래의 validateStudent는 Student 매개변수를 값으로 받도록 되어 있기 때문에, 
호출부에서는 함수로 전달된 Student 객체에 어떤 변화가 생기더라도 그 변화로부터 안전하게 보호를 받는다는 
점을 알고 있습니다. 그도 그럴 것이 validateStudent가 상대하는 Student 객체는 원본이 아닌 사본이니까요. 
그런데 이제는 Student 객체의 전달 방식이 참조에 의한 전달입니다. 매개변수 앞에 const가 붙은건 바로 그 
때문인데, 이것이 붙지 않으면 validateStudent 함수로 넘어간 Student 객체가 변할지도 모른다는 걱정을 
호출부가 해야 하거든요.

참조에 의한 전달 방식으로 매개변수를 넘기면 복사손실 문제(slicing problem)가 없어지는 장점도 있습니다. 
파생 클래스 객체가 기본 클래스 객체로서 전달되는 경우는 드물지 않게 접할 수 있는데, 이때 이 객체가 값으로 
전달되면 기본 클래스의 복사 생성자가 호출되고, 파생 클래스 객체로 동작하게 해 주는 특징들이 '싹둑 잘려' 
떨어지고 맙니다. 여러분 손에 남은 것은 파생 클래스의 징표가 거세된 기본 클래스 객체뿐인 거죠 뭐, 사실 
놀랄 일도 아닙니다. 기본 클래스 생성자가 만들었으니까요. 모르긴 해도 여러분이 원한 결과가 이것일 리는 없을 
거예요. 예를 하나 더 들어 보겠습니다. 그래픽 기반의 윈도우 시스템을 구현한 클래스 라이브러리를 써서 어떤 
작업을 하고 있다고 가정합시다.

class 