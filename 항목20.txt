항목 20: '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달' 방식을 택하는 편이 대개 낮다.

기본적으로 C++는 함수로부터 객체를 전달받거나 함수에 객체를 전달할 때 '값에 의한 전달(pass
-by-value)' 방식을 사용합니다(C에서 물려받은 특성 중 하나죠). 특별히 다른 방식을 지정하지 
않는 한, 함수 매개변수는 실제 인자의 '사본'을 통해 초기화되며, 어떤 함수를 호출 한 쪽은 그 
함수가 반환한 값의 '사본'을 돌려받습니다. 이들 사본을 만들어내는 원천이 바로 복사 생성자인데
요. 이점 때문에 '값에 의한 전달'이 고비용의 연산이 되기도 합니다. 어째서 그럴까요? 
예를 들어, 아래의 클래스 계통을 보고 생각해 보도록 합시다.

class Person
{
public:
	Person();			// 매개변수는 간결함을 위해 생략함
	virtual ~Person();	// 가상 소멸자인 이유는 항목 7에서 확인하세요.
	...
private:
	std::string name;
	std::string address;
};

class Student: public Person
{
public:
	Student();		// 역시 비슷한 이유로 매개변수 생략
	~Student();
	...
private:
	std::string schollName;
	std::string schoolAddress;
};

이제 아래의 코드를 봐주세요 validateStudent라는 함수를 호출하고 있는데, 이 함 수는 Student 
인자를 전달받고(값으로) 이 인자가 유효화됐는가를 알려 주는 값을 반환합니다.

bool validateStudent(Student s) ; // Student를 값으로 전달받는 함수 
Student plato;					// 소크라테스의 제자 플라톤 
bool platoIsOK = validateStudent(plato) ; // 이제 함수를 호출합니다.

이 함수가 호출될 때 어떤 일이 일어날까요?

확실한 것부터 뽑아 봅시다. plato로부터 매개변수 s를 초기화시키기 위해 Student의 복사 생성자가 
호출될 것입니다. 게다가 s는 validateStudent가 복귀할 때 소멸될 것이고요. 정리하면, 이 함수의 
매개변수 전달 비용은 Student의 복사 생성자 호출 한 번, 그리고 Student의 소멸자 호출 한 번입니다.

이야기가 이렇게 끝나면 얼마나 큰 기쁨이겠습니까만, 끝나려면 좀 멀었습니다. Student 객체에는 
String 객체 두 개가 멤버로 들어 있기 때문에, Student 객체가 생성될 때마다 이들 String 형제도 
덩달아 생성되어야 합니다. 게다가 Student 객체는 Person 객체로부터 파생되었기 때문에, Student 객
체가 생성되면 Person 객체도 (먼저) 생성 되어야 합니다. Person 객체 안에는 또 String 객체 두 개
가 들어 있기 때문에, Person 객체가 매번 생성될 때 String 생성자가 두 번 더 불리게 되겠지요. 최종 
결과는 갑갑합니다. 단지 Student 객체 하나를 값으로 전달했을 뿐인데 Student 복사 생성자 호출 한 번, 
Person 복사 생성자 호출 한 번에 추가로 String 복사 생성자 호출이 네 번 일 어납니다. Student 객
체의 사본이 소멸될 때도 암담하기는 마찬가지입니다. 앞에서 호출 된 생성자들 각각이 소멸자 호출과 대응되는 
거죠 세상에나, Student 객체를 값으로 전달하는 데 날아간 비용을 계산해 보니 생성자 여섯 번에 소멸자 
여섯 번입니다!

뭐 좋습니다. 틀린 것도 아니며 또 바라지 않았던 동작도 아닙니다. 어쨌든 여러분이 원한 대로 제대로 생성
되고 소멸되고 있지요. 그렇지만, 가끔 위쪽도 바라보며 살면 좋잖아요? 생성자 소멸자 호출을 몇 번씩 거치지 
않고 넘어갈 수 있는 방법이 있다변 인생이 조금 더 반질반질할 텐데 말이에요. 그런데 그런 방법이 있습니다. 
상수객체에 대한 참조자(reference-to-const)로 전달히게 만드는 것입니다.

bool validateStudent(const Student& s);

이렇게 하면 순식간에 훨씬 효율적인 코드로 바뀝니다. 새로 만들어지는 객체 같은 것이 없기 때문에, 생성
자와 소멸자가 전혀 호출되지 않거든요. 여기서 새겨둬야 할 부분이 매개변수 선언문에 있는 const입니다. 
이것이 아주 중요합니다. 원래의 validateStudent는 Student 매개변수를 값으로 받도록 되어 있기 때문에, 
호출부에서는 함수로 전달된 Student 객체에 어떤 변화가 생기더라도 그 변화로부터 안전하게 보호를 받는다는 
점을 알고 있습니다. 그도 그럴 것이 validateStudent가 상대하는 Student 객체는 원본이 아닌 사본이니까요. 
그런데 이제는 Student 객체의 전달 방식이 참조에 의한 전달입니다. 매개변수 앞에 const가 붙은건 바로 그 
때문인데, 이것이 붙지 않으면 validateStudent 함수로 넘어간 Student 객체가 변할지도 모른다는 걱정을 
호출부가 해야 하거든요.

참조에 의한 전달 방식으로 매개변수를 넘기면 복사손실 문제(slicing problem)가 없어지는 장점도 있습니다. 
파생 클래스 객체가 기본 클래스 객체로서 전달되는 경우는 드물지 않게 접할 수 있는데, 이때 이 객체가 값으로 
전달되면 기본 클래스의 복사 생성자가 호출되고, 파생 클래스 객체로 동작하게 해 주는 특징들이 '싹둑 잘려' 
떨어지고 맙니다. 여러분 손에 남은 것은 파생 클래스의 징표가 거세된 기본 클래스 객체뿐인 거죠 뭐, 사실 
놀랄 일도 아닙니다. 기본 클래스 생성자가 만들었으니까요. 모르긴 해도 여러분이 원한 결과가 이것일 리는 없을 
거예요. 예를 하나 더 들어 보겠습니다. 그래픽 기반의 윈도우 시스템을 구현한 클래스 라이브러리를 써서 어떤 
작업을 하고 있다고 가정합시다.

class Window 
{ 
public:
	...
	std::string name() const;		// 윈도우의 이름을 반환합니다. 
	virtual void display() const;	// 윈도우 테두리 및 내부를 그립니다.
};

class WindowWithScrollBars: public Window
{
public:
	...
	virtual void dispaly() const;
};

이 window 클래스로 만들어지는 객체는 이름을 갖고 있으며, 이 이름은 name 멤버 함수로 얻어냄니다. 게다가 
화면 표시도 가능한데, display 멤버 함수를 호출하면 윈도우를 화변에 뿌릴 수 있습니다. 그리고 display가 
가상 함수로 선언되어 있다는 점에서, 그저 그런 Window 객체의 화면표시 방식은 windowWithScrollBars 
객체에서 그보다 잘 빠진 모습으로 바뀔 수 있다는 단서도 발견할 수 있지요(항목 34 및 36 참조).

뭐 이렇습나다. 이제 이것을 가지고 어떤 윈도우의 이름을 출력하고 그 윈도우를 화면에 표시 하는 함수를 하나 
만들어 보겠습니다. 우선 틀리게 구현한 버전을 가지고 이야기를 시작하죠.

void printNameAndDisplay(Window w)	//	저런! 매개변수가 복사손실에 당합니다.
{
	std::cout << w.name(); 
	w.display(); 
}


이 함수에 windowWithScrollBars 객체를 넘긴다면 어떤 일이 생길지 생각해 보셨나요?

WindowWithScrollBars wwsb;
printNameAndDisplay(wwsb);

매개변수 w가 생성되기는 하는데(머리 속 지우개, 아직 님아 있나요? 값으로 전달됩니다), Window 객체로 만들어
지면서 wwsb가 windowWithScrollBars 객체의 구실을 할 수 있는 부속 정보가 전부 싹둑 썰려 나갑니다. 
printNameAndDisplay 함수 안에서 이리저리 굴러다닐 w는 어떤 타입의 객체가 넘겨지든 아랑곳없이 window 클
래스 객체의 면모만을 갖게 되겠지요(Window 생성자로 만들어졌으니 어련하겠습니까). 특히, printNameAndDisplay 
안에서 호출되는 display는 그 어떤 어려움에도 굴하지 않고 Window::display일 것입니다. 
windowWithScrollBars::display는 영원히 호출되지 않는다고요.

복사손실 문제에서 도망가려면, w를 상수객체에 대한 참조자로 전달하도록 만들면 됩니다.

void printNameAndDisplay(const Window& w) // 좋습니다 이제 매개변수는 잘리지 않습니다.(와우....)
{
	std::cout << w.name(); 
	w.display(); 
}

이제 w는 어떤 종류의 윈도우가 넘겨지더라도 그 윈도우의 성질을 그대로 갖게 됩니다.

************************************************************************************
C++ 컴파일러의 동작 원리에 관심 있는 분이라면, 참조자는 보통 포인터를 써서 구현된다는 사실을 알고 계시거나 
알아내실 겁니다. 즉, 참조자를 전달한다는 것은 결국 포인터를 전달한다는 것과 일맥상통한다는 이야기죠. 이렇게 
따져 보면, 전달하는 객체의 타입이 기본제공 타입(int 등)일 경우에는 참조자로 넘기는 것보다 값으로 넘기는 
편이 더 효율적일 때가 많습니다. 그러니까 '값에 의한 전달' 및 '상수객체의 참조에 의한 전달' 중 하나를 선택해야 
할 때, 기본제공 타입에 대해서는 '값에 의한 전달'을 선택하더라도 엉터리가 아니라는 이야기입니다. 이 점은 STL의 
반복자와 함수 객체에도 마찬가지입니다. 예전부터 반복자와 함수 객체는 값으로 전달되도록 설계해 왔기 때문입니다. 
참고로, 반복자와 함수 객체를 구현할 때는 반드시 1. 복사 효율을 높일 것과 2. 복사손실 문제에 노출되지 않도록 
만드는 것이 필수입니다(항목 1을 읽으신 분이변 뭔가 머리에 떠올랐을 겁니다. 현재 쓰고 있는 C++의 하위 언어에 
따라 규칙이 어떻게 변하는지를 여실히 보여주는 사례죠?).
************************************************************************************

기본제공 타입은 작습니다. 이 점에 착안해서 좀 앞서 나가는 분들이 있습니다. 타입 크기만 작으면 전부 '값에 의한 
전달'을 할 수 있다고 생각하는 거죠. 사용자 정의 타입이라도 말입니다. 그런 부실한 생각으로 이 험한 세상을 어떻게 
사시려고 그러시나요 '그냥 크기가 작으니까'는 그 객체의 복사 생성자 호출이 저비용이란 뜻으로 해석하라는 단서가 
아닙니다. 데이터 멤버라고 해봐야 달랑 포인터 하나뿐인 객체가 꽤 많이(대부분의 STL 컨테이너도 그 중의 일부죠) 
널려 있긴 하지만, 이런 객체를 복사하는 데는 그 포인터 멤버가 가리키는 대상까지 복사하는 작업도 따라다녀야 합
니다. 크기가 작다고 쉽지 않습니다. 비쌀 수 있다고요.

그럼, 객체가 크기가 작고 복사 생성자도 그다지 비싸지 않게 만들어졌다고 가정합시다. 산 넘으니 똥밭이라고, 수행 
성능 문제가 발목을 잡을 수 있습니다. 컴파일러 중에는 기본제공 타입과 시용자 정의 타입을 아예 다르게 취급하는 
것들이 있습니다. 기본제공 타입과 사용자 정의 타입의 하부 표현구조가 같아도 말이죠. 이를테면 진짜 double은 
레지스터에 넣어 주지만, double 하나로만 만들어진 (사용자 정의 타입) 객체는 레지스터에 넣지 않는 것입니다. 
이런 개발 환경에서 일하는 분은 차라리 참조에 의한 전달을 쓰는 편이 좋습니다. 포인터(참조자가 포인터로 구현되죠)
만큼은 레지스터에 확실히 들어가니까요.

크기가 작다고 해서 작은 사용자 정의 타입을 무조건 값으로 전달할 수 없는 이유가 하나 더 있습니다. 사용자 정의 
타입의 크기는 언제든 변화에 노출되어 있다는 것이죠. 지금은 크기가 작을지 몰라도 나중에는 커질지도 모르는 노릇
입니다. 개발도구의 내부 구현은 언제든 바뀔 수 있으니까요. 심지어 여러분이 다른 C++ 구현 환경으로 바꿀 때조차
도 사정이 변할 수 있습니다. 제가 이 글을 쓰고 있는 지금만 봐도 구현 환경마다 표준 라이브러리의 string 타입이 
그 크기가 최고 일곱 배나 차이 나는 경우도 본 적이 있는걸요.

자, 이제 마무리합시다. 일반적으로, '값에 의한 전달이 저비용이라고 가정해도 괜찮은 유일한 타입은 기본제공 타입, 
STL 반복자, 함수 객체 타입, 이렇게 세 가지뿐입니다. 이 외의 타입에 대해서는 이번 항목에 나온 이야기를 따르시는 
것이 좋습니다' 벌써 잊으셨습니까? '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달'을 선택하라고요.

이것만은 잊지 말자! 
* '값에 의한 전달'보다는 '상수 객체 참조자에 의한 전달'을 선호합시다.  대체적으로 효율적일 뿐만 아니라 복사손실 
문제까지 막아 줍니다 
* 이번 항목에서 다룬 법칙은 기본제공 타입 및 STL 반복자 그리고 함수 객체 타입에는 맞지 않습니다. 이들에 대해
서는 '값에 의한 전달'이 더 적절합니다.
