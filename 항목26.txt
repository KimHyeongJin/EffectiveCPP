항목 26: 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자

생성자 혹은 소멸자를 끌고 다니는 타입으로 변수를 정의하면 반드시 물게 되는 비용이 두
개 있습니다. 하나는 프로그램 제어 흐름이 변수의 정의에 닿을 때 생성자가 호출되는 비용
이고, 또 하나는 그 변수가 유효범위를 벗어날 때 소멸자가 호출되는 비용입니다. 변수가 정
의됐으나 시용되지 않은 경우에도 비용이 부과되는데, 이런 비용은 웬만한 경우가 아니면 물
고 싶을 생각이 안 들 것입니다.

사용하지 않을 변수를 누가 정의하겠냐고 큰소리치는 독자도 물론 있겠지만, 인생 그렇게
호락호락하지 않습니다. 아래의 함수를 한 번 보시고 다시 생각해 보세요. 이 함수는 주어진
비밀번호(password)가 충분히 길 경우에 해당 비밀번호를 암호화하여 반환하는 함수입니다.
비밀번호가 너무 짧으면 logic_error 타입의 예외를 던지도록 만들어졌는데, logic_
error 타입은 표준 C++ 라이브러리에 정의되어 있습니다(항목 54 참조).

// 이 함수는 "encrypted" 변수를 너무 일찍 정의해 버립니다.
std::string encryptedPassword(const std::string& password)
{
	using namespace std;

	string encrypted;

	if(password.length()<MinimumPasswordLength)
	{
		throw logic_error("Password is to short");
	}
	...		// 주어진 비밀번호를 암호화하여 encryped 변수에 넣는 데
			// 필요한 일들을 여기서 합니다.
	return encrytped;
}

encrypted 객체가 사실 이 함수에서 완전히 안 쓰인다고는 말할 수 없지만, 예외가 발생
되면 이 변수는 분명히 사용되지 않게 됩니다. 다시 말해, encryptPassword 함수가 예
를 던지더라도 encrypted 객체의 생성과 소멸에 대해 비용을 내야 한다는 이야기입니다. 
이런 사정을 확인한 이상, encrypted 변수를 정의하는 일은 꼭 필요해지기 전까지로
미루는 편이 낫겠다는 생각이 들겠지요.

// 이 함수는 "encrypted" 변수가 진짜로 필요해질 때까지 정의를 미룹니다.
std::string encryptedPassword(const std::string& password)
{
	using namespace std;

	if(password.length()<MinimumPasswordLength)
	{
		throw logic_error("Password is to short");
	}
	string encrypted;

	...		// 주어진 비밀번호를 암호화하여 encryped 변수에 넣는 데
			// 필요한 일들을 여기서 합니다.
	return encrytped;
}

위와 같이 만들고 나면 바짝 죈 듯한 느낌이 들 줄 알았는데 어쩐지 여전히 헐렁헐렁해 보
입니다. 그도 그럴 것이, encrypted 변수가 정의될 때 초기화 인자가 하나도 없는 게 그
이유인 것 같아요. 기본 생성자가 호출될 거란 뜻이지요. 상당수의 경우에 여러분이 어떤 객
체를 가지고 하는 가장 처음 일은 '값을 주는 것'일 텐데요. 이때 대개 대입 연산을 씁니다.
그런데 객체를 기본 생성하고 나서 값을 대입하는 방법이 어째서 여러분이 원하는 값으로
직접 초기화하는 방법보다 효율이 좋지 않은지, 항목 4를 미리 읽으신 분은 아실 겁니다. 지
금 경우에도 딱 들어맞는 이야기이기도 하고요. 예를 하나 들겠습니다. 다음의 함수 안에서
encryptPassword의 암호화 부분이 돌아간다고 가정해 보세요.

void encrype(std::string& s);	// 이 자리에서 s를 바로 암호화합니다.

그리고 encryptPassword의 암호화 부분이 다음과 같이 구현되어 있다고 가정해 봅시다.
뭐, 인상부터 그다지 썩 좋은 방법 같아 보이진 않지만 말이죠. 

// 이 함수는 "encrypted" 변수가 진짜로 필요해질 때까지 정의를 늦추긴 했지만,
// 여전히 쓸데없이 비효율적입니다.
std::string encryptedPassword(const std::string& password)
{
	...						// 길이를 점검
	std::string encrypted;	// 기본 생성자에 의해 만들어지는 encryped
	encrypted = password;	// encrypted에 password를 대입
	encrypt(encrypted);
	return encrytped;
}

이 순간 진정으로 바람직한 방법이라면 encrypted를 password로 확 초기화해 버려야
할 것입니다. 요컨대, 의미도 없고 비용도 만만치 않을 듯한 기본 생성자 호출을 건너뛰어야
한다는 이야기죠. 다음의 코드를 봐 주세요.

// 결국 여기까지 오다: encrypted를 정의하고 초기화하는 가장 좋은 방법
std::string encryptedPassword(const std::string& password)
{
	...						// 길이를 점검
	std::string encrypted(password);// 변수를 정의함과 동시에 초기화합니다.
									// 이때 복사 생성자를 사용합니다.
	encrypt(encrypted);
	return encrytped;
}

이번 항목의 제목에 적힌 '늦출 수 있는 데까지'의 진짜 뜻이 바로 이것입니다. 아시겠죠?
어떤 변수를 사용해야 할 때가 오기 전까지 그 변수의 정의를 늦추는 것은 기본이고, 초기
화 인자를 손에 넣기 전까지 정의를 늦출 수 있는지도 둘러봐야 한다는 것입니다. 이렇게
해야 쓰지도 않을 객체가 만들어졌다 없어지는 일이 생기지 않으며, 불필요한 기본 생성자
호출도 일어나지 않습니다. 덤으로, 누가 보아도 그 변수의 의미가 명확한 상황에서 초기화
가 이루어지기 때문에, 변수의 쓰임새를 문서화하는 데도 큰 도움이 됩니다.

"좋다고요. 그런데 루프에 대해선 어쩌죠?" 이런 질문 나올 줄 알았습니다. 어떤 변수가 루
프 안에서만 쓰이는 경우라면, 해당 변수를 루프 바깥에서 미리 정의해 놓고 루프 안에서
대입하는 방법이 좋을까요. 아니면 루프 안에 변수를 정의하는 방법이 좋을까요? 그러니까,
다음 중 어떤 구조가 좋겠냐는 거예요.

// A 방법: 루프 바깥쪽에 정의
Widget w;
for(int i = 0; i < n; ++i)
{
	w = i에 따라 딸라지는 값;
	...
}

// B 방법: 루프 안쪽에 정의

for(int i = 0; i < n; ++i)
{
	Widget w(i에 따라 딸라지는 값);
	...
}

위의 예제에서는 string 타입을 Widget 타입으로 바꾸어 봤는데요, 객체의 생성 혹은
소멸, 대입에 어가는 비용이 타입마다 다를 거라는 선입견을 가지신 분들이 있을까봐 그
랬습니다.

아무튼 이제 Widget 객체에 들어가는 연산을 기준으로 해서 두 방법에 걸리는 비용을 정
리해 보죠. 그 결과는 다음과 같습니다.

* A 방법 > 생성자 1번 + 소멸자 1번 + 대입 n번
* B 방법 > 생성자 n번 + 소멸자 n번

클래스 증에는 대입에 들어가는 비용이 생성자-소멸자 쌍보다 적게 나오는 경우가 있는데,
Widget 클래스가 이런 종류에 속한다면 A 방법이 일반적으로 훨씬 효율이 좋습니다. 이
차이는 n이 커질 때 특히 더 커집니다. 반면, 그렇지 않은 경우엔 B 방법이 아마 더 좋을
것이고요. 참, 생각해 볼 부분이 하나 더 있는데요. A 방법을 쓰면 w라는 이름을 볼 수 있
는 유효범위가 B 방법을 쓸 때보다 넓어지기 때문에(루프를 포함하는 유효범위가 되죠), 프로
그램의 이해도와 유지보수성이 역으로 안 좋아질 수도 있습니다. 그러니까 이렇게 하세요.
(1) 대입이 생성자-소멸자 쌍보다 비용이 덜 들고
(2) 전체 코드에서 수행 성능에 민감한 부분을건드리는 중
이라고 생각하지 않/는/다/면, 앞뒤 볼 것 없이 B 방법으로 가는 것이 좋습니다.

이것만은 잊지 말자!
*	변수 정의는 늦출 수 있을 때까지 늦춥시다. 프로그램이 더 깔끔해지며 효율도 좋아집니다.