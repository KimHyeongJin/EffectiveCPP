항목 28: 내부에서 사용하는 객체에 대한 "핸들"을 반환하는 코드는 되도록 피하자

사각형(rectangle)을 사용하는 어떤 응용프로그램을 만들고 있습니다. 사각형은 좌측 상단 및
우측 하단의 꼭짓점 두 개로 나타낼 수 있지요. 이것을 추상화한 Rectangle 클래스를 만
들었는데, 이 클래스의 객체를 썼을 때의 메모리 부담을 최대한 줄이고 싶다는 생각이 여러
분 머리를 스쳤습니다. 사각형의 영역을 정의하는 꼭짓점을 Rectangle 자체에 넣으면 안
될 것 같고, 이것들을 별도의 구조체에 넣은 후에 Rectangle이 이 구조체를 가리키도록
하면 어떨까 하는 생각이 든 것도 그때였습니다. 

class Point	// 점을 나타내는 클래스
{
public:
	Point(int x, int y);
	...
	void setX(int newVal);
	void setY(int newVal);
	...
};

struct RectData
{
	Point ulhc;	// ulhc = "좌측 상단(upper left-hand corner)"
	Point lrhc;	// lrhc = "우측 하단(lower right-hand corner)"
};

class Rectangle
{
	...
private:
	std::tr1::shared_ptr<RectData> pData;
	// tr1::shared_ptr에 대한 이야기는 항목 13에서 확인
}

Rectangle 클래스의 사용자는 분명히 영역정보를 알아내어 쓸 때가 있을 것이므로,
Rectangle 클래스에는 upperLeft 및 lowerRight 함수가 멤버 함수로 들어 있습니
다. 그러고 보니 Point가 사용자 정의 타입인 것이 눈에 들어오면서 불현듯 항목
20 에서 읽었던 내용이 떠오르기 시작합니다. 사용자 정의 타입을 전달할 때는 값에 의한 전
달보다 참조에 의한 전달방식을 쓰는 편이 더 효율적이라고 누군가가 부르짖었던 것 같습니
다. 그래서 들 두 멤버 함수는 (스마트)포인터로 물어둔 Point 객체에 대한 참조자를
반환하는 형태로 만들어졌습니다.

class Rectangle
{
public:
	...
	Point& upperLeft() const { return pData->ulhc; }
	Point& lowerRight() const { return pData->lrhc; }
	...
};

컴파일은 잘 됩니다. 그런데 결정적으로 틀렸습니다. 조금만 들여다보면 자기모순적인 코드
임을 알 수 있어요. 우선 upperLeft 함수와 lowerRight 함수가 어떻게 선언되어 있
는지 보세요. 상수 멤버 함수입나다. 원래 Rectangle의 꼭짓점 정보를 알아낼 수 있는
방법만 사용자에게 제공하고, Rectangle 객체를 수정하는 일은 할 수 없도록(항목 3 참조)
설계되었으니까요. 그런데 이 함수들이 반환하는 게 어떤 건지 보세요. private 멤버인
내부 데이터에 대한 참조자 아닙니까? 호출부에서 이 참조자를 써서 내부 데이터를 맘대로
수정해도 좋다는 뜻이 아니냐고요! 그러니까 다음과 같이 쓰면,

Point coord1(0, 0);
Point coord2(100, 100);
const Rectangle rec(coord1, coord2);	// rec은 (0, 0)부터 (100, 100)의
										// 영역에 있는 상수 Rectangle
										// 객체입니다.
rec.uperLeft().setX(50);	// 이제 이 rec은 (50, 0)부터 (100, 100)의 영역
							// 에 있게 됩니다!

upperLef를 호출한 쪽은 rec의 은밀한 곳에 숨겨진 Point 데이터 멤버를 참조자로
끌어와 척척 바꿀 수 있다는 것입니다. 하지만 rec은 상수 객체로 선언된 것 아닙니까?

우리는 여기서 두 가지 교훈을 얻을 수 있습니다. 첫째, 클래스 데이터 멤버는 아무리 숨겨
봤자 그 멤버의 참조자를 반환하는 함수들의 최대 접근도에 따라 캡슐화 정도가 정해진다는
점입니다. 말이 좀 어렵죠? 지금 경우를 놓고 설명해드리죠. ulhc와 lrhc는 private로
선언되어 있죠? 하지만 실질적으로는 public 멤버입니다. 왜냐하면 이들의 참조자를 반환
는 upperLeft 및 lowerRight 함수가 public 멤버 함수이기 때문입니다. 둘째, 어
떤 객체에서 호출한 상수 멤버 함수의 참조자 반환 값의 실제 데이터가 그 객체의 바깥에
저장되어 있다면, 이 함수의 호출부에서 그 데이터의 수정이 가능하다는 접입니다(사실 이
점은 비트수준 상수성의 한계가 가진 부수적 성질에 불과합니다. 비트수준 상수성은 항목 3
에서 이미 공부한 바 있지요).

지금은 참조자를 반환하는 멤버 함수만 붙들고 열심히 이야기하고 있는데, 만약 이들이 포
인터나 반복자를 반환하도록 되어 있었다 해도 마찬가지 이유로 인해 마찬가지 문제가 생깁
니다. 참조자, 포인터 및 반복자는 어쨌든 모두 핸들(handle, 다른 객체에 손을 댈 수 있게 
하는 매개자)이고, 어떤 객체의 내부요소에 대한 핸들을 반환하게 만들면 언제든지 그 객체의
캡슐화를 무너뜨리는 위험을 무릅쓸 수밖에 없습니다. 여러분도 보셨겠지만, 이것 때문에 상
수 멤버 함수조차도 객체 상태의 변경을 허용하는 지경에까지 이를 수 있습니다.

어떤 객체의 '내부요소(internals)'라고 하면 흔히들 데이터 멤버만 생각하시는 분들이 많은데,
일반적인 수단으로 접근이 가능한(쉽게 말해 protected 혹은 private로 선언된) 멤버
함수도 객체의 내부요소에 들어갑니다. 그러니 어떻겠어요? 이들에 대한 핸들도 반환하지 말
아야 합니다. 즉, 외부 공개가 차단된 멤버 함수에 대해, 이들의 포인터를 반환하는 멤버 함
수를 만드는 일이 절대로 없어야 한다는 말입니다. 이런 함수가 하나라도 들어가는 순간부
터 실질적인 접근 수준이 바뀝니다. 당연히, 멤버 함수 포인터를 반환하는 함수의 접근도에
맞춰지는 거죠. protected 혹은 private 멤버로 선언된 함수라 해도 사용자 측면에서
는 얼마든지 이들의 포인터를 얻어내어 호출해 버릴 수 있으니까요.

하지만 멤버 함수의 포인터를 반환하는 함수가 그렇게 흔치 않은 것이 사실이므로, 다시
Rectangle 클래스와 그의 멤버 함수인 upperLeft 및 lowerRight의 이야기로 돌아
옵시다. 이들 멤버 함수가 가진 문제 두 개는 위에서 함께 확인한 바 있는데, 이렇게 하면
둘 다 간단히 해결됩니다. 반환 타입에 const 키워드 만 붙여주세요.

class Rectangle
{
public:
	...
	const Point& upperLeft() const { return pData->ulhc; }
	const Point& lowerRight() const { return pData->lrhc; }
	...
};

이렇게 설계하면, 사용자는 사각형을 정의히는 꼭짓점 쌍을 읽을 수는 있지만 쓸 수는 없게
됩니다. 말하자면 upperLeft 및 lowerRight에 const를 붙여 선언한 게 이젠 거짓
말이 아니라는 이야기죠. 호출부에서 객체의 상태를 바꾸지 못하도록 컴파일러 수준에서 막
고 있거든요. 그리고 캡슐화 문제인데요. 사용자들이 Rectangle을 구성하는 Point를 들
여다보도록 하자는 것은 처음부터 알고 시작한 설계 이기 때문에, 이 부분은 의도적인 캡슐
화 완화라고 할 수 있겠습니다. 이보다 더 중요한 부분은 느슨하게 만든 데에도 제한을 두
었다는 것입니다. 읽기 접근만 주어지고, 쓰기 접근은 여전히 금지죠.

뭔가 한 것 같지만 그래도 찝찝합니다. upperLeft 함수와 lowerRight 함수를 보면
내부 데이터에 대한 핸들을 반환하고 있는 부분이 남아 있거든요 이것을 남겨두면 다른 쪽
에서 문제가 될 수 있습니다. 가장 큰 문제가 무효잠조 핸들(dangling handle)로서, 핸들이
있기는 하지만 그 핸들을 따라갔을 때 실제 객체의 데이터가 없는 것입니다. 핸들이 물고 있
는 객체가 기약도 없이 어디론가 증발하는 현상은 함수가 객체를 값으로 반환할 경우에
가장 흔하게 발생됩니다. 예를 하나 들어 보죠 어떤 GUI 객체의 사각 테두리 영역(bounding
box)을 Rectangle 객체로 반환하는 함수가 있다고 가정합시다. 