#pragma once



class WebBrowser
{
public:
	void clearCache() {};
	void clearHistory() {};
	void removeCookies() {};
	void clearEverything()
	{
		clearCache();
		clearHistory();
		removeCookies();
	}
	//....
};

//clearEverything 함수의 기능을 비멤버 함수로 제공
void clearBrowser(WebBrowser &wb)
{
	wb.clearCache();
	wb.clearHistory();
	wb.removeCookies();
}

/*
clearEverything이 비멤버 버전인 clearBrowser 보다 캽슐화 정도에서 형편없다고 저자는 말하고 있다....?
그 외에 비멤버 함수를 사용하면 WebBrowser 관련 기능을 구성하는 데 있어서 패키징 유연성(packaging flexibility)이 높아지는 장점이 있다.
이로 인해 얻게 되는 추가적인 이점으로 컴파일 의존도도 낮추고 WebBrowser의 확장성도 높일 수 있다.
그래서 비멤버 방법이 멤버 함수보다 여러모로 낫다는 이야기가 나오는 것입니다. 어째서인지 이제부터 하나씩 짚어 보도록 하죠.

캡슐화를 하면 외부에서 이것을 볼 수 없게 되고 외부에서 볼 수 있는 것들이 줄어들면, 그것들을 바꿀 때 필요한 유연성이 커진다.
변경 자체가 영향을 줄 수 있는 범위가 '변경된 것을 볼 수 있는 것들'로 한정되기 때문에 당연한 거죠.
그러니까 캡슐화되는 것들이 많아지면, 그것들을 변경할 수 있는 여유도 많이집니다.
바로 이것 때문에 우선 무엇보다도 캡슐화에 가치를 두는 것이지요. 
쉽게 말해, 이미 있는 코드를 바꾸더라도 제한된 사용자들밖에 영향을 주지 않는 융통성을 확보할 수 있다는 뜻입니다.

*/

//캡슐화 예제
class HUMAN {};

class KIMHJ : public HUMAN
{
private:
	char myID[256] = "909090-12345678";//혹시나 나의 주민 번호를 바꾸게 되더라도 다른 사람에게 영향을 주지 않는다.
};

/*
자, 똑같은 기능을 제공하는데 멤버 함수 (그 클래스의 private 데이터 멤버뿐만 아니라 private 멤버로 되어 있는 다른 함수, enum, typedef 타입 등등을
모두 접근할 수 있는) 를 쓸 것이냐, 아니면 비멤버 비프렌드 함수(어느 것도 접근할 수 없는)를 쓸 것이냐를 이제 다시 생각해 보자.
캡슐화 정도가 더 높은 쪽을 고른다면 단연 후자일 것입니다.

여기서 주의해야 할 부분 두가지!!
첫 번째, 이 이야기는 비멤버 비프렌드(non-friend) 함수에만 적용된다는 것입니다.
프렌드 함수는 private 멤버에 대한 접근권한이 해당 클래스의 멤버 함수가 가진 접근권한과 똑같기 때문에, 캡슐화에 대한 영향 역시 같습니다.
캡슐화라는 관점에서 보았을 때, 위의  선택은 멤버 함수와 비멤버 함수 사이의 선택이 아닙니다. 잘 읽어주세요. 멤버함수와 비멤버, 비프렌드 함수 사이의 선택이란 말입니다.

두 번째, 캡슐화에 대한 이런저런 이야기 때문에 "함수는 어떤 클래스의 비멤버가 되어야 한다" 라는 주장이
"그 함수는 다른 클래스의 멤버가 될 수 없다"라는 의미가 아니라는 것입니다. 
이를테면, clearBrowser 함수를 다른 유틸리티 클래스 같은 데의 정적 멤버 함수로 만들어도 된다는 이야기 입니다.

C++로는 더 자연스런 방법을 구사할 수 있습니다. clearBrowser를 비멤버 함수로 두되, WebBrowserStuff 와 같은 네임스페이스 안에 두는 것입니다.

namespace WebBrowserStuff
{
	class WebBrowser {...};
	void clearBrowser(WebBrowser& wb);
	....
}

사실 이건 자연스러움보다 몇 걸음 더 나아간 방법이라고 볼 수 있습니다. 왜냐하면 네임스페이스는 클래스와 달리 여러 개의 소스 파일에 나뉘어 흩어질 수 있기 때문입니다.
지금 이 부분은 굉장히 중요한데, clearBrowser 같은 함수들은 편의상 준비한 함수들이기 때문입니다.
멤버도 아니고 프렌드도 아니기에, WebBrowser 사용자 수준에서 아무리 애를 써도 얻어낼 수 없는 기능은 이들도 제공할 수 없습니다.
예를 들어, clearBrowser가 없다고 해도 사용자는 그냥 claraCache, clearHistory, removeCookies를 알아서 불러주면 되는 것입니다.

WebBrowser 처렴 응용도가 높은 클래스는 이런 종류의 편의 함수가 꽤 많이 생길 수 있습니다.
즐겨찾기(bookmark)에 관련된 함수라든지, 인쇄에 관련된 함수도 있을 수 있고, 쿠키 관리용 함수도 충분히 가능하지요.
일반적인 경우입니다만, 웬만한 사용자라면 이들 편의 함수들 중 몇 개만 알고 있거나 관심을 둘 것입니다.
즐겨찾기 기능에만 관심 있는 사용자가 구태여 다른 함수들, 뭐 이를테면 쿠키 관련 편의 함수에 대한 컴파일 의존성을 고민할 이유가 없다는 말이죠.
이것들을 나누어 놓는 쉽고 깔끔한 방법은, 즐겨찾기 관련 편의 함수를 하나의 헤더 파일에 몰아서 선언하고, 쿠키 관련 편의 함수는 다른 헤더 파일에 몰아서 선언하고,
인쇄 관련 편의 함수는 제3의 헤더에 몰아서 선언하는 것입니다.

//"webbrowser.h" 헤더
namespace WebBrowserStuff
{
	class WebBrowser {...};
	//핵심 관련 기능, 이를테면 거의 모든 사용자가 써야하는 비멤버 함수들이 여기에 들어갑니다.
}

//"webbrowserbookmarks.h"
namespace WebBrowserStuff
{
	//즐겨찾기 관련 편의 함수들이 여기에 들어가니다.
}

//"webbrowsercookies.h"
namespace WebBrowserStuff
{
	//쿠키 관련 편의 함수들이 여기에 들어가니다.
}

아참, 사실 표준 C++ 라이브러리가 이러한 구조로 구성되어 있답니다. std 네임스페이스에 속한 모든 것들이 <C++ StandardLibrary> 헤더 같은 것에 모조리 들어가
한 통으로 섞여 있지 않고, 몇개의 기능과 관련된 함수들이 수십개의 헤더(<vector>, <algorithm>, <memory> 등)에 흩어져 선언되어 있습니다.
vector 기능만 필요한 사용자는 굳이 <memory>를 #nclude 할 필요가 없으며, list를 사용하지 않는 사용자는 <list>를 #include 하지 않아도 됩니다.
이렇게 하면, 사용자가 실제로 사용하는 구성요소에 대해서만 컴파일 의존성을 고려할 수 있게 되는 거죠.
반면 클래스 멤버 함수로 오게 되면 이야기가 암울해 집니다. 이런 식으로 쪼개는 것 자체가 불가능합니다. 하나의 클래스는 그 전체가 통으로 정의되어야 하고
여러 조각으로 나눌 수가 없기 때문입니다.

편의 함수 전체를 여러 개의 파일에(그러나 하나의 네임스페이스에) 나누어 놓으면 편의 함수 집합의 확장도 손쉬워집니다. 해당 네임스페이스에 비멤버 비프렌드 함수를
원하는 만큼 추가해 주기만 하면 그게 확장입니다. 예를 들어, WebBrowser를 잘 쓰고 있던 사용자가 어쩌다가 다운로드 이미지에 관련된 편의 함수를 만들어야 하겠다고
작정했다면, 헤더 파일 하나를 새로 만흔 후에 WebBrowserStuff 네임스페이스를 만들고 그 안에 관련 함수의 선언문만 끼워 넣으면 끝이라는 거죠.
이렇게 새로 추가된 함수는 기존의 다른 편의 함수들처럼 지금 바로 사용할 수 있으며 WebBrowserStuff의 구송요소로 바로 합쳐집니다.
이런 부분 역시 클래스로는 제공이 불가능한 기능입니다. 클래스 자체를 사용자가 확장할 수는 없으니까요. 아, 물론 새로운 클래스를 파생시킬 수 있기는 하지요.
하지만 파생 클래스는 기본 클래스 안에 캡슐화된(다시 말해 private) 멤버에 대한 접근권한이 없기 때문에, 이런 식의 '확장 기능'은 항공권으로 치면 이등석 티켓 정도랄까요.
게다가 항목 7에서도 말했지만 모든 클래스가 기본 클래스로 쓸 용도로 설계된 것은 또 아니죠.

이것만은 잊지 말자!
멤버 함수보다는 비멤버 비프렌드 함수를 자주 쓰도록 합시다. 캡슐화 정도가 높아지고, 패키징 유연성도 커지며, 기능적인 확장성도 늘어납니다.
*/
