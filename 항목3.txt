항목 3: 낌새만 보이면 const 를 들이대 보자!

const의 면모에 대해 생각해 볼 때 정말 멋지다고 말할 수 는 부분이 있다면 아마도
'의미적인 제약'(const 키워가 붙은 객체는 외부 변경을 불가능하게 한다)을 소스 코드 수준
에서 붙인다는 점과 컴파일러가 이 제약을 단단히 지켜준다는 점일 것입니다. 어떤 값(객체
의 내용)이 불변이어야 한다는 제작자의 의도를 컴파일러 및 다른 프로그래머와 나눌 수 있
는 수단이라고나 할까요. 값이 변하면 안 되는 게 맞는다면, 여러분도 반드시 지켜야 합니
다. 이렇게 해야 컴파일러가 제약 위반을 막는 일에 한몫 거들 수 있기 때문입니다.

const 키워드는 생긴 것 답지 않게 그야말로 팔방미인입니다. 클래스 바깥에서는 전역 혹
은 네임스페이스 유효범위의 상수를 선언(정의)하는 데 쓸 수 있습니다(항목 2 참조). 그뿐 아
니라 파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const를 붙일 수 있습
니다. 클래스 내부의 경우에는, 정적 멤버 및 비정적 데이터 멤버 모두를 상수로 선언할 수
있습니다. 포인터는 어떨까요? 기본적으로는 포인터 자체를 상수록 혹은 포인터가 가리키는
데이터를 상수로 지정할 수 있는데, 둘 다 지정할 수도 있고 아무것도 지정하지 않을 수도
있습니다.

char greeting[] = "Hello";

char* p = greeting;		// 비상수 포인터, 비상수 데이터

const char* p = greeting;	// 비상수 포인터, 상수 데이터

char * const p = greeting;	// 상수 포인터, 비상수 데이터

const char * const p = greeting;	// 상수 포인터, 상수 데이터

//잊어 먹지 말고 암기!!
C T N			// 상수 변수, const type name
C T* N(=T C* N)	// 비상수 포인터, 상수 데이터, const type* name
C T * C N(=T C * C N)	// 상수 포인터, 상수 데이터, const type * const name
T * C N			// 상수 포인터, 비상수 데이터

변덕에 일평생을 바쳐온 사람이 만든 문법처럼 보이지만 그렇지 않습니다. 잘 보세요. const
키워드가 *표의 왼쪽에 있으면 포인터가 가리키는 대상이 상수인 반면, const가 *표의 오
른쪽에 있는 경우엔 포인터 자체가 상수입니다. const가 *표의 양쪽에 다 있으면 포인터가
가리키는 대상 및 포인터가 다 상수라는 뜻이죠.

포인터가 가리키는 대상을 상수로 만들 때 const를 사용하는 스타일은 조금씩 다릅니다.
어떤 프로그래머는 타입 앞에 const를 붙이기도 합니다. 그 외에는 타입의 뒤쪽이자 *표
의 앞에 const를 붙이는 사람들이겠지요. 의미적인 차이는 전혀 없습니다. 즉, 아래의 함
수들이 받아들이는 매개변수 타입은 모두 똑같디는 야기입니다.

void f1(const Widget *pw);	// f1 은 상수 Widget 객체에 대한
							// 포인터 를 매개변수로 취합니다.
void f2(Widget const *pw);	// f2 도 그렇고요.

두 가지 형태 모두가 현업 개발자들의 코드에 아주 잘 쓰이고 있으므로, 눈에 어색해 하지
않도록 잘 익혀 두도록 합시다.

STL 반복자(iterator)는 포인터를 본뜬 것이기 때문에, 기본적인 동작 원리가 T* 포인터와
진짜 흡사합니다. 어떤 반복자를 const로 선언하는 일은 포인터를 상수로 선언하는 것(즉,
T* const 포인터)과 같습니다. 반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가
허용되지 않지만, 반복자가 가리키는 대상 자체는 변경이 가능합니다. 만약 변경이 불가능한
객체를 가리키는 반복자(즉, const T* 포인터의 STL 대응물)가 필요하다면 const_iterator
를 쓰면 됩니다.

std::vector<int> vec;
...
const std::vector<int>::iterator iter = vec.begin();
				// iter는 T* const처럼 동작합니다.
*iter = 10;		// OK, iter가 가리키는 대상을 변경합니다.
++iter;			// 에러! iter는 상수입니다.

std::vector<int>::const_iterator cIter = vec.begin();
				// cIter는 const T*처럼 동작합니다.
*cIter = 10;	// 에러! *cIter가 상수이기 때문에 안됩니다.
++cIter;		// 이건 문제없습니다. cIter를 변경하니까요.

뭐니 뭐니 해도 가장 강력한 const의 용도는 함수 선언에 쓸 경우입니다. 함수 선언문에
있어서 const는 함수 반환 값, 각각의 매개변수, 멤버 함수 앞에 붙을 수 있고, 함수 전체
에 대해 const의 성질을 붙일 수 있습니다.

함수 반환 값을 상수로 정해 주면, 안전성이나 효율을 포기하지 않고도 시용자측의 에러 돌
발 상황을 줄이는 효과를 꽤 자주 볼 수 있게 됩니다. 한 예로, 항목 24에서 살펴볼 유리수
클래스에서 operator* 함수가 어떻게 선언되어 있는지를 보도록 하지요.

class Rational {...};

const Rational operator*(const Rational& lhs, const Rational& rhs);

첫인상이 까칠하다고 느끼는 프로그래머들이 꽤 있을 것 같습니다. operator* 의 반환 값
이 상수 객체일 이유를 어디서 찾겠느냐는 의견일 텐데요, 그런데 상수 객체로 되어 있지
않으면 사용자 쪽에서 저지르는 아래와 같은 어처구니없는 실수를 멍청히 지켜볼 수밖에 없
게 됩니다.

Rational a, b, c;
...
(a*b) = c;		// a*b의 결과에 대고 operator=를 호출하다니요!

두 수의 곱에 대입 연산을 취하고 싶은 프로그래머가 있을지는 모르겠지만, 이런 상황을 원
하지 않았는데도 무의식중에 경험해 본 프로그래머가 전자보다 훨씬 많다는 사실은 입니다.
어쩌다가 그냥 키보드를 잘못 누른 것이죠(그리고 bool로 암시적 변환이 가능한 타입도 포함됩
니다).

if (a * b = c) // 어흑, 나는 원래 비교하려고 그랬던 건데!

위의 코드는 a 및 b의 타입이 기본제공 타입이었다면 용서 없이 문법 위반에 걸리는 코드입
니다. 훌륭한 사용자 정의 타입의 특정 중 하나는 기본제공 타입과의 쓸데없는 비호환성
을 피한디는 것인데(항목 18 참조), 위에서 본 바와 같이 두 수의 곱에 대해 대입 연산이 되
도록 놓이두는 것이 바로 '쓸데없는' 경우가 되겠습니다. operator*의 반환 값을 const
로 정해 놓으면 이런 경우를 미연에 막을 수 있지요. 그렇기 때문에 상수 반환 값 지정이
정답이 되는 것이고요.

const 매개변수에 대해선 특별히 새로 할 이야기는 없습니다. 그냥 const 타입의 지역
객체와 특성이 똑같으니까요. 그리고 이것 역시 가능한 한 항상 사용하도록 하십시오. 매개
변수 혹은 지역 객체를 수정할 수 없게 하는 것이 목적이라면 const로 선언하는 것을 잊
지 말도록 합시다. 눈 딱 감고 여섯 글자만 더 눌러 보세요. 여러분의 참한 심성을 건드리는
"==로 생각하고 친 건데 실수로 =를 쳤네"와 비슷한 컴파일 에러를 보게 될 일이 없을 것
입니다.

상수 멤버 함수
멤버 함수에 붙는 const 키워드의 역할은 "해당 멤버 함수가 상수 객체에 대해 호출될 함
수이다"라는 사실을 알려 주는 것입니다. 그런데 이런 함수가 왜 중요할까요? 이유는 무려
두 가지입니다. 

첫째는 클래스의 인터페이스를 이해하기 좋게 하기 위해서인데, 그 클래스로 만들어진 객체를 
변경할 수 있는 함수는 무엇이고, 또 변경할 수 없는 함수는 무엇인가를 사용자 쪽에서 알고 
있어야 하는 것입니다. 

둘째는 이 키워드를 통해 상수 객체를 사용할수 있게 하자는 것인데, 코드의 효율을 위해 아주 
중요한 부분이기도 합니다. 항목 20에서 이야기하고 있듯이 C++ 프로그램의 실행 성능을 높
이는 핵심 기법 중 하나가 객체 전달을 '상수 객체에 대한 참조자(reference-to-const)'로 
진행하는 것이기 때문이죠. 그런데 이 기법이 제대로 살아 움직이려면 상수 상태로 전달된 
객체를 조작할 수 있는 const 멤버 함수, 즉 상수 멤버 함수가 준비되어 있어야 한다는 것이 
바로 포인트입니다.

const 키워드가 있고 없고의 차이만 있는 멤버 함수들은 오버로딩이 가능합니다. 이 성질
을 잘 모르고 지나치는 분들이 꽤 있는 것 같은데, C++의 아주 중요한 성질이니 꼭 외워
두세요. 한 예로, 문서의 한 구역을 나타내는 데 쓰려고 만든 클래스를 한 번 보시죠.

class TextBlock 
{
public:
	...
	const char& operator[](std::size_t position) const // 상수 객체에 대한
	{ return text[position]; }							// operator[]
	char& operator[](std::size_t position)		// 비상수 객체에 대한
	{ return text[position]; }					// operator[]	
private:
	std::string text;
};

위처럼 선언된 TextBlock의 operator[]는 다음과 같이 쓸 수 있습니다.

TextBlock tb("Hello");

std::cout << tb[O];	// TextBlock::operator[] 의
					// 비상수 멤버를 호출합니다.
const TextBlock ctb("World");

std::cout << ctb[O];	// TextBlock::operator[] 의
						// 상수 멤버를 호출합니다. 

참, 실제 프로그램에서 상수 객체가 생기는 경우는 1. 상수 객체에 대한 포인터 혹은 2. 상수
객체에 대한 참조자로 객체가 전달될 때입니다. 위의 ctb 예제는 이해를 돕기 위한 용도의
성격이 짙고, 아래의 예제가 더 실제의 경우와 가깝습니다.

void print(const TextBlock& ctb)	// 이 함수에서 ctb 상수 객체로 쓰입니다.
{
	std::cout<<ctb[0];		// TextBlock::operator[]의 상수
							// 멤버를 호출합니다.
	...
}

operator[]를 '오버로드(overload)'해서 각 버전마다 반환 타입을 다르게 가져갔기 때문
에, TextBlock의 상수 객체와 비상수 객체의 쓰임새가 달라집니다. 

std::cout<<tb[0];		// 좋습니다. 비상수 버전의 TextBlock 객체를 읽습니다.

tb[0] = 'x';			// 역시 문제없죠. 비상수 버전의 TextBlock 객체를 읽습니다.

std::cout<<ctb[0];	// 이것도 됩니다. 상수 버전의 TextBlock 객체를 읽습니다.

ctb[0] = 'x';		// 컴파일 에러 발생: 상수 버전의 TextBlock 객체에 대해 쓰기는
					// 안 됩니다.

주의할 것이 하나 있는데, 넷째 줄에서 발생한 에러는 순전히 operator[]의 반환 타입
(return type) 때문에 생긴 것이란 점입니다. 그러니까 operator[] 호출이 잘못된 것은
없습니다. 이 에러는 const char& 타입에 대입 연산을 시도했기 때문에 생긴 것입니다.
상수 멤버로 되어 있는 operator[]의 반환 타입 이 const char& 이니까요.

하나 더 눈여겨 볼 부분이 있습니다. operator[]의 비상수 멤버는 char의 참조자
(refernce)를 반환한다는 것인데, char 하나만 쓰면 안 된다는 점을 꼭 주의하십시오. 만약
operator[]가 그냥 char를 반환하게 만들어져 있으면, 다음과 같은 문장이 컴파일되지
않게 됩니다.

tb[O] = 'x';

왜 그럴까요? 기본제공 타입을 반환하는 함수의 반환 값을 수정하는 일은 절대로 있을 수 없
기 때문입니다. 설령 이 합법적으로 통한다고 해도, 반환 시 '값에 의한 반환'을 수행하
는 C++의 성질(항목 20 참조)이 뒤에 떡 버티고 있습니다. 즉, 수정되는 값은 tb.text[O]의
사본이지, tb.text[0] 자체가 아니라는 거죠. 아마 이게 여러분이 의도한 동작은 아닐 것입
니다.

여기까지 하고, 잠깐 숨고르기 시간을 가져보는 게 좋겠습니다. 어떤 멤버 함수가 상수 멤버
(const)라는 것이 대체 어떤 의미일까요? 여기에는 굵직한 양대 개념이 자리 잡고 있습니다.
하나는 비트수준 상수성[bitwise constness, 다른 말로 물리적 상수성 phiyscal constness)
이라고도 함]이고, 또 하나는 논리적 상수성(logical constness)입니다.

비트수준 상수성은 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야(정적
맴버는 제외합니다) 그 멤버 함수가 'const'임을 인정하는 개념입니다. 
즉, 그 객체를 구성하는 비트들 중 어떤 것도 바꾸면 안 된다는 것입니다. 
비트수준 상수성을 사용하면 상수성 위반을 발견하는 데 힘이 많이 들지 않습니다. 
***컴파일러는 데이터 멤버에 대해 대입 연산이 수행되었는지만 보면 되니까요.***

사실 C++에서 정의하고 있는 상수성이 비트수준 상수성입니다. 그리고 상수 멤버 함수는 그 
함수가 호출된 객체의 어떤 비정적 멤버도 수정할 수 없게 되어 있지요.

그런데, 애석하게도 '제대로 const'로 동작하지 않는데도 이 비트수준 상수성 검사를 통과하
는 멤버 함수들이 적지 않다는 점이 우리를 슬프게 합니다. 어떤 포인터가 가리키는 대상을
수정하는 멤버 함수들 중 싱당수가 이런 안타까운 경우에 속하고 있습니다. 하지만 그 포인터
가 객체의 멤버로 들어 있는 한, 이 함수는 비트수준 상수성을 갖는 것으로 판별되고 컴
파일러도 뭐라고 불평하지 않습니다. 그런데 이것 때문에 상식적으로 이해가 안 되는 동작
이 생길 수 있습니다. 예를 들어 TextBlock 비슷한 클래스를 하나 만들어서 갖고 있는데,
내부 데이터가 string이 아니고 char*로 관리된다고 가정합시다. 이렇게 만든 이유는
string 객체를 사용할 수 없는 C API에도 이것을 쓸 수 있게 하기 위해서 겠지요. 어쨌
든 한번 보죠.

class CTextBlock 
{
public:
	...
	char& operator[](std::size_t position) const// 부적절한(그러나 비트수준
	{ return text[position]; }					// 상수성이 있어서 허용되는)
private:										// operator[]의 선언
	char* pText;
};