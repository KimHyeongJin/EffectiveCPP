항목 3: 낌새만 보이면 const 를 들이대 보자!

const의 면모에 대해 생각해 볼 때 정말 멋지다고 말할 수 는 부분이 있다면 아마도
'의미적인 제약'(const 키워가 붙은 객체는 외부 변경을 불가능하게 한다)을 소스 코드 수준
에서 붙인다는 점과 컴파일러가 이 제약을 단단히 지켜준다는 점일 것입니다. 어떤 값(객체
의 내용)이 불변이어야 한다는 제작자의 의도를 컴파일러 및 다른 프로그래머와 나눌 수 있
는 수단이라고나 할까요. 값이 변하면 안 되는 게 맞는다면, 여러분도 반드시 지켜야 합니
다. 이렇게 해야 컴파일러가 제약 위반을 막는 일에 한몫 거들 수 있기 때문입니다.

const 키워드는 생긴 것 답지 않게 그야말로 팔방미인입니다. 클래스 바깥에서는 전역 혹
은 네임스페이스 유효범위의 상수를 선언(정의)하는 데 쓸 수 있습니다(항목 2 참조). 그뿐 아
니라 파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const를 붙일 수 있습
니다. 클래스 내부의 경우에는, 정적 멤버 및 비정적 데이터 멤버 모두를 상수로 선언할 수
있습니다. 포인터는 어떨까요? 기본적으로는 포인터 자체를 상수록 혹은 포인터가 가리키는
데이터를 상수로 지정할 수 있는데, 둘 다 지정할 수도 있고 아무것도 지정하지 않을 수도
있습니다.

char greeting[] = "Hello";

char* p = greeting;		// 비상수 포인터, 비상수 데이터

const char* p = greeting;	// 비상수 포인터, 상수 데이터

char * const p = greeting;	// 상수 포인터, 비상수 데이터

const char * const p = greeting;	// 상수 포인터, 상수 데이터

//잊어 먹지 말고 암기!!
C T N			// 상수 변수, const type name
C T* N(=T C* N)	// 비상수 포인터, 상수 데이터, const type* name
C T * C N(=T C * C N)	// 상수 포인터, 상수 데이터, const type * const name
T * C N			// 상수 포인터, 비상수 데이터

변덕에 일평생을 바쳐온 사람이 만든 문법처럼 보이지만 그렇지 않습니다. 잘 보세요. const
키워드가 *표의 왼쪽에 있으면 포인터가 가리키는 대상이 상수인 반면, const가 *표의 오
른쪽에 있는 경우엔 포인터 자체가 상수입니다. const가 *표의 양쪽에 다 있으면 포인터가
가리키는 대상 및 포인터가 다 상수라는 뜻이죠.

포인터가 가리키는 대상을 상수로 만들 때 const를 사용하는 스타일은 조금씩 다릅니다.
어떤 프로그래머는 타입 앞에 const를 붙이기도 합니다. 그 외에는 타입의 뒤쪽이자 *표
의 앞에 const를 붙이는 사람들이겠지요. 의미적인 차이는 전혀 없습니다. 즉, 아래의 함
수들이 받아들이는 매개변수 타입은 모두 똑같디는 야기입니다.

void f1(const Widget *pw);	// f1 은 상수 Widget 객체에 대한
							// 포인터 를 매개변수로 취합니다.
void f2(Widget const *pw);	// f2 도 그렇고요.

두 가지 형태 모두가 현업 개발자들의 코드에 아주 잘 쓰이고 있으므로, 눈에 어색해 하지
않도록 잘 익혀 두도록 합시다.

STL 반복자(iterator)는 포인터를 본뜬 것이기 때문에, 기본적인 동작 원리가 T* 포인터와
진짜 흡사합니다. 어떤 반복자를 const로 선언하는 일은 포인터를 상수로 선언하는 것(즉,
T* const 포인터)과 같습니다. 반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가
허용되지 않지만, 반복자가 가리키는 대상 자체는 변경이 가능합니다. 만약 변경이 불가능한
객체를 가리키는 반복자(즉, const T* 포인터의 STL 대응물)가 필요하다면 const_iterator
를 쓰면 됩니다.

std::vector<int> vec;
...
const std::vector<int>::iterator iter = vec.begin();
				// iter는 T* const처럼 동작합니다.
*iter = 10;		// OK, iter가 가리키는 대상을 변경합니다.
++iter;			// 에러! iter는 상수입니다.

std::vector<int>::const_iterator cIter = vec.begin();
				// cIter는 const T*처럼 동작합니다.
*cIter = 10;	// 에러! *cIter가 상수이기 때문에 안됩니다.
++cIter;		// 이건 문제없습니다. cIter를 변경하니까요.

뭐니 뭐니 해도 가장 강력한 const의 용도는 함수 선언에 쓸 경우입니다. 함수 선언문에
있어서 const는 함수 반환 값, 각각의 매개변수, 멤버 함수 앞에 붙을 수 있고, 함수 전체
에 대해 const의 성질을 붙일 수 있습니다.

함수 반환 값을 상수로 정해 주면, 안전성이나 효율을 포기하지 않고도 시용자측의 에러 돌
발 상황을 줄이는 효과를 꽤 자주 볼 수 있게 됩니다. 한 예로, 항목 24에서 살펴볼 유리수
클래스에서 operator* 함수가 어떻게 선언되어 있는지를 보도록 하지요.

class Rational {...};

const Rational operator*(const Rational& lhs, const Rational& rhs);

첫인상이 까칠하다고 느끼는 프로그래머들이 꽤 있을 것 같습니다. operator* 의 반환 값
이 상수 객체일 이유를 어디서 찾겠느냐는 의견일 텐데요, 그런데 상수 객체로 되어 있지
않으면 사용자 쪽에서 저지르는 아래와 같은 어처구니없는 실수를 멍청히 지켜볼 수밖에 없
게 됩니다.

Rational a, b, c;
...
(a*b) = c;		// a*b의 결과에 대고 operator=를 호출하다니요!

두 수의 곱에 대입 연산을 취하고 싶은 프로그래머가 있을지는 모르겠지만, 이런 상황을 원
하지 않았는데도 무의식중에 경험해 본 프로그래머가 전자보다 훨씬 많다는 사실은 입니다.
어쩌다가 그냥 키보드를 잘못 누른 것이죠(그리고 bool로 암시적 변환이 가능한 타입도 포함됩
니다).

if (a * b = c) // 어흑, 나는 원래 비교하려고 그랬던 건데!

위의 코드는 a 및 b의 타입이 기본제공 타입이었다면 용서 없이 문법 위반에 걸리는 코드입
니다. 훌륭한 사용자 정의 타입의 특정 중 하나는 기본제공 타입과의 쓸데없는 비호환성
을 피한디는 것인데(항목 18 참조), 위에서 본 바와 같이 두 수의 곱에 대해 대입 연산이 되
도록 놓이두는 것이 바로 '쓸데없는' 경우가 되겠습니다. operator*의 반환 값을 const
로 정해 놓으면 이런 경우를 미연에 막을 수 있지요. 그렇기 때문에 상수 반환 값 지정이
정답이 되는 것이고요.

const 매개변수에 대해선 특별히 새로 할 이야기는 없습니다. 그냥 const 타입의 지역
객체와 특성이 똑같으니까요. 그리고 이것 역시 가능한 한 항상 사용하도록 하십시오. 매개
변수 혹은 지역 객체를 수정할 수 없게 하는 것이 목적이라면 const로 선언하는 것을 잊
지 말도록 합시다. 눈 딱 감고 여섯 글자만 더 눌러 보세요. 여러분의 참한 심성을 건드리는
"==로 생각하고 친 건데 실수로 =를 쳤네"와 비슷한 컴파일 에러를 보게 될 일이 없을 것
입니다.

상수 멤버 함수
멤버 함수에 붙는 const 키워드의 역할은 "해당 멤버 함수가 상수 객체에 대해 호출될 함
수이다"라는 사실을 알려 주는 것입니다. 그런데 이런 함수가 왜 중요할까요? 이유는 무려
두 가지입니다. 

첫째는 클래스의 인터페이스를 이해하기 좋게 하기 위해서인데, 그 클래스로 만들어진 객체를 
변경할 수 있는 함수는 무엇이고, 또 변경할 수 없는 함수는 무엇인가를 사용자 쪽에서 알고 
있어야 하는 것입니다. 

둘째는 이 키워드를 통해 상수 객체를 사용할수 있게 하자는 것인데, 코드의 효율을 위해 아주 
중요한 부분이기도 합니다. 항목 20에서 이야기하고 있듯이 C++ 프로그램의 실행 성능을 높
이는 핵심 기법 중 하나가 객체 전달을 '상수 객체에 대한 참조자(reference-to-const)'로 
진행하는 것이기 때문이죠. 그런데 이 기법이 제대로 살아 움직이려면 상수 상태로 전달된 
객체를 조작할 수 있는 const 멤버 함수, 즉 상수 멤버 함수가 준비되어 있어야 한다는 것이 
바로 포인트입니다.

const 키워드가 있고 없고의 차이만 있는 멤버 함수들은 오버로딩이 가능합니다. 이 성질
을 잘 모르고 지나치는 분들이 꽤 있는 것 같은데, C++의 아주 중요한 성질이니 꼭 외워
두세요. 한 예로, 문서의 한 구역을 나타내는 데 쓰려고 만든 클래스를 한 번 보시죠.

class TextBlock 
{
public:
	...
	const char& operator[](std::size_t position) const // 상수 객체에 대한
	{ return text[position]; }							// operator[]
	char& operator[](std::size_t position)		// 비상수 객체에 대한
	{ return text[position]; }					// operator[]	
private:
	std::string text;
};

위처럼 선언된 TextBlock의 operator[]는 다음과 같이 쓸 수 있습니다.

TextBlock tb("Hello");

std::cout << tb[O];	// TextBlock::operator[] 의
					// 비상수 멤버를 호출합니다.
const TextBlock ctb("World");

std::cout << ctb[O];	// TextBlock::operator[] 의
						// 상수 멤버를 호출합니다. 

참, 실제 프로그램에서 상수 객체가 생기는 경우는 1. 상수 객체에 대한 포인터 혹은 2. 상수
객체에 대한 참조자로 객체가 전달될 때입니다. 위의 ctb 예제는 이해를 돕기 위한 용도의
성격이 짙고, 아래의 예제가 더 실제의 경우와 가깝습니다.

void print(const TextBlock& ctb)	// 이 함수에서 ctb 상수 객체로 쓰입니다.
{
	std::cout<<ctb[0];		// TextBlock::operator[]의 상수
							// 멤버를 호출합니다.
	...
}

operator[]를 '오버로드(overload)'해서 각 버전마다 반환 타입을 다르게 가져갔기 때문
에, TextBlock의 상수 객체와 비상수 객체의 쓰임새가 달라집니다. 

std::cout<<tb[0];		// 좋습니다. 비상수 버전의 TextBlock 객체를 읽습니다.

tb[0] = 'x';			// 역시 문제없죠. 비상수 버전의 TextBlock 객체를 읽습니다.

std::cout<<ctb[0];	// 이것도 됩니다. 상수 버전의 TextBlock 객체를 읽습니다.

ctb[0] = 'x';		// 컴파일 에러 발생: 상수 버전의 TextBlock 객체에 대해 쓰기는
					// 안 됩니다.

주의할 것이 하나 있는데, 넷째 줄에서 발생한 에러는 순전히 operator[]의 반환 타입
(return type) 때문에 생긴 것이란 점입니다. 그러니까 operator[] 호출이 잘못된 것은
없습니다. 이 에러는 const char& 타입에 대입 연산을 시도했기 때문에 생긴 것입니다.
상수 멤버로 되어 있는 operator[]의 반환 타입 이 const char& 이니까요.

하나 더 눈여겨 볼 부분이 있습니다. operator[]의 비상수 멤버는 char의 참조자
(refernce)를 반환한다는 것인데, char 하나만 쓰면 안 된다는 점을 꼭 주의하십시오. 만약
operator[]가 그냥 char를 반환하게 만들어져 있으면, 다음과 같은 문장이 컴파일되지
않게 됩니다.

tb[O] = 'x';

왜 그럴까요? 기본제공 타입을 반환하는 함수의 반환 값을 수정하는 일은 절대로 있을 수 없
기 때문입니다. 설령 이 합법적으로 통한다고 해도, 반환 시 '값에 의한 반환'을 수행하
는 C++의 성질(항목 20 참조)이 뒤에 떡 버티고 있습니다. 즉, 수정되는 값은 tb.text[O]의
사본이지, tb.text[0] 자체가 아니라는 거죠. 아마 이게 여러분이 의도한 동작은 아닐 것입
니다.

여기까지 하고, 잠깐 숨고르기 시간을 가져보는 게 좋겠습니다. 

어떤 멤버 함수가 상수 멤버(const)라는 것이 대체 어떤 의미일까요????
여기에는 굵직한 양대 개념이 자리 잡고 있습니다.
하나는 비트수준 상수성[bitwise constness, 다른 말로 물리적 상수성 phiyscal constness)
이라고도 함]이고, 또 하나는 논리적 상수성(logical constness)입니다.

비트수준 상수성(물리적 상수성)은 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 
않아야(정적맴버는 제외합니다) 그 멤버 함수가 'const'임을 인정하는 개념입니다. 
즉, 그 객체를 구성하는 비트들 중 어떤 것도 바꾸면 안 된다는 것입니다. 
비트수준 상수성을 사용하면 상수성 위반을 발견하는 게 어렵지 않습니다.
***컴파일러는 데이터 멤버에 대해 대입 연산이 수행되었는지만 보면 되니까요.***

사실 C++에서 정의하고 있는 상수성이 비트수준 상수성입니다. 그리고 상수 멤버 함수는 그 
함수가 호출된 객체의 어떤 비정적 멤버도 수정할 수 없게 되어 있지요.

그런데, 애석하게도 '제대로 const'로 동작하지 않는데도 이 비트수준 상수성 검사를 통과하
는 멤버 함수들이 적지 않다는 점이 우리를 슬프게 합니다. 어떤 포인터가 가리키는 대상을
수정하는 멤버 함수들 중 싱당수가 이런 안타까운 경우에 속하고 있습니다. 하지만 그 포인터
가 객체의 멤버로 들어 있는 한, 이 함수는 비트수준 상수성을 갖는 것으로 판별되고 컴
파일러도 뭐라고 불평하지 않습니다. 그런데 이것 때문에 상식적으로 이해가 안 되는 동작
이 생길 수 있습니다. 예를 들어 TextBlock 비슷한 클래스를 하나 만들어서 갖고 있는데,
내부 데이터가 string이 아니고 char*로 관리된다고 가정합시다. 이렇게 만든 이유는
string 객체를 사용할 수 없는 C API에도 이것을 쓸 수 있게 하기 위해서 겠지요. 어쨌
든 한번 보죠.

class CTextBlock 
{
public:
	...
	char& operator[](std::size_t position) const// 부적절한(그러나 비트수준
	{ return pText[position]; }					// 상수성이 있어서 허용되는)
private:										// operator[]의 선언
	char* pText;
};

코드에 나와 있듯이 operator[] 함수가 상수 멤버 함수로 선언되어 있습니다(틀린 건데 말
이죠). 이 함수는 그럼에도 불구하고 해당 객체의 내부 데이터에 대한 참조자를 버젓이 반환
합니다(관련된 자세한 사항은 항목 28 참조). 이건 일단 그렇다 치고 operator[]의 내부 
코드만 보면 pText는 안 간드린다는 점은 확실합니다. 그러니 컴파일러가 이 operator[]에 
대한 코드를 생성할 때 불평할 이유가 없겠지요. 어쨌든 비트수준에서 상수성을 지키고 있고? 
컴파일러 선에서는 이것까지만 점검하면 이니까요. 하지만 이로 인해 어떤 사태가 생길지는 
아래에서 확인해 보도록 합시다.

const CTextBlock cctb("Hello");	// 상수 객체를 선언합니다.

char *pc = &cctb[O];	// 상수 버전의 operator[]를 호출하여 cctb의
						// 내부 데이터에 대한 포인터를 얻습니다.
*pc = 'J';				// cctb는 이제 Hello 라는 값을 갖습니다.

확실히 무엇인가가 잘못됐습니다. 어떤 값으로 초기화된 상수 객체를 하나 만들어 놓고 이
것에다 상수 멤버 함수를 호출했더니 값이 변해버린 것입니다!

논리적 상수성이란 개념은 이런 황당한 상황을 보완하는 대체 개념으로 나오게 되었습니다.
이 개념을 부르짖는 사람들의 주장은 이렇습니다. 상수 멤버 함수라고 해서 객체의 한 비트
도 수정할 수 없는 것이 아니라 일부 몇 비트 정도는 꿀 수 있되, 그것을 사용자측에서
알아채지 못하게만 하면 상수 멤버 자격이 있다는 것입니다. 예를 하나 들어 보겠습니다.
CTextBlock 클래스는 문장 구역의 길이를 시용자들이 요구할 때마다 이 정보를 캐시해
둘 수 있을 텐데요, 그래서 다음과 같은 멤버를 둘 수 있을 것입니다.

class CTextBlock 
{
public:
	...
	std::size_t length() const;
private:
	char* pText;
	std::size_t textLength;		// 바로 직전에 계산한 텍스트 길이
	bool lengthIsValid;			// 이 길이가 현재 유효한가?
};

std::size_t CTextBlock::length() const
{
	if(!lengthIsValid)
	{
		textLength = std::strlen(pText);// 에러! 상수 멤버 함수 안에서는
		lengthIsValid = true;			// textLength 및 lengthIsValid에
	}									// 대입할 수 없습니다.
	return textLegnth;
}

length의 구현은 너무나도 자명하게 '비트수준 상수성(물리적 상수성)'과 거리가 멀다.

textLength 및 lengthIsValid가 바뀔 수 있으니까요. 그렇지만 CTextBlock의
상수 객체에 대해서는 당연히 아무 문제가 없어야 할 것 같은 코드입니다. 컴파일러는 에러
를 쏟아낼 게 뻔합니다. 컴파일러의 검열을 통과하려면 비트 수준의 상수성 이 지켜져야 합
니다. 이런 상황에서는 어떻게 해야 할까요?

해답은 단순합니다. const에 맞서는 C++의 변신 비기, mutable을 사용하는 것입니다.
mutable은 비정적 데이터 멤버를 비트수준 상수성의 족쇄에서 풀어 주는 아름다운 오색
약수 같은 키워드입니다. 아래를 보시죠.

class CTextBlock 
{
public:
	...
	std::size_t length() const;
private:
	char* pText;
	mutable std::size_t textLength;		// 이 데이터 멤버들은 어떤 순간에도
	mutable bool lengthIsValid;			// 수정이 가능합니다. 심지어 상수 멤버
};										// 함수 안에서도 수정 할 수 있습니다.

std::size_t CTextBlock::length() const
{
	if(!lengthIsValid)
	{
		textLength = std::strlen(pText);// 이제 문제 없습니다.
		lengthIsValid = true;			// 문제 없습니다.
	}
	return textLegnth;
}



상수 멤버 및 비상수 멤버 함수에 코드 중복 현상을 피하는 방법

mutable은 '생각지도-않던-비트-수준-상수성이-웬-말이냐' 문제를 단어 하나로 하는 해결하는
꽤 괜찮은 방법임엔 틀림없지만, 이것으로 const에 관련된 골칫거리 전부를 말끔히 씻어내
진 못합니다. 또 예를 들어 보죠. TextBlock(및 CTextBlock)의 operator[] 함수가
지금은 특정 문자의 참조자만 반환하고 있지만, 이것 말고도 여러 가지를 더 할 수도 있을
것입니다. 경계 검사라든지 접근정보 로깅도 그렇고, 게다가 내부자료 무결성 검증도 못할
리 없지요. 이런저런 코드를 모조리 operator[]의 상수/비상수 버전에 넣어 버리면(이제
만만치 않게 길어진 '암시적' 인라인 함수를 보며 조마조마했던 마음도 일찌감치 은하계 저편으로
날아가고 말이죠. 항목 30을 보세요) 어느덧 코드 판박이 괴물이 떡 하니 우리 앞에서 뒹굴고
있게 됩니다.

class TextBlock
{
public:
	...
	const char& operator[](std:;size_t position) const
	{
		...						// 경계 검사
		...						// 접근 데이터 로깅
		...						// 자료 무결성 검증
		return text[position];
	}

	char& operator[](std::size_t position)
	{
		...						// 경계 검사
		...						// 접근 데이터 로깅
		...						// 자료 무결성 검증
		return text[position];
	}

private:
	std::string text;
};

출석 부르기도 무서운 코드 중복입니다. 코드 중복과 함께 꼭 따라 나오는 말썽꾸러기 친구
녀석들이 더 큰 골치입니다. 컴파일 시간, 유지보수, 코드 크기 부풀림... 감당할 수 있겠어
요? 경계 검사 등의 자질구레한 코드를 별도의 멤버 함수(물론 private 멤버로)에 옮겨 두고
이것을 operator[]의 양 버전에서 호출하게 만들면 제법 괜찮을 것 같다고 생각하겠지
만, 그래도 코드 중복은 여전합니다. 이렇게 해도 함수 호출이 두 번씩 되잖아요? return
문은 또 중복 코드 아닙니까?

안 때릴 테니까 솔직히 말해 보세요. 진짜로 원하는 것을 감추고 자신을 속이고 있진 않나
요? 사실은 operator[]의 핵심 기능을 한 번만 구현해 두고 이것을 두 번 사용하고 싶
지 않느냔 말이에요. 그러니까, operator[]의 양 버전 중 하나만 제대로 만들고 다른 버
전은 이것을 호출하는 식으로 만들고 싶은 거죠? 그러고 보니, const 껍데기를 캐스팅으로
날리면 어떨까 하는 생각에 이르게 됩니다.

기본적으로, 캐스팅은 일반적으로도 통념적으로도 썩 좋지 않은 아이디어입니다. 심지어 이
책에서도 이거 하지 말라는 이야기를 짤막하게 하지 못해 아예 한 항목이 만들어져 버렸죠
(항목 27). 하지만 코드 중복도 결코 애들 소풍놀이가 아닙니다. 자, 잘 생각해 봅시다. 지금
의 경우, operator[]의 상수 버전은 비상수 버전과 비교해서 하는 일이 정확히 똑같습니
다. 단지 다른 점이 있다면 반환 타입에 const 키워드가 덧붙어 있다는 것뿐이죠. 따라서
여기서는 케스팅을 써서 반환 타입으로부터 const 껍데기를 없애더라도 안전합니다. 왜냐
하면 비상수 operator[] 함수를 호출하는 쪽이라면 그 호출부엔 비상수 객체가 우선적
으로 들어 있었을 게 분명하기 때문입니다. 그렇지 않았다면 비상수 멤버 함수를 호출했을
리도 만무하고요. 그래서 결론은 이렇게 나옵니다. 캐스팅이 필요하긴 하지만, 안전성도 유
지하면서 코드 중복을 피하는 방법은 비상수 operator[]가 상수 버전을 호출하도록 구
현하는 것입니다. 아래에 그 코드를 써 보았는데, 불친절한 첫인상이지만 설명을 읽고 나면
눈에 확 들어올 것입니다.

class TextBlock
{
public:
	...
	const char& operator[](std:;size_t position) const	// 이전과 동일
	{
		...
		...
		...
		return text[position];
	}

	char& operator[](std::size_t position)	// 상수 버전 operator[]를 호출하고 끝
	{
		return const_cast<char&>(	// operator[]의 반환 타입에 캐스팅을 적용,
									// const 를 떼어냅니다.
			static_cast<const TextBlock&>	// *this의 타입에 const를 붙입니다.
				(*this)[position];			// operator[]의 상수 버전을 호출합니다.
	}
	...
};

보시면 알겠지만 캐스팅이 한 번이 아니라 두 번 되어 있습니다. 자, 곰곰이 생각해 보죠.
지금 해야 하는 일은 비상수 operator[]가 상수 버전을 호출하게 하는 것입니다. 그런데
비상수 operator[] 속에서 그냥 operator[]라고 적으면 그 자신이 재귀적으로 호출
되고 말 테죠. 뭐, 아마도 처음 백만 번 정도 돌고 나면 덜 웃기겠죠? 이러한 무한 재귀호출
을 피해 가기 위해서는 "상수 operator[]를 호출하고 싶다"라는 열망을 코드로 표현해
주어야 하는데, 이에 대한 직접적인 방법이 없는 게 좀 큰일입니다. 그 대신으로 생각한 차선책
이 *this의 타입 캐스팅입니다. 원래의 타입인 TextBlock& 에서 const TextBlock&
으로 바꾸는 것이죠. 그렇습니다. 캐스팅을 쓴 이유는 const가 붙어야 하기 때문이었습니다.
결국 정리하면, 두 개의 캐스팅 중 첫 번째 것은 *this에 const를 붙이는 캐스팅이
고(비상수 operator[]에서 상수 버전을 호출하기 위해), 두 번째 것은 상수 operator[]의
반환 값에서 const를 떼어내는 캐스팅입니다.

const를 붙이는 캐스팅은 안전한 타입 변환(비상수 객체에서 상수 객체로 바꾸는)을 강제로
진행하는 것뿐이기 때문에 static_cast만 써도 딱 맞습니다. 반면에 const를 제거하는
캐스팅은 const_cast밖에 없으므로 별다른 선택의 여지가 없습니다(하긴 기술적으로 안
되는 건 없습니다. C 스타일 캐스팅을 쓰면 잘 되긴 하지요. 하지만 항목 27에서 볼 수 있듯이 그
런 캐스탱은 잘 된 선택이라고 보기 힘듭니다. static_cast 혹은 const_cast 동의 키워드가
웬지 낯설다고 느껴지는 분은 항목 27을 보세요. 개괄적인 설명을 잘 해두었으니까요).

이런저런 걸림돌을 넘고 넘어, 어쨌든 연산자 함수 하나를 호출하는 것이 전부입니다. 그래
서인지 문법이 조금 이상해 보이기도 하죠. 예쁜이 코드 대회에 나가더라도 똑 떨어질 게
분명하지만, 코드 중복을 피하자는 원하는 효과를 얻을 수 있었습니다. operator[]의 상
수 버전을 써서 비상수 버전을 구현한 것만 가지고 말이죠. 예쁜 문법 스타일까지 구겨가면
서 원하는 것을 해야 하는가의 판단은 여러분 몫이겠지만, 비상수 멤버 함수의 구현에 상수
멤버 쌍둥이를 사용하는 기법 자체는 꼭 알아둘 가치가 있다는 점만은 확실히 말씀드릴 수
있습니다.

참, 알아둘 가치로 보면 위의 것보다 중요한 이야기 하나를 빼놓을 수 없습니다. 앞의 방법
을 뒤집어서 하는 쪽(즉, 코드 중복 회피를 위해 상수 버전이 비상수 버전을 호출하게 만드는 것)
도 생각할 수 있는데, 그것은 우리가 원하는 바가 아닙니다. 혹시 잊으셨을까봐 재차 강조합
니다만, 상수 멤버 함수는 해당 객체의 논리적인 상태를 바꾸지 않겠다고 컴파일러와 굳게
약속한 함수인 반면, 비상수 멤버 함수는 이런 약속 같은 걸 하지 않습니다. 즉, 어쩌다가
상수 멤버에서 비상수 멤버를 호출하게 되면, 수정하지 않겠다고 약속한 그 객체를 배신하
는 셈이 되고 그 객체는 변경될 위험에 빠질 수 있습니다. 그렇기 때문에 상수 멤버 함수에
서 비상수 멤버 함수를 호출하면 틀리다는 이야기가 나오는 것입니다. 실제로, 상수 멤버 함
수에서 비상수 멤버 함수를 호출하는 코드를 어떻게든 컴파일하려면 const_cast를 적용
해서 *this에 붙은 const를 떼어내어야 하는데, 이게 온갖 재앙의 씨앗입니다. 이것의
역순 호출(위에서 우리가 했던 것 말이에요)은 안전성에서 문제가 없습니다. 상수 멤버 함수
안에서는 그 객체를 바꾸든 안 바꾸든 맘대로 할 수 있기 때문에, 거기에서 상수 멤버 함수
를 호출한다고 해서 특별히 잘못될 리가 없습니다. 위의 코드에서 보셨듯이 *this에 대해
static_cast가 제대로 작동히는 이유가 바로 이것 때문입니다. const에 관련된 위험이
없거든요.

이번 항목이 시작되자마자 말씀드렸다시피, const는 참으로 대단한 축복입니다. 포인터나
반복자에 대해서 그렇고, 포인터/반복자/참조자가 가리키는 객체에 대해서 그렇고, 함수의
매개변수 및 반환 타입에 대해서도 마찬가지이며, 지역 변수는 물론이고 멤버 함수 까지
const는 매우 든든한 친구입니다. 할 수 있으면 아끼지 말고 남발하세요. 저질러도 후회
없을 것입니다.

이것만은 잊지 말자!
*	const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 줍니다. const
	는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을
	수 있으며, 멤버 함수에도 붙을 수 습니다.
*	컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 여러분은 개념적인(논리적인)
	상수성을 사용해서 프로그래밍해야 합니다.
*	상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드
	중복을 피하는 것이 좋은데, 이때 비상수 버전이 상수 버전을 호출하도록 만드세요.