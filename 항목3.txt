항목 3: 낌새만 보이면 const 를 들이대 보자!

const의 면모에 대해 생각해 볼 때 정말 멋지다고 말할 수 는 부분이 있다면 아마도
'의미적인 제약'(const 키워가 붙은 객체는 외부 변경을 불가능하게 한다)을 소스 코드 수준
에서 붙인다는 점과 컴파일러가 이 제약을 단단히 지켜준다는 점일 것입니다. 어떤 값(객체
의 내용)이 불변이어야 한다는 제작자의 의도를 컴파일러 및 다른 프로그래머와 나눌 수 있
는 수단이라고나 할까요. 값이 변하면 안 되는 게 맞는다면, 여러분도 반드시 지켜야 합니
다. 이렇게 해야 컴파일러가 제약 위반을 막는 일에 한몫 거들 수 있기 때문입니다.

const 키워드는 생긴 것 답지 않게 그야말로 팔방미인입니다. 클래스 바깥에서는 전역 혹
은 네임스페이스 유효범위의 상수를 선언(정의)하는 데 쓸 수 있습니다(항목 2 참조). 그뿐 아
니라 파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 const를 붙일 수 있습
니다. 클래스 내부의 경우에는, 정적 멤버 및 비정적 데이터 멤버 모두를 상수로 선언할 수
있습니다. 포인터는 어떨까요? 기본적으로는 포인터 자체를 상수록 혹은 포인터가 가리키는
데이터를 상수로 지정할 수 있는데, 둘 다 지정할 수도 있고 아무것도 지정하지 않을 수도
있습니다.

char greeting[] = "Hello";

char* p = greeting;		// 비상수 포인터, 비상수 데이터

const char* p = greeting;	// 비상수 포인터, 상수 데이터

char * const p = greeting;	// 상수 포인터, 비상수 데이터

const char * const p = greeting;	// 상수 포인터, 상수 데이터

//잊어 먹지 말고 암기!!
C T N			// 상수 변수, const type name
C T* N(=T C* N)	// 비상수 포인터, 상수 데이터, const type* name
C T * C N(=T C * C N)	// 상수 포인터, 상수 데이터, const type * const name
T * C N			// 상수 포인터, 비상수 데이터

변덕에 일평생을 바쳐온 사람이 만든 문법처럼 보이지만 그렇지 않습니다. 잘 보세요. const
키워드가 *표의 왼쪽에 있으면 포인터가 가리키는 대상이 상수인 반면, const가 *표의 오
른쪽에 있는 경우엔 포인터 자체가 상수입니다. const가 *표의 양쪽에 다 있으면 포인터가
가리키는 대상 및 포인터가 다 상수라는 뜻이죠.

포인터가 가리키는 대상을 상수로 만들 때 const를 사용하는 스타일은 조금씩 다릅니다.
어떤 프로그래머는 타입 앞에 const를 붙이기도 합니다. 그 외에는 타입의 뒤쪽이자 *표
의 앞에 const를 붙이는 사람들이겠지요. 의미적인 차이는 전혀 없습니다. 즉, 아래의 함
수들이 받아들이는 매개변수 타입은 모두 똑같디는 야기입니다.

void f1(const Widget *pw);	// f1 은 상수 Widget 객체에 대한
							// 포인터 를 매개변수로 취합니다.
void f2(Widget const *pw);	// f2 도 그렇고요.

두 가지 형태 모두가 현업 개발자들의 코드에 아주 잘 쓰이고 있으므로, 눈에 어색해 하지
않도록 잘 익혀 두도록 합시다.

STL 반복자(iterator)는 포인터를 본뜬 것이기 때문에, 기본적인 동작 원리가 T* 포인터와
진짜 흡사합니다. 어떤 반복자를 const로 선언하는 일은 포인터를 상수로 선언하는 것(즉,
T* const 포인터)과 같습니다. 반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가
허용되지 않지만, 반복자가 가리키는 대상 자체는 변경이 가능합니다. 만약 변경이 불가능한
객체를 가리키는 반복자(즉, const T* 포인터의 STL 대응물)가 필요하다면 const_iterator
를 쓰면 됩니다.

std::vector<int> vec;
...
const std::vector<int>::iterator iter = vec.begin();
				// iter는 T* const처럼 동작합니다.
*iter = 10;		// OK, iter가 가리키는 대상을 변경합니다.
++iter;			// 에러! iter는 상수입니다.

std::vector<int>::const_iterator cIter = vec.begin();
				// cIter는 const T*처럼 동작합니다.
*cIter = 10;	// 에러! *cIter가 상수이기 때문에 안됩니다.
++cIter;		// 이건 문제없습니다. cIter를 변경하니까요.

뭐니 뭐니 해도 가장 강력한 const의 용도는 함수 선언에 쓸 경우입니다. 함수 선언문에
있어서 const는 함수 반환 값, 각각의 매개변수, 멤버 함수 앞에 붙을 수 있고, 함수 전체
에 대해 const의 성질을 붙일 수 있습니다.

함수 반환 값을 상수로 정해 주면, 안전성이나 효율을 포기하지 않고도 시용자측의 에러 돌
발 상황을 줄이는 효과를 꽤 자주 볼 수 있게 됩니다. 한 예로, 항목 24에서 살펴볼 유리수
클래스에서 operator* 함수가 어떻게 선언되어 있는지를 보도록 하지요.

class Rational {...};

const Rational operator*(const Rational& lhs, const Rational& rhs);

첫인상이 까칠하다고 느끼는 프로그래머들이 꽤 있을 것 같습니다. operator* 의 반환 값
이 상수 객체일 이유를 어디서 찾겠느냐는 의견일 텐데요, 그런데 상수 객체로 되어 있지
않으면 사용자 쪽에서 저지르는 아래와 같은 어처구니없는 실수를 멍청히 지켜볼 수밖에 없
게 됩니다.

Rational a, b, c;
...
(a*b) = c;		// a*b의 결과에 대고 operator=를 호출하다니요!

두 수의 곱에 대입 연산을 취하고 싶은 프로그래머가 있을지는 모르겠지만, 이런 상황을 원
하지 않았는데도 무의식중에 경험해 본 프로그래머가 전자보다 훨씬 많다는 사실은 입니다.
어쩌다가 그냥 키보드를 잘못 누른 것이죠(그리고 bool로 암시적 변환이 가능한 타입도 포함됩
니다).

if (a * b = c) // 어흑, 나는 원래 비교하려고 그랬던 건데!

위의 코드는 a 및 b의 타입이 기본제공 타입이었다면 용서 없이 문법 위반에 걸리는 코드입
니다. 훌륭한 사용자 정의 타입의 특정 중 하나는 기본제공 타입과의 쓸데없는 비호환성
을 피한디는 것인데(항목 18 참조), 위에서 본 바와 같이 두 수의 곱에 대해 대입 연산이 되
도록 놓이두는 것이 바로 '쓸데없는' 경우가 되겠습니다. operator*의 반환 값을 const
로 정해 놓으면 이런 경우를 미연에 막을 수 있지요. 그렇기 때문에 상수 반환 값 지정이
정답이 되는 것이고요.

const 매개변수에 대해선 특별히 새로 할 이야기는 없습니다. 그냥 const 타입의 지역
객체와 특성이 똑같으니까요. 그리고 이것 역시 가능한 한 항상 사용하도록 하십시오. 매개
변수 혹은 지역 객체를 수정할 수 없게 하는 것이 목적이라면 const로 선언하는 것을 잊
지 말도록 합시다. 눈 딱 감고 여섯 글자만 더 눌러 보세요. 여러분의 참한 심성을 건드리는
"==로 생각하고 친 건데 실수로 =를 쳤네"와 비슷한 컴파일 에러를 보게 될 일이 없을 것
입니다.

상수 멤버 함수
멤버 함수에 붙는 const 키워드의 역할은 "해당 멤버 함수가 상수 객체에 대해 호출될 함
수이다"라는 사실을 알려 주는 것입니다. 그런데 이런 함수가 왜 중요할까요? 이유는 무려
두 가지입니다. 

첫째는 클래스의 인터페이스를 이해하기 좋게 하기 위해서인데, 그 클래스로 만들어진 객체를 
변경할 수 있는 함수는 무엇이고, 또 변경할 수 없는 함수는 무엇인가를 사용자 쪽에서 알고 
있어야 하는 것입니다. 

둘째는 이 키워드를 통해 상수 객체를 사용할수 있게 하자는 것인데, 코드의 효율을 위해 아주 
중요한 부분이기도 합니다. 항목 20에서 이야기하고 있듯이 C++ 프로그램의 실행 성능을 높
이는 핵심 기법 중 하나가 객체 전달을 '상수 객체에 대한 참조wk(reference-to-const)'로 
진행하는 것이기 때문이죠. 그런데 이 기법이 제대로 살아 움직이려면 상수 상태로 전달된 
객체를 조작할 수 있는 const 멤버 함수, 즉 상수 멤버 함수가 준비되어 있어야 한다는 것이 
바로 포인트입니다.