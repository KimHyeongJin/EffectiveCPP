항목 21: 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자

유리수를 나타내는 클래스가 하나 있다고 가정합시다. 이 클래스에는 두 유리수를 곱하는 
멤버 함수가 선언되어 있습니다.

class Rational 
{ 
public:
	// 생성자가 explicit로 선언되지 않은 이유는 항목 24에서 확인하세요.
	Rational(int numerator = 0 ,int denominator = 1); 
	...
private: 
	int n , d;	// 분자 및 분모 
	// 반환 타입이 const인 이유는 항목 3에서 찾아볼 수 있습니다.
	friend const Rational operator*(const Rational& lhs, 
									const Rational& rhs);
 };

이 클래스의 operator*는 곱셈 결과를 값으로 반환하도록 선언되어 있군요. Rational 객체
의 생성과 소멸에 들어가는 비용을 신경 쓰지 않고 이렇게 했다면 여러분은 직무유기를 하고 
있을지도 모릅니다. 꼭 이런 객체에 비용을 날릴 필요가 없으면 실제로도 그러고 싶지 않은게 
여러분 마음이겠지요. 그래서 또 이렇게 물어보는 것입니다. 정말 여기에 비용을 들여야 할까요?

***아, 값이 아닌 참조자를 반환할 수 있으면 비용 부담은 확실히 없을 것입니다.

하지만 참조자에 대해 한 번만 더 생각해 보세요!!!! 참조자는 그냥 이름입니다. 존재하는 객체에 
붙는 다른 이름이라고요. 여러분이 지금까지 보아온 참조자 선언문을 전부 떠올려 보면, "이게 
무엇에 대한 이름이게?"라고 묻는 부분이 반드시 붙어 왔을 것입니다. 당연하죠 참조자는 어떤 
것에 대한 '또 다른' 이름이어야 하기 때문입니다. 다시 operator*를 들여다 보세요. 이 함
수가 참조자를 반환하도록 만들어졌다면, 

***이 함수가 반환하는 참조자는 반드시 이미 존재하는 Rational 객체의 참조자여야 합니다.

이 객체에는 곱셈이 기능한 두 객체3)의 곱이 들어 있어야 하는 것은 말할 필요도 없고요.

주석 3) '곱셈이 가능한 객체'라고 돌려서 쓴 이유에 주목하자. 진짜 Rational 객체 외에 
Rational 객체로 암시적 변환이 가능한 객체도 operator*의 피연산자(인자)가 될 수 있기 
때문이다

그럼, 반환될 객체는 어디에 있을까요? 'operator* 호출 전에 어디엔가 생겼겠지'라고 생각
하는 분은 혹시 없겠죠? 무슨 말인고 하니, 

Rational a(1, 2); // a 1/2 
Rational b(3, 5); // b = 3/5 
Rational c = a * b; // c는 3/10이어야 합니다.

위의 코드에서 10분의 3이란 값을 가진 유리수가 이미 생겨 주지 않을까 하는 기대를 걸면 
난감하다는 이야기입니다. C++ 세상엔 '거저'가 없습니다. 그 유리수(객체)에 대한 참조자를 
operator*에서 반환할 수 있으려면, 그 유리수 객체를 직접 생성해야 한다는 말입니다. 

함수 수준에서 새로운 객체를 만드는 방법은 딱 두 가지뿐입니다. 
하나는 스택에 만드는 것이고, 또 하나는 힙에 만드는 것입니다. 

우선 전자의 방법부터 보죠. 스택에 객체를 만들려면 지역 변수
를 정의하면 됩니다. 그럼 이 방법을 써서 operator*를 한 번 작성해 볼까요?

// 경고! 어이없는 코드입니다.
const Rational operator*(const Rational& lhs, const Rational& rhs)
{
	Rational result( lhs.n * rhs.n, lhs.d * rhs.d );
	return result;
}

이런 방법은 손에 묻히는 것조차도 피했으면 좋겠습니다. 생성자가 불리는게 싫어서 시작한 
일인데, 결국 result가 다른 객체처럼 생성되어야 하잖아요. 그뿐이면 좋게요? 더 심각한 
문제도 있습니다. 이 연산자 함수는 result에 대한 참조자를 반환하는데, result는 지역 
객체입니다. 다시 말해 함수가 끝날 때 덩달아 소멸되는 객체죠. 그러니까, 이 operator* 
는 현재 온전한 Rational 객체에 대한 참조지를 반환하지 않습니다. 지금 이 참조자가 가
리키고 있는 대상은 전(前) Rational 객체, 바꿔 말해 그전엔 Rational 객체였던 놈, 
좀 길고 폼 나게 표현해서 한때는 잘나가던 Rational 객체였으나 이젠 흔적도 희미해질 
정도로 악취(?)를 풍기며 썩어 없어지는 메모리뭉치란 말씀입니다. 소멸자가 호출되어 버린 
객체는 누구도 알아주지 않는 바이트덩어리인 것입니다. 당연히, 반환 타입에 홀딱 넘어가 이 
함수를 호출한 쪽은 그 즉시 미정의 동작의 거친 세계에 떨어져 어쩔 줄 모르겠지요. 실제로, 
지역 객체에 대한 참조자를 반환하는 함수는 어떤 함수든지 프로그램의 핵폭탄이 됩니다(지역 
객체의 포인터를 반환하는 함수도 마찬가지이고요).

자, 다음은 후자의 방법을 살펴볼 순서입니다. 함수가 반환할 객체를 힙에 생성해 뒀다가 
그 녀석의 참조자를 반환하는 것은 어떨까요? 힙 기반 객체는 new 연산자를 통해 이 세상으
로 불러온다는 것 정도는 아실테고요. 그럼 operator* 함수를 힙 기반으로 만들어 봅시다.

// 경고! 또 일 났네요. 일 났어! 
const Rational& operator*(const Rational& lhs ,const Rational& rhs)
{
	Rational *result = new Rational(lhs.n * rhs.n, lhs.d * rhs.d); 
	return *result;
}

여전히 생성자가 한 변 호출되기는 매한가지이군요. new로 할당한 메모리를 초기화할 때 생
성자가 호출되니 말입니다. 그러나 이것 말고 다른 문제가 하나 더 있습니다. 여기서 new로 
저질러 버린 객체를 대체 누가 delete로 뒤처리해 주길 바란다는 말입니까?

이 함수를 호출하는 분이 운좋게 잊어 버리지 않고 delete를 해준다면 다행입니다. 아래
의 코드를 보세요. 말도 안 되는 코드가 아닌데도 메모리 누출엔 속수무책입니다.

Rational w, x, y, z; 
w = x * y * z; // operator* (operator*(x, y), z) 와 같습니다.

여기서는 한 문장 안에서 operator* 호출이 두 번 일어나고 있기 때문에, new에 짝을 맞
추어 delete를 호출하는 작업도 두 번이 필요합니다. 그런데 operator*의 사용자 쪽에서
는 이렇게 할 수 있는 합당한 방법이 없습니다. operator*로부터 반환되는 참조자 뒤에 
숨겨진 포인터에 대해서는 사용자가 어떻게 접근할 방법이 없기 때문입니다. 소스의 목을 
비틀어도 자원 누출이 보장되는 '다 보장' 코드 되겠습니다.

이야기를 살짝 돌려 보죠. 지금까지 살펴본 두 개의 코드는 한 가지 문제를 똑같이 가지고 
있었습니다. 아마 스택 기반으로 하든 힙 기반으로 하든 operator* 에서 반환되는 결과는 
반드시 생성자를 꼭 한 번 호출했을 거예요. 그런데, 필요 없는 생성자 호출을 피해 보자는 
것이 아마 처음 세운 목표였을 걸요? 그런데 저 생성자 호출만은 어쩔 수 없지 않나 하고 
낙심하는 분도 아마 있을 거고요. 그러던 여러분에게 그분이 강림하셨습니다. Rational 
객체를 정적 객체로 함수 안에 정의해 놓고 이것의 참조자를 반환하는 식으로 operator* 
를 질러 버리라고 말씀하시는군요.

// 경고! 사고를 아주 제대로 치시는군요!
const Rational& operator*(const Rational& lhs ,const Rational& rhs)
{
	// 반환할 참조자가 가리킬 정적 객체
	static Rational result;
	// lhs와 rhs를 곱하고 그 결과를 result에 저장
	result = ....;
	return result;
}

정적 객체를 사용하는 설계가 항상 그러하듯, 이 코드는 스레드 안전성 문제가 얽혀 
있습니다. 하지만 이보다 더 확실한 약점이 있는데 빼놓으면 섭하겠죠. 어떤 약점인
지는 아래에 준비한 그야말로 멀쩡한 코드를 보며 고민해 봅시다.

// Rational 객체를 위한 operator== 
bool operator==(const Rational& lhs, const Rational& rhs); 
Rational a, b, c, d; 
...
if ((a * b) == (c * d)) 
{ 
	//두 유리수 쌍의 곱이 서로 같으면 적절한 처리를 수행합니다; 
} 
else 
{ 
	//다르면 적절한 처리를 수행합니다;
}

뭘 생각하세요? 오래 붙들고 있다고 달라지나요? 글세, ((a*b) ==  (c*d)) 표현식이 
항상 true 값을 낸단 말입니다. a, b, c, d에 어떤 값이 들어가도 마찬가지라니까요!

얼토당토않은 폭로라며 머리끈을 질끈 매시는 분들의 이해를 돕기 위해, 위의 표현식을 
아래처럼 함수 형태로 동등하게 바꿔 보겠습니다.

if (operator== (operator*(a, b), operator*(c, d))) 

operator== 함수가 호출될 때를 곰곰이 따져 봅시다. 이때 분명 두 개의 operator* 
함수 호출이 활성화되어 있을 것이고, 각각의 호출을 통해 operator* 안에 정의된 정적 
Rational 객체의 참조자가 반환될 것입니다. operator==이 비교하는 피연산자는 operator* 
안의 정적 Rational 객체의 값, 그리고 operator* 안의 정적 Rational 객체의 값입니다. 
이 둘이 같지 않은 것이 더 이상하지 않나요? 그것도 항상 말입니다.

이 정도면 operator* 등의 함수에서 참조자를 반환하는 것만큼 시간낭비는 없다는 이야기가 
충분히 여러분에게 먹혀야 할 것 같은데, 아직도 '참조반환집착증'에서 헤어나지 못하는 측은한 
영흔들이 이렇게까지 생각하고 있더라고요. "뭐야, 그건 정적 데이터가 하나니까 그렇지. 정적 
배열(array)을 쓰면 교묘하게 해결할 수 있을걸..."

이젠 이분들의 크고 아름다운 설계를 예제 코드로 보여주기조차 지쳤습니다. 손은 지쳤을지 언정, 
그렇게 생각해 놓고 나서 부끄러움이 스며들어 어쩔줄 모르는 여러분의 발그레한 얼굴은 눈앞에 
생생하네요. 정적 배열이요? 그럼 배열의 크기인 n부터 정해야 할 겁니다. 이 n 은 작아도 고민, 
커도 고민입니다. n이 너무 작으면 반환 값을 저장할 공간이 부족해질 것입니다. 정적 데이터 
하나를 사용한 설계에서 별로 나아진게 없는 상태죠. 그렇다고 n이 너무 크면 프로그램의 수행 
성능이 떨어집니다. 함수가 가장 처음 실행될 때 배열 안의 모든 객체가 '생성'된다는 사실을 잊은 
건 아니죠? 비록 딱 한 번뿐이지만, 이때 생성자가 n번 호출 되고 유효범위가 끝날 때 소멸자가 n번 
호출된단 말씀입니다. 수행 성능을 높이기 위해 어떻게든 하는 작업이 '최적화(optimization)'인데, 
지금 자행되고 있는 일은 '부적화(pessimization)' 라고 불러야 하지 않을까요. 이것으로 끝나면 
좋게요? 배열 안의 객체에 값을 어떻게 넣을 것이며, 비용이 얼마나 들지 생각해 보세요. 객체 
사이에 값을 옮기는 가장 직접적인 수단은 대입일 것이고, 그렇다면 대입에 어떤 비용이 들어갈까요? 
전부는 아니지만, 많은 타입의 경우 소멸자(이전의 값을 없애는 데)와 생성자(새 값을 복사해 오는 데)가 
한 번씩 호출되어야 합니다. 이쯤 되면 달라도 한참 다른 길로 들어선 것 같습니다. 생성자와 소멸자 
호출을 피히는 것이 목표 아니었나요? 받이들이세요. 이 방법으로는 문제를 푸는데 한 걸음도 못 
나아갑니다(배열 대신에 vector를 쓰시겠다는 분이 있군요. 참 끈질기십니다. 별로 나아지지 않는다고요).

새로운 객체를 반환해야 하는 함수를 작성하는 방법에는 정도(正道)가 있습니다. 바로 '새로운 객체를 
반환하게 만드는 것'이죠 그러니까 Rational operator*는 아래처럼 혹은 아래와 비슷하게 
작성해야 합니다.

inline const Rational operator*(const Rational& lhs, const Rational& rhs)
{
	return Rational(lhs.n * rhs.n, lhs.d * rhs.d); 
}

이 코드에도 반환 값을 생성하고 소멸시키는 비용이 들어 있지 않느냐며 팔을 걷어붙이는 분들이 
계시는데요, 맞습니다. 그분들이 틀린 것은 아닙니다. 그러나 끝까지 따져 보면 여기에 들어가는 
비용은 올바른 동작에 지불되는 작은 비용입니다. 그뿐 아니라, 여러분 혈압을 용솟음치게 할 계산서 
같은 것은 나오지도 않습니다. 모든 프로그래멍 언어가 그러하듯, C++에서도 다 컴파일러 구현자들이 
가시적인 동작 변경을 가하지 않고도 기존 코드의 수행 성능을 높이는 최적화를 적용할 수 있도록 배려해 
두었습니다. 그 결과, 몇몇 조건하에서는 이 최적화 메커니즘에 의해 operator*의 반환 값에 대한 생성과 
소멸 동작이 안전하게 제거될 수 있습니다.4) 여러분의 컴파일러가 이 기능을 갖고 있으면(실제로 많은 
컴파일러가 그렇습니다) 위의 코드는 여전히 본래의 의도대로 동작할 것입니다. 그것도 생각보다 빨리요.

::4) 반환 값 최적화(return value optimization), 줄여서 RVO라고 부른다

자, 또 마무리할 시간입니다. 참조자를 반환할 것인가 아니면 객체를 반환할 것인가를 결정 할 때, 
이것만 잊지 말아 주세요. 어떤 선택을 하든 올바른 동작이 이루어지도록 만드는 것!

이것이 진짜로 여러분이 할 일입니다. 여러분야 선택한 결과를 최대한 저비용으로 만들려면 어떻게 해야 
하는지 파악하느라 끔끔대는 일은 컴파일러 제작사에게 맡기라 이겁니다.

이것만은 잊지 말자! 
* 지역 스택 객체에 대한 포인터나 참조자를 반환하는 일, 흑은 힙에 할당된 객체에 대한 참조자를 
반환하는 일, 또는 지역 정적 객체에 대한 포인터나 참조자를 반환하는 일은 그런 객체가 두 개 이상 
필요해질 가능성이 있다면 절대로 하지 마세요(항목 4를 보시면 지역 정적 객체에 대한 참조자를 반환하도록 
설계된 올바른 코드 예제를 찾을 수 있습니다. 최소한 단일 스레드 환경에서는 통합니다).