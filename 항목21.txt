항목 21: 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자

유리수를 나타내는 클래스가 하나 있다고 가정합시다. 이 클래스에는 두 유리수를 곱하는 
멤버 함수가 선언되어 있습니다.

class Rational 
{ 
public:
	// 생성자가 explicit로 선언되지 않은 이유는 항목 24에서 확인하세요.
	Rational(int numerator = 0 ,int denominator = 1); 
	...
private: 
	int n , d;	// 분자 및 분모 
	// 반환 타입이 const인 이유는 항목 3에서 찾아볼 수 있습니다.
	friend const Rational operator*(const Rational& lhs, 
									const Rational& rhs);
 };

이 클래스의 operator*는 곱셈 결과를 값으로 반환하도록 선언되어 있군요. Rational 객체
의 생성과 소멸에 들어가는 비용을 신경 쓰지 않고 이렇게 했다면 여러분은 직무유기를 하고 
있을지도 모릅니다. 꼭 이런 객체에 비용을 날릴 필요가 없으면 실제로도 그러고 싶지 않은게 
여러분 마음이겠지요. 그래서 또 이렇게 물어보는 것입니다. 정말 여기에 비용을 들여야 할까요?

***아, 값이 아닌 참조자를 반환할 수 있으면 비용 부담은 확실히 없을 것입니다.

하지만 참조자에 대해 한 번만 더 생각해 보세요!!!! 참조자는 그냥 이름입니다. 존재하는 객체에 
붙는 다른 이름이라고요. 여러분이 지금까지 보아온 참조자 선언문을 전부 떠올려 보면, "이게 
무엇에 대한 이름이게?"라고 묻는 부분이 반드시 붙어 왔을 것입니다. 당연하죠 참조자는 어떤 
것에 대한 '또 다른' 이름이어야 하기 때문입니다. 다시 operator*를 들여다 보세요. 이 함
수가 참조자를 반환하도록 만들어졌다면, 

***이 함수가 반환하는 참조자는 반드시 이미 존재하는 Rational 객체의 참조자여야 합니다.

이 객체에는 곱셈이 기능한 두 객체3)의 곱이 들어 있어야 하는 것은 말할 필요도 없고요.

주석 3) '곱셈이 가능한 객체'라고 돌려서 쓴 이유에 주목하자. 진짜 Rational 객체 외에 
Rational 객체로 암시적 변환이 가능한 객체도 operator*의 피연산자(인자)가 될 수 있기 
때문이다

그럼, 반환될 객체는 어디에 있을까요? 'operator* 호출 전에 어디엔가 생겼겠지'라고 생각
하는 분은 혹시 없겠죠? 무슨 말인고 하니, 

Rational a(1, 2); // a 1/2 
Rational b(3, 5); // b = 3/5 
Rational c = a * b; // c는 3/10이어야 합니다.

위의 코드에서 10분의 3이란 값을 가진 유리수가 이미 생겨 주지 않을까 하는 기대를 걸면 
난감하다는 이야기입니다. C++ 세상엔 '거저'가 없습니다. 그 유리수(객체)에 대한 참조자를 
operator*에서 반환할 수 있으려면, 그 유리수 객체를 직접 생성해야 한다는 말입니다. 

함수 수준에서 새로운 객체를 만드는 방법은 딱 두 가지뿐입니다. 
하나는 스택에 만드는 것이고, 또 하나는 힙에 만드는 것입니다. 

우선 전자의 방법부터 보죠. 스택에 객체를 만들려면 지역 변수
를 정의하면 됩니다. 그럼 이 방법을 써서 operator*를 한 번 작성해 볼까요?

// 경고! 어이없는 코드입니다.
const Rational operator*(const Rational& lhs, const Rational& rhs)
{
	Rational result( lhs.n * rhs.n, lhs.d * rhs.d );
	return result;
}

이런 방법은 손에 묻히는 것조차도 피했으면 좋겠습니다. 생성자가 불리는게 싫어서 시작한 
일인데, 결국 result가 다른 객체처럼 생성되어야 하잖아요. 그뿐이면 좋게요? 더 심각한 
문제도 있습니다. 이 연산자 함수는 result에 대한 참조자를 반환하는데, result는 지역 
객체입니다. 다시 말해 함수가 끝날 때 덩달아 소멸되는 객체죠. 그러니까, 이 operator* 
는 현재 온전한 Rational 객체에 대한 참조지를 반환하지 않습니다. 지금 이 참조자가 가
리키고 있는 대상은 전(前) Rational 객체, 바꿔 말해 그전엔 Rational 객체였던 놈, 
좀 길고 폼 나게 표현해서 한때는 잘나가던 Rational 객체였으나 이젠 흔적도 희미해질 
정도로 악취(?)를 풍기며 썩어 없어지는 메모리뭉치란 말씀입니다. 소멸자가 호출되어 버린 
객체는 누구도 알아주지 않는 바이트덩어리인 것입니다. 당연히, 반환 타입에 홀딱 넘어가 이 
함수를 호출한 쪽은 그 즉시 미정의 동작의 거친 세계에 떨어져 어쩔 줄 모르겠지요. 실제로, 
지역 객체에 대한 참조자를 반환하는 함수는 어떤 함수든지 프로그램의 핵폭탄이 됩니다(지역 
객체의 포인터를 반환하는 함수도 마찬가지이고요).

자, 다음은 후자의 방법을 살펴볼 순서입니다. 함수가 반환할 객체를 힙에 생성해 뒀다가 
그 녀석의 참조자를 반환하는 것은 어떨까요? 힙 기반 객체는 new 연산자를 통해 이 세상으
로 불러온다는 것 정도는 아실테고요. 그럼 operator* 함수를 힙 기반으로 만들어 봅시다.

// 경고! 또 일 났네요. 일 났어! 
const Rational& operator*(const Rational& lhs ,const Rational& rhs)
{
	Rational *result = new Rational(lhs.n * rhs.n, lhs.d * rhs.d); 
	return *result;
}

여전히 생성자가 한 변 호출되기는 매한가지이군요. new로 할당한 메모리를 초기화할 때 생
성자가 호출되니 말입니다. 그러나 이것 말고 다른 문제가 하나 더 있습니다. 여기서 new로 
저질러 버린 객체를 대체 누가 delete로 뒤처리해 주길 바란다는 말입니까?

이 함수를 호출하는 분이 운좋게 잊어 버리지 않고 delete를 해준다면 다행입니다. 아래
의 코드를 보세요. 말도 안 되는 코드가 아닌데도 메모리 누출엔 속수무책입니다.

Rational w, x, y, z; 
w = x * y * z; // operator* (operator*(x, y), z) 와 같습니다.

여기서는 한 문장 안에서 operator* 호출이 두 번 일어나고 있기 때문에, new에 짝을 맞
추어 delete를 호출하는 작업도 두 번이 필요합니다. 그런데 operator*의 사용자 쪽에서
는 이렇게 할 수 있는 합당한 방법이 없습니다. operator*로부터 반환되는 참조자 뒤에 
숨겨진 포인터에 대해서는 사용자가 어떻게 접근할 방법이 없기 때문입니다. 소스의 목을 
비틀어도 자원 누출이 보장되는 '다 보장' 코드 되겠습니다.

이야기를 살짝 돌려 보죠. 지금까지 살펴본 두 개의 코드는 한 가지 문제를 똑같이 가지고 
있었습니다. 아마 스택 기반으로 하든 힙 기반으로 하든 operator* 에서 반환되는 결과는 
반드시 생성자를 꼭 한 번 호출했을 거예요. 그런데, 필요 없는 생성자 호출을 피해 보자는 
것이 아마 처음 세운 목표였을 걸요? 그런데 저 생성자 호출만은 어쩔 수 없지 않나 하고 
낙심하는 분도 아마 있을 거고요. 그러던 여러분에게 그분이 강림하셨습니다. Rational 
객체를 정적 객체로 함수 안에 정의해 놓고 이것의 참조자를 반환하는 식으로 operator* 
를 질러 버리라고 말씀하시는군요.

// 경고! 사고를 아주 제대로 치시는군요!
const Rational& operator*(const Rational& lhs ,const Rational& rhs)
{
// 반환할 참조자가 가리킬 정적 객체
	static Rational result;
	//lhs와 rhs를 곱하고 그 결과를 result에 저장
	result = ....;
	return result;
}

정적 객체를 시용하는 설계가 항상 그러하듯, 이 코드 역시 우리의 염통을 졸깃하게 만드는 
스레드 안전성 문제가 얽혀 있습니다. 하지만 이보다 더 확실한 약점이 있는데 빼놓으면 섭
하겠죠. 어떤 약점인지는 아래에 준비한 그야말로 멀쩡한 코드를 보며 고민해 봅시다.

// Rational 객체를 위한 operator== 
bool operator==(const Rational& lhs, const Rational& rhs); 
Rational a, b, c, d; 
...
if ((a * b) == (c * d)) 
{ 
	//두 유리수 쌍의 곱이 서로 같으면 적절한 처리를 수행합니다; 
} 
else 
{ 
	//다르면 적절한 처리를 수행합니다;
}

뭘 생각하세요? 오래 붙들고 있다고 달라지나요? 글세, ((a*b) ==  (c*d)) 표현식이 
항상 true 값을 낸단 말입니다. a, b, c, d에 어떤 값이 들어가도 마찬가지라니까요!

얼토당토않은 폭로라며 머리끈을 질끈 매시는 분들의 이해를 돕기 위해, 위의 표현식을 
아래처럼 함수 형태로 동등하게 바꿔 보겠습니다.

if (operator== (operator*(a, b), operator*(c, d))) 