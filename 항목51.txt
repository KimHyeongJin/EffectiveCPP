항목 51: new 및 delete를 작성할 때 따라야 할 기존의 관례를 잘 알아 두자.

항목 50을 읽으셨다면 사용자 정의 버전의 operator new와 operator delete 함수를
언제 만들어 쓰는지에 대해 이제 어느 정도는 이해가 되셨을 텐데요, 실제로 사용자 정의
버전을 작성해 보려고 했을 때 도대체 어떤 관례를 따라야 하는지에 대해서는 아직 막막하
실 겁니다. 보시면 사실 따르기 힘든 규칙은 없습니다. 그러나 일부는 이해하기 살짝 구린
게 있기 때문에, 이런 부분이 무엇인지에 해대 유념해 둘 필요가 있습니다.

자, 우선 operator new부터 시작하죠. 기존의 관례에 잘 맞는 operator new를 구현하
려면 다음의 요구사항만큼은 기본으로 지켜야 합니다. 일단 반환 값이 제대로 되어 있어야
하고, 가용 메모리가 부족할 경우에는 지켜야 합니다. 일단 반환 값이 제대로 되어 있어야
하고, 가용 메모리가 부족할 경우에는 new 처리자 함수를 호출해야 하며(항목 49, 참조),
크기가 없는(0바이트) 메모리 요청에 대한 대비책을 갖춰둬어야 합니다. 끝으로, 실수로
"기본(normal)" 형태의 new가 가려지지 않도록 하십시오. 사실 이 부분은 구현 요구사
항이라기 보다는 클래스 인터페이스에 관한 문제이긴 하지만 대단히 중요합니다. 항목 52
에 자세히 다루어 두었으니 참고하세요.

operator new의 반환 값 부분은 지극히 간단합니다. 요청된 메모리를 마련해 줄 수 있
으면 그 메모리에 대한 포인터를 반환하는 것으로 끝입니다. 메모리를 마련해 줄 수 없는
경우가 문제인데, 이 경우에는 항목 49에서 이야기한 규칙을 따라서 bad_alloc 타입의
예외를 던지게 하면 됩니다.

구현도 이렇게 말처럼 쉬우면 좋겠는데, 간단하지는 않습니다. 사실 operator new는 
메모리 할당이 실패할 때마다 new 처리자 함수를 호출하는 식으로 메모리 할당을 2회 이
상 시도하기 때문입니다. 그러니까, 어떻게든 어떤 메모리를 해제하는 데 실마리가 되는
동작을 new 처리자 함수 쪽에서 할 수 있을 것으로 가정하는 거죠. operator new가 예
외를 던지게 되는 경우는 오직 new 처리자 함수에 대한 포인터가 널일 때뿐입니다.

그리고 이번 항목을 시작할 때 제가 '살짝 이상하다'고 이야기한 바 있는, 뭔가 상당히 어
색한 요구사항을 이쯤에서 말씀드려야 할 듯합니다. 바로, 0바이트가 요구되었을 때조차도
operator new 함수는 적법한 포인터를 반환해야 한다는 것입니다(이런 동작이 요구사항으로
있는 덕택에 다른 부분들이 좀 간단해지긴 하지만요). 어쨌든 지금까지의 요구사항을 모으고
정리해서, 비멤버 버전의 operator new 함수를 의사 코드로 만들어 보면 다음과 같습니다.

// 여러분의 operator new 함수는 다른 매개변수를 추가로 가질 수 있습니다.
void* operator new(std::size_t size) throw(std::bad_alloc)
{
	using namespace std;
	if(size == 0)
	{
		size = 1;
	}

	while(true)
	{
		size 바이트를 할당해 봅니다;
		if(할당이 성공했음)
			return (할당된 메모리에 대한 포인터);

		// 할당이 실패했을 경우, 현재의 new 처리자 함수가 어느 것으로
		// 설정되어 있는지 찾아냅니다(아래를 보세요).
		new_handler globalHandler = set_new_handler(0);
		set_new_handler(globalHandler);

		if(globalHandler)(*globalHandler)();
		else throw std::bad_alloc();
	}
}

외부에서 0바이트를 요구했을 때 1바이트 요구인 것으로 간주하고 처리하는 수법은 어쩐지
무척 비굴해 보이기도 하고 얍삽해 보이기도 합니다만, 어떻습니까? 일단 간단하고, 규칙을
어긴 것도 아니며, 제대로 돌아가잖아요. 그리고 이렇게 생각해 보세요. 0바이트가 여러분
평생 동안 진짜 몇 번이나 요구될 것 같습니까?

new 처리자 함수의 포인터를 널로 설정하고 바로 뒤에 원래의 처리자 함수로 되될려 놓는
코드도 눈에 자꾸 거슬립니다. 눈뜨고 못 볼 수준은 아니지만 그다지 예뻐 보이진 않거든요.
안타까운 일이지만, 현재의 전역 new 처리자 함수를 얻어오는 직접적인 방법은 없습니다.
set_new_handler 함수를 호출하고 그 반환 값을 가져오는 방법밖에 없기 때문에, 위와
같이 할 수밖에 없었던 것입니다. 뭔가 다른 방법이 있으면 당장 바꾸고 싶은 마음이 용솟
음칠 만큼 아쉽죠. 맞습니다. 그렇지만 현장에서도 효과적인 코드입니다. 최소한 단인 스레
드에서 동작하는 환경이라면 이렇게 해도 될 것입니다. 반면, 다중스레드 환경에서는 new
처리자 함수를 둘러싼(전역) 자료구조들이 조작될 때 스레드 안전성이 보장되어야 하기 때
문에 스레드 잠금을 걸어야 합니다.

operator new 함수에는 무한 루프가 들어 있다는 이야기를 항목 49에서 했는데, 위의
코드를 보시면 그 루프를 확인할 수 있습니다. 이보다 더 '무한'스러울 수 없는 위력을 뿜
어내는 "while(true)"입니다. 이 루프를 빠져나오는 유일한 조건은 메모리 할당이 성공
하든지 아니면 항목 49에서 이야기한 동작들 중 한 가지를 new 처지라 함수 쪽에서 해 주든
지 둘 중 하나입니다. new 처리자에서 직무유기를 해 버릴 경우, operator new의 내부
루프는 절대로 스스로 끝나지 않습니다.

사실, operator new 멤버 함수는 파생 클래스 쪽으로 상속이 되는 함수입니다. 상당히
많은 분들께서 이 점을 간과하시고도 아무렇지도 않게 웃으며 하루하루를 연명하고 계시더
군요. 정말 우스운 꼴을 당할 수 있으니 주의하시기 바랍니다. 위에 나온 operator new
함수의 의사 코드를 보시면, 할당을 시도하는(size가 0이 아니면 말이에요) 메모리의 크기
가 size바이트로 되어 있습니다. 이 코드는 틀린 게 하나도 없는 100점 코드입니다. 이 함
수에 전달되는 인자가 size이니까요. 그런데 특정 클래스 전용의 할당자를 만들어서 할당
효율을 최적화하기 위해서 사용자 정의 메모리 관리자를 작성할 수 있다는 이야기는 항목 50
을 읽은 분이라면 기억하고 계실 것입니다.