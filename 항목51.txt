항목 51: new 및 delete를 작성할 때 따라야 할 기존의 관례를 잘 알아 두자.

항목 50을 읽으셨다면 사용자 정의 버전의 operator new와 operator delete 함수를
언제 만들어 쓰는지에 대해 이제 어느 정도는 이해가 되셨을 텐데요, 실제로 사용자 정의
버전을 작성해 보려고 했을 때 도대체 어떤 관례를 따라야 하는지에 대해서는 아직 막막하
실 겁니다. 보시면 사실 따르기 힘든 규칙은 없습니다. 그러나 일부는 이해하기 살짝 구린
게 있기 때문에, 이런 부분이 무엇인지에 해대 유념해 둘 필요가 있습니다.

자, 우선 operator new부터 시작하죠. 기존의 관례에 잘 맞는 operator new를 구현하
려면 다음의 요구사항만큼은 기본으로 지켜야 합니다. 일단 반환 값이 제대로 되어 있어야
하고, 가용 메모리가 부족할 경우에는 지켜야 합니다. 일단 반환 값이 제대로 되어 있어야
하고, 가용 메모리가 부족할 경우에는 new 처리자 함수를 호출해야 하며(항목 49, 참조),
크기가 없는(0바이트) 메모리 요청에 대한 대비책을 갖춰둬어야 합니다. 끝으로, 실수로
"기본(normal)" 형태의 new가 가려지지 않도록 하십시오. 사실 이 부분은 구현 요구사
항이라기 보다는 클래스 인터페이스에 관한 문제이긴 하지만 대단히 중요합니다. 항목 52
에 자세히 다루어 두었으니 참고하세요.

operator new의 반환 값 부분은 지극히 간단합니다. 요청된 메모리를 마련해 줄 수 있
으면 그 메모리에 대한 포인터를 반환하는 것으로 끝입니다. 메모리를 마련해 줄 수 없는
경우가 문제인데, 이 경우에는 항목 49에서 이야기한 규칙을 따라서 bad_alloc 타입의
예외를 던지게 하면 됩니다.

구현도 이렇게 말처럼 쉬우면 좋겠는데, 간단하지는 않습니다. 사실 operator new는 
메모리 할당이 실패할 때마다 new 처리자 함수를 호출하는 식으로 메모리 할당을 2회 이
상 시도하기 때문입니다. 그러니까, 어떻게든 어떤 메모리를 해제하는 데 실마리가 되는
동작을 new 처리자 함수 쪽에서 할 수 있을 것으로 가정하는 거죠. operator new가 예
외를 던지게 되는 경우는 오직 new 처리자 함수에 대한 포인터가 널일 때뿐입니다.

그리고 이번 항목을 시작할 때 제가 '살짝 이상하다'고 이야기한 바 있는, 뭔가 상당히 어
색한 요구사항을 이쯤에서 말씀드려야 할 듯합니다. 바로, 0바이트가 요구되었을 때조차도
operator new 함수는 적법한 포인터를 반환해야 한다는 것입니다(이런 동작이 요구사항으로
있는 덕택에 다른 부분들이 좀 간단해지긴 하지만요). 어쨌든 지금까지의 요구사항을 모으고
정리해서, 비멤버 버전의 operator new 함수를 의사 코드로 만들어 보면 다음과 같습니다.

// 여러분의 operator new 함수는 다른 매개변수를 추가로 가질 수 있습니다.
void* operator new(std::size_t size) throw(std::bad_alloc)
{
	using namespace std;
	if(size == 0)
	{
		size = 1;
	}

	while(true)
	{
		size 바이트를 할당해 봅니다;
		if(할당이 성공했음)
			return (할당된 메모리에 대한 포인터);

		// 할당이 실패했을 경우, 현재의 new 처리자 함수가 어느 것으로
		// 설정되어 있는지 찾아냅니다(아래를 보세요).
		new_handler globalHandler = set_new_handler(0);
		set_new_handler(globalHandler);

		if(globalHandler)(*globalHandler)();
		else throw std::bad_alloc();
	}
}

외부에서 0바이트를 요구했을 때 1바이트 요구인 것으로 간주하고 처리하는 수법은 어쩐지
무척 비굴해 보이기도 하고 얍삽해 보이기도 합니다만, 어떻습니까? 일단 간단하고, 규칙을
어긴 것도 아니며, 제대로 돌아가잖아요. 그리고 이렇게 생각해 보세요. 0바이트가 여러분
평생 동안 진짜 몇 번이나 요구될 것 같습니까?

new 처리자 함수의 포인터를 널로 설정하고 바로 뒤에 원래의 처리자 함수로 되될려 놓는
코드도 눈에 자꾸 거슬립니다. 눈뜨고 못 볼 수준은 아니지만 그다지 예뻐 보이진 않거든요.
안타까운 일이지만, 현재의 전역 new 처리자 함수를 얻어오는 직접적인 방법은 없습니다.
set_new_handler 함수를 호출하고 그 반환 값을 가져오는 방법밖에 없기 때문에, 위와
같이 할 수밖에 없었던 것입니다. 뭔가 다른 방법이 있으면 당장 바꾸고 싶은 마음이 용솟
음칠 만큼 아쉽죠. 맞습니다. 그렇지만 현장에서도 효과적인 코드입니다. 최소한 단인 스레
드에서 동작하는 환경이라면 이렇게 해도 될 것입니다. 반면, 다중스레드 환경에서는 new
처리자 함수를 둘러싼(전역) 자료구조들이 조작될 때 스레드 안전성이 보장되어야 하기 때
문에 스레드 잠금을 걸어야 합니다.

operator new 함수에는 무한 루프가 들어 있다는 이야기를 항목 49에서 했는데, 위의
코드를 보시면 그 루프를 확인할 수 있습니다. 이보다 더 '무한'스러울 수 없는 위력을 뿜
어내는 "while(true)"입니다. 이 루프를 빠져나오는 유일한 조건은 메모리 할당이 성공
하든지 아니면 항목 49에서 이야기한 동작들 중 한 가지를 new 처지라 함수 쪽에서 해 주든
지 둘 중 하나입니다. new 처리자에서 직무유기를 해 버릴 경우, operator new의 내부
루프는 절대로 스스로 끝나지 않습니다.

사실, operator new 멤버 함수는 파생 클래스 쪽으로 상속이 되는 함수입니다. 상당히
많은 분들께서 이 점을 간과하시고도 아무렇지도 않게 웃으며 하루하루를 연명하고 계시더
군요. 정말 우스운 꼴을 당할 수 있으니 주의하시기 바랍니다. 위에 나온 operator new
함수의 의사 코드를 보시면, 할당을 시도하는(size가 0이 아니면 말이에요) 메모리의 크기
가 size바이트로 되어 있습니다. 이 코드는 틀린 게 하나도 없는 100점 코드입니다. 이 함
수에 전달되는 인자가 size이니까요. 그런데 특정 클래스 전용의 할당자를 만들어서 할당
효율을 최적화하기 위해서 사용자 정의 메모리 관리자를 작성할 수 있다는 이야기는 항목 50
을 읽은 분이라면 기억하고 계실 것입니다. 여기서 특정 클래스란 '그' 클래스 하나를 가리
킬 뿐, '그 클래스 혹은 그 클래스로부터 파생된 다른 클래스들' 모두를 통칭하는 것은 아닙
니다. 그러니까 어떤 X라는 클래스를 위한 operator new 함수가 있다면, 이 함수의 동작
은 크기가 sizeof(X)인 객체에 대해 맞추어져 있는 것입니다. 더도 덜도 아니고 딱 sizeof(X)
란 말이죠. 그런데 상속이라 불리는 요상한 녀석 때문에 파생 클래스 객체를 담을 메모리를
할당하는 데 기본 클래스의 operator new 함수가 호출되는 웃지 못 할 일이 생긴다는 것
입니다.

class Base
{
public:
	static void* operator new(std::size_t size) throw(std::bad_alloc);
	...
};

class Derived: public Base	// Derived에서는 operator new가 선언되지 않았다.
{ ... };

Derived* p = new Derived;	// Base::operator new가 호출되네!

만약 Base 클래스 전용의 operator new가 이런 상황에 대해 어떤 조치를 취하도록 설계
되지 않았다면(게다가 그렇게 설계되지 않았을 가능성이 충분히 있다면) 전체 설계를 바꾸지
않고 쓸 수 있는 가장 좋은 해결 방법은 "틀린" 메모리 크기가 들어왔을 때를 시작부분에서
확인한 후에 표준 operator new를 호출하는 쪽으로 살짝 비껴가게 만드는 것입니다. 아래
처럼 말이죠.

void* Base::operator new(std::size_t size) throw(std::bad_alloc)
{
	if(size != sizeof(Base))			// "틀린" 크기가 들어오면,
		return ::operator new(size);	// 표준 operator new 쪽에서 메모리
										// 할당 요구를 처리하도록 넘깁니다.
		...		// 맞는 크기가 들어오면 메모리 할당 요구를 여기서 처리합니다.
}						

"자, 잠깐!" 이렇게 울부짖는 소리가 들릴 시간입니다. "뭔가 빼먹었어요. 아저씨께서 앞
에서 말씀하신 '생기면-뭔가-잘못된-거지만-그렇다고-안-생기는-것도-아닌' 0바이트 상황을
점검하지 않았다고요!" 맞아요. 저는 안 했습니다. 그리고 울부짖는 건 좋은데 제발 앞으로
그 줄표좀 빼주세요(줄표? -이거?). 제가 넣지 않아서 그렇지, 사실 0바이트 점검 코드는
있습니다. 단지 sizeof(Base)와 size를 비교하는 코드에 합쳐져 있을 뿐이죠. 여기서 잠
깐 또 이상하고 아름다운 C++의 세계에 대해 한 번 더 말씀드리지 않을 수 없겠네요. C++
에는 모든 독립 구조(freestanding)의 객체는 반드시 크기가 0이 넘어야 한다는 요상한 금
기사항 같은 것이 있습니다(항목 39 참조). 이런 정의 덕택에 sizeof(Base)가 0이 될 일
은 딸기 덩굴에 수박이 열린다 해도 생기지 않습니다. 따라서 size가 0이면 if 문이 거짓이
되어 메모리 처리 요구가 ::operator new 쪽으로 넘어가는 것입니다. 그러니까 위의 코드
는 메모리 요구에 대한 처리를 제대로 한 게 되지요.

정리해보자 sizeof(Base)가 0이 될수 없고, size가 0이면 if(size != sizeof(Base))
는 진실이 되어 ::operator new쪽으로 넘어간다...아닌가?

만약에 배열에 대한 메모리 할당을 클래스 전용 방식으로 하고 싶다면, operator new의
사촌격인 operator new[] 함수를 구현하면 됩니다[이 함수는 "배열 new(array new)"
라고 더 많이 불립니다. "operator new[]" 부분을 어떻게 발음해야 좋을지 정하기가 무척
힘들거든요]. operator new[]를 직접 구현하는 것은 여러분 결심이니 말리진 않겠지만 지금
해드릴 이야기는 꼭 잊지 마세요. operator new[] 안에서 해줄 일은 단순히 원시 메모리의
덩어리를 할당하는 것밖엔 없다는 것입니다. 이 시점에서 배열 메모리에 아직 생기지도 않은
클래스 객체에 대해서 아무것도 알 수 없습니다. 사실, 배열 안에 몇 개의 객체가 들어갈지 계
산하는 것조차도 안 됩니다. 첫째, 객체 하나가 얼마나 큰지를 확정할 방법이 없습니다. 앞에
서도 언급한 바 있는 상속 때문에, 파생 클래스 객체의 배열을 할당하는 데 기본 클래스의
operator new[] 함수가 호출될 수 있습니다. 그리고 파생 클래스 객체는 대체적으로 기본
클래스 객체보다 더 크다는 것도 문제입니다. 그렇기 때문에, Base::operator new[] 안에서
조차도 배열에 들어가는 객체 하나의 크기가 sizeof(Base)라는 가정을 할 수 없습니다. 이
말을 풀이해 보면, Base::operator new[]에서 할당한 배열 메모리에 들어가는 객체의 개수
를 (요구된 바이트 수/sizeof(Base))로 계산할 수 없다는 뜻이 나오는 것이죠.