항목 25: 예외를 던지지 않는 swap에 대한 지원도 생각해 보자

swap은 상당히 재미있는 함수입니다. swap은 초창기부터 STL에 포함된 이래로 예외 안전
성 프로그래밍(항목 29 참조)에 없어선 안 될 감초 역할로서, 자기대입 현상(항목 11 참조)의
가능성에 대처하기 위한 대표적인 메커니즘으로서 널리 사랑받아 왔습니다. 이렇게 쓸모가
많다보니 swap을 어떻게 제대로 구현하느냐가 굉장히 중요해졌지요. 하지만 예쁘면 얼굴값
한다고? 이 함수에 관련된 특이한 말썽거리들도 있는 것이 사실입니다. 대체 어떤 말썽거리가 
있으며, 또 어떻게 대처해야 쓸 만한 swap을 만들 수 있는가를 심도 있게 파헤쳐 보는 
것이 이번 항목의 주제 되겠습니다.

두 객체의 값을 '맞바꾸기(swap)'한다는 것은 각자의 값을 상대방에게 주는 동작입니다. 기본
적으로는 이 맞바꾸기 동작을 위해 표준 라이브러리에서 제공하는 swap 알고리즘을 쓰는
데, 이 알고리즘이 구현된 모습을 보면 여러분이 알고 있는 그 'swap'과 하나도 다르지 않
다는 것을 알 수 있습니다.

namespace std
{
	template<typename T>	// std::swap의 전형적인 a의 값과 b의 값을
	void swap(T& a, T& b)	// 맞바꿉니다.
	{
		T temp(a);
		a = b;
		b = temp;
	}
}

표준에서 기본적으로 제공히는 swap(이하 표준 swap)은 구현 코드를 보시면 알겠지만 복사
만 제대로 지원하는(복사 생성자 및 복사 대입 연산자를 통해) 타입이기만 하면 어떤 타입의
객체이든 맞바꾸기 동작을 수행해 줍니다. swap을 위해 특별히 추가 코드를 마련하거나 할
필요가 없습니다.

하지만, 표준 swap의 동작을 보고 짜릿한 감동을 느끼거나 소름이 돋는 분은 아마 없을 겁
니다. 한 번 호출에 복사가 세 번, a에서 temp로, b에서 a로, temp에서 b로 말이죠. 
타입에 따라서는 이런 사본이 정말 필요 없는 경우도 있는데, 이런 타입을 표준 swap에 넘겨 
호출하는 것은 마치 경주용 트랙을 달리다가 갑자기 산골 오솔길로 접어드는 격이겠지요.

복사하면 손해를 보는 타입들 중 으뜸을 꼽는다면 아마도 다른 타입의 실제 데이터를 가리
키는 포인터가 주성분(!)인 타입일 것입니다. 이러한 개념을 설계의 미학으로 끌어올려 많이
들 쓰고 있는 기법이 바로 'pimpl 5) 관용구(idiom)'('pointer to implementation'
이란 뜻입니다. 항목 31 참조)이지요. 이해를 돕는 의미에서, pimpl 설계를 차용하여 
Widget 클래스를 만든예를 보여 드리죠.

5) 허버 서터(Herb Sutter)가 처음 정리하여 제안한 용어로 알려져 있다. 그의 저서인
"Exceptional C++"(AddisonWesley, 1999)를 참고하기 바란다. - 옮긴이

class WidgetImpl	// Widget의 실제 데이터를 나타내는 클래스 세부사항은
{					// 별로 중요하지 않습니다.
public:
	...
private:
	int a, b, c;	// 아마도 많은 데이터가 있겠죠.
	std::vector<double> v;	// 어쨌든 복사 비용이 높아요!
	...
};

class Widget		// pimpl 관용구를 사용한 클래스
{
public:
	Widget(const Widget& rhs);
	Widget& operator=(const Widget& rhs)// Widget 복사하기 위해, 자신
	{									// WidgetImpl 객체를 복사합니다.
		...								// operator=의 일반적인 구현 방법에
		*pImpl = *(rhs.pImpl);			// 대한 자세한 내용이 궁금하신 분은
		...								// 항목 10, 11, 12를 읽어보세요.
	}
	...
private:
	WidgetImpl* pImpl;		// Widget의 실제 데이터를 가진 객체에 대한 포인터
};

이렇게 만들어진 Widget 객체를 우리가 직접 맞바꾼다면, pImpl 포인터만 살짝 바꾸는 것
말고는 실제로 할 일이 없습니다. 하지만 이런 사정을 표준 swap 알고리즘이 알 턱이 있을
까요? 언제나처럼 Widget 객체 세 개를 복사하고 그것도 모자라 WidgetImpl 객체 세 개
도 복사할 것입니다. 아주 심하게 비효율적입니다.

그래서 조금 손을 보고 싶습니다. std::swap에다가 뭔가를 알려 주는 거죠. Widget 객
체를 맞바꿀 때는 일반적인 방법을 쓰지 말고 내부의 pImpl 포인터만 맞바꾸라고 말입니
다. C++로는 방금 제가 이야기한 그대로 할 수 는 방법이 있습니다 std::swap을
Widget에 대해 특수화(specialize) 하는 것인데, 일단 기본 아이디어만 간단히 코드로 
보여 드리겠습니다. 아직 컴파일은 안 되니 주의하세요.

namespace std
{
	template<>						// 이 코드가 T가 Widget일 경우에
	void swap<Widget>(Widget& a,	// 대해 std::swap을 특수화한 것입
	Widget& b)						// 니다. 아직 컴파일되지는 않습니다.
	{								
		swap(a.pImpl, b.pImpl);	// Widget을 'swap'하기 위해, 각자의 
	}							// pImpl 포인터만 맞바꿉니다.
}

우선 함수 시작부분에 있는 'template<>'을 봐 주세요. 이 함수가 std::swap의 완전
템플릿 특수화(total template specialization) 함수라는 것을 컴파일러에게 알려 주는 
부분입니다. 그리고 함수 이름 뒤에 있는 '<Widget>'은 T가 Widget일 경우에 대한 특수화라
는 사실을 알려 주는 부분이고요. 다시 말해, 타입에 무관한 swap 템플릿이 Widget에 적
용될 때는 위의 함수 구현을 사용해야 한다는 뜻입니다. 일반적으로 std 네임스페이스의
구성요소는 함부로 변경하거나 할 수 없지만, 프로그래머가 직접 만든 타입(Wideget 등)에
대해 표준 템플릿(swap 같은)을 완전 특수화하는 것은 허용이 됩니다. 지금처럼 말이죠.

그렇지만 필자가 미리 자수했듯이 이 함수는 컴파일되지 않습니다. 문법이 틀려서 그런 것은
아니고, a와 b에 들어 있는 pImpl 포인터에 접근하려고 히는데 이들 포인터가 private
멤버이기 때문입니다. 특수화 함수를 프렌드로 선언할 수도 있었지만, 이렇게 하면 표준 템플
릿들에 쓰인 규칙과 어긋나므로 좋은 모양은 아닙니다. 그래서 Widget 안에 swap 이라는
public 멤버 함수를 선언하고 그 함수가 실제 맞비꾸기를 수행하도록 만든 후에, std::swap
의 특수화 함수에게 그 멤버 함수를 호출하는 일을 맡깁니다.

class Widget		// swap 멤버 함수가 추가된 버전
{
public:
	...
	void swap(Widget& other)
	{
		using std::swap;		 // 이 선언문이 필요한 이유는 이후의 설명에서
								 // 확인할 수 있습니다.
		swap(pImpl, other.pImpl);// Widget을 맞바꾸기 위해, 각 Widget의
	}							 // pImpl 포인터를 맞바꿉니다.
	...
};

namespace std
{
	template<>								// std::swap 템플릿의 특수화 함수를
	void swap<Widget>(Widget& a, Widget& b) // 살짝 고친 결과
	{
		a.swap(b);			// Widget을 맞바꾸기 위해, swap 멤버 함수를 호출합니다.
	}
}

컴파일될 뿐만 아니라, 기존의 STL 컨테이너와 일관성도 유지되는 착한 코드가 되었습니다.
public 멤버 함수 버전의 swap과 이 멤버 함수를 호출히는 std::swap의 특수화 함수
모두 지원하고 있고요.

그런데 이제 이런 가정을 하나 더 해 봅시다. Widget과 WidgetImpl이 클래스가 아니
라 클래스 템플릿으로 만들어져 있어서, WidgetImpl에 저장된 데이터의 타입을 매개변수
로 꿀 수 있다면 어떻게 될까요? 