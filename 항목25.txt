항목 25: 예외를 던지지 않는 swap에 대한 지원도 생각해 보자

swap은 상당히 재미있는 함수입니다. swap은 초창기부터 STL에 포함된 이래로 예외 안전
성 프로그래밍(항목 29 참조)에 없어선 안 될 감초 역할로서, 자기대입 현상(항목 11 참조)의
가능성에 대처하기 위한 대표적인 메커니즘으로서 널리 사랑받아 왔습니다. 이렇게 쓸모가
많다보니 swap을 어떻게 제대로 구현하느냐가 굉장히 중요해졌지요. 하지만 예쁘면 얼굴값
한다고? 이 함수에 관련된 특이한 말썽거리들도 있는 것이 사실입니다. 대체 어떤 말썽거리가 
있으며, 또 어떻게 대처해야 쓸 만한 swap을 만들 수 있는가를 심도 있게 파헤쳐 보는 
것이 이번 항목의 주제 되겠습니다.

두 객체의 값을 '맞바꾸기(swap)'한다는 것은 각자의 값을 상대방에게 주는 동작입니다. 기본
적으로는 이 맞바꾸기 동작을 위해 표준 라이브러리에서 제공하는 swap 알고리즘을 쓰는
데, 이 알고리즘이 구현된 모습을 보면 여러분이 알고 있는 그 'swap'과 하나도 다르지 않
다는 것을 알 수 있습니다.

namespace std
{
	template<typename T>	// std::swap의 전형적인 a의 값과 b의 값을
	void swap(T& a, T& b)	// 맞바꿉니다.
	{
		T temp(a);
		a = b;
		b = temp;
	}
}

표준에서 기본적으로 제공히는 swap(이하 표준 swap)은 구현 코드를 보시면 알겠지만 복사
만 제대로 지원하는(복사 생성자 및 복사 대입 연산자를 통해) 타입이기만 하면 어떤 타입의
객체이든 맞바꾸기 동작을 수행해 줍니다. swap을 위해 특별히 추가 코드를 마련하거나 할
필요가 없습니다.

하지만, 표준 swap의 동작을 보고 짜릿한 감동을 느끼거나 소름이 돋는 분은 아마 없을 겁
니다. 한 번 호출에 복사가 세 번, a에서 temp로, b에서 a로, temp에서 b로 말이죠. 
타입에 따라서는 이런 사본이 정말 필요 없는 경우도 있는데, 이런 타입을 표준 swap에 넘겨 
호출하는 것은 마치 경주용 트랙을 달리다가 갑자기 산골 오솔길로 접어드는 격이겠지요.

복사하면 손해를 보는 타입들 중 으뜸을 꼽는다면 아마도 다른 타입의 실제 데이터를 가리
키는 포인터가 주성분(!)인 타입일 것입니다. 이러한 개념을 설계의 미학으로 끌어올려 많이
들 쓰고 있는 기법이 바로 'pimpl 5) 관용구(idiom)'('pointer to implementation'
이란 뜻입니다. 항목 31 참조)이지요. 이해를 돕는 의미에서, pimpl 설계를 차용하여 
Widget 클래스를 만든예를 보여 드리죠.

5) 허버 서터(Herb Sutter)가 처음 정리하여 제안한 용어로 알려져 있다. 그의 저서인
"Exceptional C++"(AddisonWesley, 1999)를 참고하기 바란다. - 옮긴이

class WidgetImpl	// Widget의 실제 데이터를 나타내는 클래스 세부사항은
{					// 별로 중요하지 않습니다.
public:
	...
private:
	int a, b, c;	// 아마도 많은 데이터가 있겠죠.
	std::vector<double> v;	// 어쨌든 복사 비용이 높아요!
	...
};

class Widget		// pimpl 관용구를 사용한 클래스
{
public:
	Widget(const Widget& rhs);
	Widget& operator=(const Widget& rhs)// Widget 복사하기 위해, 자신
	{									// WidgetImpl 객체를 복사합니다.
		...								// operator=의 일반적인 구현 방법에
		*pImpl = *(rhs.pImpl);			// 대한 자세한 내용이 궁금하신 분은
		...								// 항목 10, 11, 12를 읽어보세요.
	}
	...
private:
	WidgetImpl* pImpl;		// Widget의 실제 데이터를 가진 객체에 대한 포인터
};

이렇게 만들어진 Widget 객체를 우리가 직접 맞바꾼다면, pImpl 포인터만 살짝 바꾸는 것
말고는 실제로 할 일이 없습니다. 하지만 이런 사정을 표준 swap 알고리즘이 알 턱이 있을
까요? 언제나처럼 Widget 객체 세 개를 복사하고 그것도 모자라 WidgetImpl 객체 세 개
도 복사할 것입니다. 아주 심하게 비효율적입니다.

그래서 조금 손을 보고 싶습니다. std::swap에다가 뭔가를 알려 주는 거죠. Widget 객
체를 맞바꿀 때는 일반적인 방법을 쓰지 말고 내부의 pImpl 포인터만 맞바꾸라고 말입니
다. C++로는 방금 제가 이야기한 그대로 할 수 는 방법이 있습니다 std::swap을
Widget에 대해 특수화(specialize) 하는 것인데, 일단 기본 아이디어만 간단히 코드로 
보여 드리겠습니다. 아직 컴파일은 안 되니 주의하세요.

namespace std
{
	template<>						// 이 코드가 T가 Widget일 경우에
	void swap<Widget>(Widget& a,	// 대해 std::swap을 특수화한 것입
	Widget& b)						// 니다. 아직 컴파일되지는 않습니다.
	{								
		swap(a.pImpl, b.pImpl);	// Widget을 'swap'하기 위해, 각자의 
	}							// pImpl 포인터만 맞바꿉니다.
}

우선 함수 시작부분에 있는 'template<>'을 봐 주세요. 이 함수가 std::swap의 완전
템플릿 특수화(total template specialization) 함수라는 것을 컴파일러에게 알려 주는 
부분입니다. 그리고 함수 이름 뒤에 있는 '<Widget>'은 T가 Widget일 경우에 대한 특수화라
는 사실을 알려 주는 부분이고요. 다시 말해, 타입에 무관한 swap 템플릿이 Widget에 적
용될 때는 위의 함수 구현을 사용해야 한다는 뜻입니다. 일반적으로 std 네임스페이스의
구성요소는 함부로 변경하거나 할 수 없지만, 프로그래머가 직접 만든 타입(Wideget 등)에
대해 표준 템플릿(swap 같은)을 완전 특수화하는 것은 허용이 됩니다. 지금처럼 말이죠.

그렇지만 필자가 미리 자수했듯이 이 함수는 컴파일되지 않습니다. 문법이 틀려서 그런 것은
아니고, a와 b에 들어 있는 pImpl 포인터에 접근하려고 히는데 이들 포인터가 private
멤버이기 때문입니다. 특수화 함수를 프렌드로 선언할 수도 있었지만, 이렇게 하면 표준 템플
릿들에 쓰인 규칙과 어긋나므로 좋은 모양은 아닙니다. 그래서 Widget 안에 swap 이라는
public 멤버 함수를 선언하고 그 함수가 실제 맞비꾸기를 수행하도록 만든 후에, std::swap
의 특수화 함수에게 그 멤버 함수를 호출하는 일을 맡깁니다.

class Widget		// swap 멤버 함수가 추가된 버전
{
public:
	...
	void swap(Widget& other)
	{
		using std::swap;		 // 이 선언문이 필요한 이유는 이후의 설명에서
								 // 확인할 수 있습니다.
		swap(pImpl, other.pImpl);// Widget을 맞바꾸기 위해, 각 Widget의
	}							 // pImpl 포인터를 맞바꿉니다.
	...
};

namespace std
{
	template<>								// std::swap 템플릿의 특수화 함수를
	void swap<Widget>(Widget& a, Widget& b) // 살짝 고친 결과
	{
		a.swap(b);			// Widget을 맞바꾸기 위해, swap 멤버 함수를 호출합니다.
	}
}

컴파일될 뿐만 아니라, 기존의 STL 컨테이너와 일관성도 유지되는 착한 코드가 되었습니다.
public 멤버 함수 버전의 swap과 이 멤버 함수를 호출히는 std::swap의 특수화 함수
모두 지원하고 있고요.

그런데 이제 이런 가정을 하나 더 해 봅시다. Widget과 WidgetImpl이 클래스가 아니
라 클래스 템플릿으로 만들어져 있어서, WidgetImpl에 저장된 데이터의 타입을 매개변수
로 꿀 수 있다면 어떻게 될까요? 

template<typename T>
class WidgetImpl { ... };

template<typename T>
class Widget { ... };

swap 멤버 함수를 Widget에(필요하면 WidgetImpl에도) 넣는 정도는 먼젓번 경우처럼
별로 어렵지 않지만, std::swap을 특수화하는 데서 좌절모드로 들어가게 됩니다. 사실 우
리가 작성 하려고 했던 코드는 이런 것이었단 말이죠.

namespace std
{
	template<typename T>
	void swap<Widget<T>>(Widget<T>& a,	// 에러! 적법하지 않은 코드
						Widget<T>& b)
	{
		a.swap(b);
	}
}

우리 눈에는 퍼펙트하고 깔끔해 보이지만, C++의 기준에는 적법하지 않다는 점이 걸림돌이
되고 말았습니다. 우리는 지금 함수 템플릿(std::swap)을 부분적으로 특수화해 달라고 컴파
일러에게 요청한 것인데, C++는 클래스 템플릿에 대해서는 부분 특수화(partial specialization)
를 허용하지만 함수 템플릿에 대해서는 허용하지 않도록 정해져 있습니다. 그러니 컴파일이
안 되는 것이 당연하지요(함수 템플릿의 부분 특수화를 받아들이는 어리버리한 컴파일러도 물론
있긴 합니다만).

함수 템플릿을 '부분적으로 특수화'하고 싶을 때 흔히 취하는 방법은 그냥 오버로드 버전을
하나 추가히는 것입니다. 즉, 이렇게 하라는 거죠.

namespace std
{
	template<typename T>
	void swap(Widget<T>& a,	// std::swap을 오버로드한 함수("swap" 뒤에 "<...>")
			  Widget<T>& b)	// 가 없는 것을 놓치지 마세요)인데요. 이 코드가 왜 
	{						// 유효하지 않은지에 대한 이야기가 이후에 이어집니다.
		a.swap(b);
	}
}

일반적으로 함수 템플릿의 오버로딩은 해도 별 문제가 없지만, std는 조금 특별한 네임스페
이스이기 때문에 이 네임 페이스에 대한 규칙도 다소 특별합니다. 요컨대, std 내의 템플릿
에 대한 완전 특수화는 가능하지만, std에 새로운 템플릿을 추가하는 것은 안됩니다.
(혹은 클래스든 함수든 어떤 것도 안 됩니다). std에 들어가는 구성요소의 결정은 전적으로
C++ 표준화 위원회에 달려 있기 때문에, 그분들께서 결정한 거룩한 성역에는 티끌 하나라도
얹을 수 없도록 금지하고 있는 것이죠. 으휴... 그런데, 그 '금지'하는 모양이 사람 마음을 무
척 불편하게 만든단 말입니다. std의 영역을 침범하더라도 일단 컴파일까지는 거의 다 되고
실행도 됩니다. 그런데 실행되는 결과가 미정의 사항이라는 것입니다. 여러분 소프트웨어가
여러분 생각대로 돌아가게 만들고 싶으시면, std에 절대 아무것도 추가하지 마세요.

그럼 뭘 어쩌라고요? 어찌 됐든 우리는 친애하는 사용자님 께서 swap을 호출해서 우리만
의 효율 좋은 '템플릿 전용 버전'을 쓸 수 있었으면 좋겠단 말입니다. 설레발을 떨긴 했으나
방법은 간단합니다. 멤버 swap을 호출하는 비멤버 swap을 선언해 놓되, 이 비멤버 함수를
std::swap의 특수화 버전이나 오버로딩 벼전으로 선언하지만 않으면 됩니다. 예를 들어,
이번 항목에 나온 Widget 관련 기능이 전부 WidgetStuff 네임스페이스에 들어 있다고
가정하면 다음과 같이 만들라는 이야기입니다.

namespace WidgetStuff
{
	...						// 템플릿으로 만들어진 WidgetImpl 및 기타 등등
	template<typename T>	// 이전과 마찬가지로 swap이란 이름의 멤버 함수가
	class Widget { ... };	// 들어 있습니다.
	...
	template<typename T>	// 비멤버 swap 함수
	void swap(Widget<T>& a,	// 이번엔 std 네임스페이스의 일부가 아닙니다.
				Widget<T>&b)
	{
		a.swap(b);
	}
}

이제는 어떤 코드가 두 Widget 객체에 대해 swap을 호출하더라도, 컴파일러는 C++의
이름 탐색 규칙[아참, 이 규칙은 인자 기반 탐색 argument-dependent lookup) 혹은 
쾨니그 탐색(Koenig lookup)이란 이름으로 알려져 있습니다]6)에 의해 WidgetStuff 
네임스페이스 안에서 Widget 특수화 버전을 찾아냅니다. 오예, 이것이 바로 우리가 원하던 
바였습니다.

이 간단한 방법은 클래스 템플릿뿐만 아니라 클래스에 대해서도 잘 통하므로, 언제든 이 방
법을 써야 할 것 같다는 느낌이 들긴 합니다. 긴 인생 힘들게 살다 보면 반드시 클래스에 대
해 std::swap을 특수화해야 할 이유가 생기기 때문에(뒤에서 짧게 설명드리겠습니다), 여러
분이 만든 '클래스 타입 전용의 swap'이 되도록 많은 곳에서 호출되도록 만들고 싶으시면(그
리고 그런 swap을 갖고 있다면), 그 클래스와 동일한 네임스페이스 안에 비멤버 버전의 swap
을 만들어 넣고, 그와 동시에 std::swap의 특수화 버전도 준비해 두어야 하겠습니다.

그런데 이죠, 위의 모든 사항들은 여러분이 네임스페이스를 안 쓰고 있어도 여전히 유효
합니다(멤버 swap을 호출하는 비멤버 swap이 필요하다는 말씀입니다). 하지만 전역 네임스페이
스(global namespace)를 못 잡아먹어서 안달복달할 필요가 있을까요? 클래스며, 템플릿이며,
함수며, 나열자 타입이며, 나열자 상수며, typedef 타입 등의 온갖 이름을 전역 네임스페
이스에 들이대면서 말이죠. 그런 분들께는 혹시 예의범절 탑재가 몇 년 더딘 건 아니냐고
묻고싶네요.

지금까지 함께 살펴본 내용은 전부 swap을 구현하는 사람들 쪽에 무게가 가 있었지만, 이
제는 고객의 눈으로 어떤 상황 하나를 놓고 이야기해 보도록 하지요. 여러분이 어떤 함수
템플릿을 만들고 있는데, 이 함수 템플릿은 실행 중에 swap을 써서 두 객체의 값을 맞바꾸
어야 한다고 가정합시다.

template<typename T>
void doSomething(T& obj1, T& obj2)
{
	...
	swap(obj1, obj2);
	...
}

6)  어떤 함수에 어떤 타입의 인자가 있으연, 그 함수의 이름을 찾기 위해 해당 타입의 인자가 위치한 네임스페이스 내
부의 이름을 탐색해 들어간다는 간단한 규칙이다. ADL(Argument Dependent Lookup) 이란 약자로 많이 불린다.
'쾨니그'의 Koenig는 C++ 표준화 위원회 임원이자 이 규칙을 창안한 앤드류 콰니그(A ndrew Koenig)의 이름에서
따온 것이다. "TC++PL"을 가지고 계신 독자는 8.2.6 절을 참고하고, 없는 독자는 위키피디아(www.wikipedia.org)
등을 검색해 보거나 우리말 웹페이지인 http://www.debulab.com/knowledge/koeniglookup.html 에 방문해 볼 것을
권한다. 참고로, 2.95 이상의 gcc는 ADL을 완벽히 따르며, 7/7.1 미만의 MSVC는 연산자 함수에 대해서만 ADL
을 따른다.-옮긴이

이 부분에서 과연 어떤 swap을 호출해야 할까요? 가능성은 세 가지입니다. (1) std에 있는
일반형 버전: 이것은 확실히 있습니다. (2) std의 일반형을 특수화한 버전: 있을 수도, 없을
수도 있습니다. (3) T 타입 전용의 버전: 있거나 없거나 할 수 있으며, 어떤 네임스페이스
안에 있거나 없거나 할 수도 있습니다(하지만 확실히 std 안에는 없어야 하겠지요). 여러분은
타입 T 전용 버전이 있으면 그것이 호출되도록 하고, T 타입 전용 버전이 없으떤 std 의
일반형 버전이 호출되도록 만들고 싶습니다. 어떻게 이렇게 끌어낼 수 있을까요? 아래의
코드가 정답입니다.

template<typename T>
void doSomething(T& obj1, T& obj2)
{
	using std::swap;	// std::swap을 이 함수 안으로 끌어올 수 있도록 만든다.
	...
	swap(obj1, obj2);	// T 타입 전용의 swap을 호출합니다.
	...
}

컴파일러가 위의 swap 호출문을 만났을 때 하는 일은 현재의 상황에 딱 맞는 swap을 찾
는 것입니다. C++의 이름 탐색 규칙을 따라, 우선 전역 유효범위 혹은 타입 T와 동일한 
네임스페이스 안에 T 전용의 swap이 있는지를 찾습니다[예를 들어 T가 WidgetStuff 네임스
페이스 내의 Widget이라면, 컴파일러는 인자 의존 규칙(앞에서 보셨죠?)을 적용하여 Widget-
Stuff의 swap을 찾아낼 것입니다. T 전용 swap이 없으면 컴파일러는 그 다음 순서를 밟는
데, 이 함수가 std::swap을 볼 수 있게 해 주는 using 선언(using declaration)이 함수
앞부분에 떡 하니 있기 때문에 std의 swap을 쓰게끔 결정할 수도 있습니다. 하지만 이런
상황이 되더라도 컴파일러는 std::swap의 T 전용 버전을 일반형 템플릿보다 더 우선적
으로 선택하도록 정해져 있기 때문에, T에 대한 std::swap의 특수화 버전이 이미 준비되
어 있으면 결국 그 특수화 버전이 쓰이게 됩니다.

쉽죠? 원하는 swap이 호출되도록 만드는 작업은 별로 어렵지 않습니다. 이거 딱 하나만 조
심하면 됩니다. 호출문에 한정자를 잘못 붙이거나 하지는 마세요. 한정자가 붙게 되면 C++
가 호출될 함수를 결정하는 메커나즘에 바로 영향이 가기 때문입니다. 예를 들어, 위의
swap 호출문을 아래와 같이 써 버리면,

std::swap(obj1, obj2);		// swap을 호출하는 잘못된 방법

std의 swap(그 어떤 템플릿 특수화 버전들도 포함해서) 외의 다른 것은 거들떠보지도 말라고
컴파일러를 구속하게 됩니다. 더 딱 맞을 수 있는 T 전용 버전이 다른 곳에 있을 가능성을
완전히 무시히는 것이죠. 안타깝게도 수련이 조금 더 필요한 프로그래머들이 버젓이 함수
호출문을 이렇게 한정화하는 경우를 주변에서 더러 발견하곤 한답니다. 클래스에 대해
std::swap을 완전히 특수화하는 게 중요한 이유가 바로 이것입니다. 이렇게 해 두면 잘
못 한정화된 호출문으로도 타입 T 전용의 swap 함수를 끌어와 쓸 수 있기 때문입니다(시중
의 표준 라이브러리 중에도 이런 코드가 들어 있는 예가 꽤 있기 때문에, 이런 코드가 가능한 효율
적으로 동작하는 데 도움을 주는 편이 여러분에게 이익이 됩니다).

따라오느라 힘드셨죠? 이번 항목에서는 표준 swap, 멤버 swap, 비멤버 swap, 특수화한
std::swap 그리고 swap 호출 시의 상황들에 대해 집중적으로 조명해 보았습니다. 이제
차근히 정리해 보는 시간을 가져 보죠.

첫째, 표준에서 제공하는 swap이 여러분의 클래스 및 클래스 템플릿에 대해 납득할 만한
효율을 보이면, 그냥 아무것도 하지 말고 지내세요. 여러분야 만든 타입으로 만든 객체에 대
해 'swap'을 시도하는 사용자 코드는 표준 swap을 호출하게 될 것입니다. 그리고 아무 문
제도 없을거고요.

둘째, 그런데 표준 swap의 효율이 기대한 만큼 충분하지 않다면(여러분의 클래스 혹은 클래
스 템플릿이 pimpl 관용구와 비슷하게 만들어져 있을 경우가 십중팔구입니다), 다음과 같이 
하십시오. 

1.	여러분의 타입으로 만들어진 두 객체의 값을 빛나게 빨리 맞바꾸는 함수를 swap이라
	는 이름으로 만들고, 이것을 public 멤버 함수로 두십시오. 단, 좀 있다가 이유를 말
	씀드리겠지만, 이 함수는 절대로 예외를 던져선 안 됩니다.
2.	여러분의 클래스 혹은 템플릿이 들어 있는 네임스페이스와 같은 네임스페이스에 비멤
	버 swap을 만들어 넣습니다. 그리고 1번에서 만든 swap 멤버 함수를 이 비멤버 함
	수가 호출하도록 만듭니다.
3.	새로운 클래스(클래스 템플릿이 아니라)를 만들고 있다면, 그 클래스에 대한 std::swap
	의 특수화 버전을 준비해 둡니다. 그리고 이 특수화 버전에서도 swap 멤버 함수를 호
	출하도록 만듭니다.

셋째이자 마지막입니다. 사용자 입장에서 swap을 호출할 때, swap을 호출히는 함수가
std::swap을 볼 수 있도록 using 선언을 반드시 포함시킵니다. 그 다음에 swap을 호
출하되, 네임스페이스 한정자를 붙이지 않도록 하십시오.

마무리 짓지 않은 이야기가 이제 딱 하나 남았네요. 지금 세 가지 사항을 정리하면서, 멤버
버전의 swap은 절대로 예외를 던지지 않도록 만들라고 했습니다. 그 이유는 swap을 진짜
쓸모 있게 응용하는 방법들 중에 클래스(및 클래스 템플릿)가 강력한 예외 안전성 보장(strong
exception-safety guarantee)7)을 제공하도록 도움을 주는 방법이 있기 때문입니다. 그 방법의
전말은 항목 29에서 볼 수 있습니다. 그런데 이 기법은 멤버 버전 swap이 예외를 던지지
않아야 한다는 가정을 깔고 있습니다. 하필 멤버 버전만 이렇습니다! 비멤버 버전의 경우,
표준 swap은 복사 생성과 복사 대입에 기반하고 있는데 일반적으로 복사 생성 및 복사 대입
함수는 예외 발생이 허용되기 때문에 이런 제약을 받지 않습니다. 따라서 swap을 직접 만
들어 보실 분은 두 값을 빠르게 바꾸는 방법만 구현하고 끝내면 안 되겠지요? 예외를 던지
지 않는 방법도 함께 준비하는 센스가 필요합니다. 다행히, '효율'과 '예외 금지'의 두 가지
특성은 함께 붙어 다니는 경우가 대부분입니다. 효율이 대단히 좋은 swap 함수는 거의 항
상 기본제공 타입(pimpl 관용구 기반의 설계에서 쓰이는 포인터처럼)을 사용한 연산으로 만들어
지기 때문입니다. 그리고 기본 제공 타입을 사용한 연산은 절대로 예외를 던지지 않거든요.

이것만은 잊지 말자!
*	std::swap이 여러분의 타입에 대해 느리게 동작할 여지가 있다면 swap 멤버 함수를
	제공합시다. 이 멈버 swap은 예외를 던지지 않도록 만듭시다.
*	멈버 swap을 제공했으면, 이 멤버를 호출하는 비멤버 swap도 제공합니다. 클래스(템플릿
	이 아닌)에 대해서는, std::swap도 특수화해 둡시다.
*	사용자 입장에서 swap을 호출할 때는, std::swap에 대한 using 선언을 넣어 준
	후에 네임스페이스 한정 없이 swap을 호출합시다.
*	사용자 정의 타입에 대한 std 템플릿을 완전 특수화하는 것은 가능합니다. 그러나 std에
	어떤 것이라도 새로 '추가'하려고 들지는 마십시오 .

7) 어떤 연산이 실행되다가 예외가 발생되면 그 연산이 시작되기 전의 상태로 돌릴 수 있다는 보장.
	"TC++PL"(S/E)의 E.2를 참고하거나 이 책의 항목 29를 읽어 보기 바란다.-옮긴이 
