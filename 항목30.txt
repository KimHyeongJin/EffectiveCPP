항목 30: 인라인 함수는 미주알고주알 따져서 이해해 두자

인라인 함수, 아무리 생각해도 훌륭한 아이디어 아닙니까? 함수처럼 보이고 함수처럼 동작하
는데다가, 매크로보다 훨씬 안전하고 쓰기 좋습니다(항목 2 참조). 함수 호출 시 발생하는 오
버헤드도 걱정할 필요가 없고요. 여기에 뭘 더 바랄 게 있을까요?

인라인 함수에는 여러분이 잘 모르고 계시는 이점이 하나 숨겨져 있답니다. 함수 호출 비용이 
면제되는 것은 눈에 보이는 부분에 불과하다고요. 대체적으로 컴파일러 최적화는 함수 호출이 
없는 코드가 연속적으로 이어지는 구간에 적용되도록 설계되었기 때문에, 인라인 함수를 사용
하면 컴파일러가 함수 본문에 대해 문맥별(context-specific) 최적화를 걸기가 용이해집니
다. 실제로 대부분의 컴피일러는 '아웃라인(outline)' 함수 호출5)에 대해 이런 최적화를 
적용하지 않습니다.

5)	일반적인 함수 호출을 뜻한다. 함수의 본문을 그대로 끼워 넣는다는 뜻의 인라인 함수와 
	반대로, 보통의 함수 호출은 개요만을 써 놓는 것과 같다는 의미로 생각하면 무리가 
	없을 듯. 아웃라인 함수란 용어는 인라인 함수의 뜻을 부각시키기 위해 이후에도 계속 
	같은 의미로 사용하였다-옮긴이 

그러나 프로그래밍은 우리네 사람살이와 별반 다르지 않습니다. 세상에 공짜 점심 같은 것
은 없듯이 인라인 함수 역시 예외가 아닙니다. 인라인 함수의 아이디어는 함수 호출문을 그 
함수의 본문으로 바꿔치기하자는 것이라서, 통계학 박사 논문감은 못 된다고 봐야 합니다.
목적 코드의 크기가 커질 게 뻔하니까요. 메모리가 제한된 컴퓨터에서 아무 생각 없이 인라
인을 남발했다가는 프로그램 크기가 그 기계에서 쓸 수 있는 공간을 넘어버릴 수도 있습니
다. 가상 메모리를 쓰는 환경일지라도 인라인 함수로 인해 부풀려진 코드는 성능의 걸림돌
이 되기 쉽습니다. 페이징 횟수가 늘어나고, 명령어 캐시 적중률이 떨어질 가능성도 높아집
니다. 수행 성능은 이런 문제들과 얽히면서 타격을 입는 것이고 말이죠.

반대의 경우도 있습니다. 본문 길이가 굉장히 짧은 인라인 함수를 사용하면, 함수 본문에 
대해 만들어지는 코드의 크기가 함수 호출문에 대해 만들어지는 코드보다 작아질 수도 있습
니다. 바로 이런 경우에는 상황이 바뀐답니다. 목적 코드의 크기도 작아지며 명령어 캐시 
적중률도 높아지지요.

달들 아시겠지만 inline은 컴파일러에 대해 '요청'을 하는 것이지, '명령'이 아닙니다. 
이 요청은 inline을 붙이지 않아도 그냥 눈치껏 되는 경우도 있고 명시적으로 할 수도 있습
니다. 우선 암시적인 방법부터 알아보죠. 클래스 정의6) 안에 함수를 바로 정의해 넣으면 컴
파일러는 그 함수를 인라인 힘수 후보로 찍습니다.

class Person
{
public:
	...
	int age() const { return theAge; }	// 암시적인 인라인 요청: age는
	...									// 클래스 정의 내부에서 정의되었습니다.
private:
	int theAge;
};

이런 함수는 대개 멤버 함수이지만, 항목 46을 보시면 프렌드 함수도 클래스 내부에서 정의
될 수 있다는 내용이 나오니 참고하세요. 어쨌든 이런 경우에는 암시적으로 인라인 함수로
선언됩니다.

6)	'클래스 선언'이라고 해도 무방한 부분이다. 일반적으로 클래스 선언은 class foo{}; 
	부분이고[대개 헤더(선언)파일에 위치] 클래스 정의는 foo::bar() 등의 멤버 함수 
	본문을 만드는 것[대개 구현(정의) 파일에 위치]이라고 알고 있기 때문에, 이질감이 
	느껴질 수 있다. 사실 C++의 클래스는 멤버 함수 선언 외에도 멤버 데이터 및(인라인) 
	함수 본문 등의 구현 세부사항이 들어갈 수 있으며, 대개 이런 형태가 많이 쓰이기 때문에 
	class declaration이란 말보다는 class definition이란 말을 원저자가 강조해서 
	표현했다고 봐 주기 바란다. 이번 장의 이후 항목에서도 이런 의미로 class declaration
	자리에 class definition이 오고 있음을 알려 둔다.-옮긴이 


인라인 힘수를 선언하는 적인 방법은 함수 정의 에 inli ne 키워드를 붙이는 것입니다. 
한 예로, 표준 라이브러리의 max 템플릿(<algorithm>에 있습니다)은 대개 다음과 같
이 구현되어 있어요.

template<typename T>	// 명시적인 인라인 요청
inline const T& std::max(const T& a, const T& b)
{ return a < b ? b:a ; }	// std::max 앞에 "inline"이 붙어 있습니다.

max가 템플릿이라는 점 때문에 '인라인 함수와 템플릿은 대개 헤더 파일 안에 정의한다'라
는 이야기가 생각나기도 합니다. 이 점을 오해해서 함수 템플릿은 반드시 인라인 함수이어
야 한다고 결론 내리시는 화끈한 분들이 있는데요. 맞지도 않을 뿐더러 이렇게 알고 사시다
간 나중에 뒤통수를 맞을 수도 있습니다. 그러니까 지금 잘 따라오세요.

인라인 함수는 대체적으로 헤더 파일에 들어 있어야 하는 게 맞습니다. 왜냐하면 대부분의
빌드 환경에서 인라인을 컴파일 도중에 수행하기 때문입니다. 인라인 함수 호출을 그 함수의
본문으로 바꿔치기하려면, 일단 컴파일러는 그 함수가 어떤 형태인지 알고 있어야 하거든요.
[링크 도중에 인라인을 수행하는 빌드 환경도 있긴 있습니다. 몇몇 경우엔 런타임에 하는 것들도-
예를 들면 닷넷 공통 언어 내부구조(Common Language Infrastructure: CLI)에 기반한 
닷넷 관리(managed) 환경들- 있고요. 하지만 이들은 예외일 뿐, 규칙에 들어가진 않습니다. 
대부분의 C++프로그램에서 함수 인라인은 컴파일 타임에 진행되는 작업입니다].

템플릿 역시, 대체적으로 헤더 파일에 들어 있어야 맞습니다. 템플릿이 사용되는 부분에서
해당 템플릿을 인스턴스로 만들려면 그것이 어떻게 생겼는지를 컴파일러가 알아야 하기 때
문입니다(인라인 함수와 마찬가지로 이 부분도 모두 그런 것은 아닙니다. 어떤 빌드 환경은 
링크 도중에 템플릿 인스턴스화를 수행하기도 하거든요. 그렇지만 대세는 컴파일 타임 인스턴
스화입니다).

그런데 템플릿 인스턴스화는 인라인과 완전히 별개로, 하등의 관련이 없습니다. 어떤 템플릿
을 만들고 있는데 이 템플릿으로부터 만들어지는 모든 함수가 인라인 함수였으면 싶은 경우
에 그 템플릿에 inline을 붙여 선언하는 것이고, 그게 끝이라고요. 위에서 보신 std::
max가 바로 이 경우입니다. 만들고 있는 함수 템플릿이 굳이 인라인될 이유가 없다면 그
템플릿을 인라인 함수로 선언하지 않아도 됩니다(명시적이든 암시적이든 말입니다). 인라인은
분명 비용을 동반하는 동작입니다. 아무렇지도 않게 일어나도록 내버려 둬도 괜찮은 성질의
것이 아니라는 거예요. 인라인이 끌고 오는 비용이 바로 코드 비대화(템플릿을 만들 경우에
더욱 각별히 신경 써야 합니다. 항목 44 참조)라는 점은 이미 앞에서도 이야기한 바 있지만, 
이것 말고도 지불해야 하는 비용이 또 있으니 큰일 났습니다. 이에 대해서는 잠시 후에 알아보
도록하죠.

비용 문제도 문제이지만, 하던 이야기는 마무리 지읍시다. "inline은 컴파일러 선에서 무
시할 수 있는 요청이다"라는 이야기를 계속 하고 있었던 것, 기억하시죠? 대부분의 컴파일
러의 경우, 아무리 인라인 함수로 선언되어 있어도 자신이 보기에 복잡한 함수는 절대로 인
라인 확장의 대상에 넣지 않는데다가(루프가 들어 있다거나 재귀 함수인 경우가 이런 예입
니다), 정말 간단한 함수라 할지라도 가상 함수 호출 같은 것은 절대로 인라인해 주지 않습
니다. 사실 두 번째 부분은 그다지 놀랄 일도 아닌 것이, virtual의 의미가 "어떤 함수를 
호출 할지 결정하는 작업을 실행 중에 한다"라는 뜻이고 inline의 의미가 "함수 호출 위치에
호출된 함수를 끼워 넣는 작업을 프로그램 실행 전에 한다"라는 뜻이니 말이 안 되는 것도
아닙니다. 주어진 시점에 호출할 함수가 무엇이 될지를 컴파일러도 알 수 없다면 어쩔 수
없는 거잖아요. 이럴 땐 컴파일러가 함수 본문을 인라인하지 않더라도 짜증내면 안 됩니다.

이러쿵저러쿵 이야기하다 보니 이런 결론이 나옵니다. 인라인 함수가 실제로 인라인되느냐
안 되느냐의 여부는 전적으로 개발자가 사용히는 빌드 환경에 달렸다는 것이죠. 그 중에서도
칼자루를 쥐고 있는 쪽은 컴파일러이겠지요. 한 가지 다행스러운 사실은, 여러분이 요청한
함수에 대한 인라인이 실패했을 경우에 경고 메시지를 내주는 진단 수준 설정 기능이 대부
분의 컴파일러에 들어 있다는 점입니다(자세한 내용은 항목 53에서 참조하세요).

인라인 함수가 아니면 당장 내일부터 해가 서쪽에서 떠야 할 정도로 완벽한 인라인 조건을
갖추었는데도, 컴파일러가 인라인 함수의 본문에 대해 코드를 만드는 경우가 있습니다. 예를
들어 어떤 인라인 함수의 주소를 취하는 코드가 있으면, 컴파일러는 이 코드를 위해 아웃라
인 함수 본문을 만들 수밖에 없을 것입니다. 있지도 않은 함수에 대해 어떻게 포인터를 가
지고 오겠어요? 게다개 인라인 함수로 선언된 함수를 함수 포인터를 통해 호출하는 경우도
대개 인라인되지 않는답니다. 종합해 보면, 확실한 인라인 함수도 '어떻게 호출하느냐에 따
라 인라인되기도 하고 안 되기도 한디는 이야기입니다. 