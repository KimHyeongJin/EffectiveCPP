항목 30: 인라인 함수는 미주알고주알 따져서 이해해 두자

인라인 함수, 아무리 생각해도 훌륭한 아이디어 아닙니까? 함수처럼 보이고 함수처럼 동작하
는데다가, 매크로보다 훨씬 안전하고 쓰기 좋습니다(항목 2 참조). 함수 호출 시 발생하는 오
버헤드도 걱정할 필요가 없고요. 여기에 뭘 더 바랄 게 있을까요?

인라인 함수에는 여러분이 잘 모르고 계시는 이점이 하나 숨겨져 있답니다. 함수 호출 비용이 
면제되는 것은 눈에 보이는 부분에 불과하다고요. 대체적으로 컴파일러 최적화는 함수 호출이 
없는 코드가 연속적으로 이어지는 구간에 적용되도록 설계되었기 때문에, 인라인 함수를 사용
하면 컴파일러가 함수 본문에 대해 문맥별(context-specific) 최적화를 걸기가 용이해집니
다. 실제로 대부분의 컴피일러는 '아웃라인(outline)' 함수 호출5)에 대해 이런 최적화를 
적용하지 않습니다.

5)	일반적인 함수 호출을 뜻한다. 함수의 본문을 그대로 끼워 넣는다는 뜻의 인라인 함수와 
	반대로, 보통의 함수 호출은 개요만을 써 놓는 것과 같다는 의미로 생각하면 무리가 
	없을 듯. 아웃라인 함수란 용어는 인라인 함수의 뜻을 부각시키기 위해 이후에도 계속 
	같은 의미로 사용하였다-옮긴이 

그러나 프로그래밍은 우리네 사람살이와 별반 다르지 않습니다. 세상에 공짜 점심 같은 것
은 없듯이 인라인 함수 역시 예외가 아닙니다. 인라인 함수의 아이디어는 함수 호출문을 그 
함수의 본문으로 바꿔치기하자는 것이라서, 통계학 박사 논문감은 못 된다고 봐야 합니다.
목적 코드의 크기가 커질 게 뻔하니까요. 메모리가 제한된 컴퓨터에서 아무 생각 없이 인라
인을 남발했다가는 프로그램 크기가 그 기계에서 쓸 수 있는 공간을 넘어버릴 수도 있습니
다. 가상 메모리를 쓰는 환경일지라도 인라인 함수로 인해 부풀려진 코드는 성능의 걸림돌
이 되기 쉽습니다. 페이징 횟수가 늘어나고, 명령어 캐시 적중률이 떨어질 가능성도 높아집
니다. 수행 성능은 이런 문제들과 얽히면서 타격을 입는 것이고 말이죠.

반대의 경우도 있습니다. 본문 길이가 굉장히 짧은 인라인 함수를 사용하면, 함수 본문에 
대해 만들어지는 코드의 크기가 함수 호출문에 대해 만들어지는 코드보다 작아질 수도 있습
니다. 바로 이런 경우에는 상황이 바뀐답니다. 목적 코드의 크기도 작아지며 명령어 캐시 
적중률도 높아지지요.

달들 아시겠지만 inline은 컴파일러에 대해 '요청'을 하는 것이지, '명령'이 아닙니다. 
이 요청은 inline을 붙이지 않아도 그냥 눈치껏 되는 경우도 있고 명시적으로 할 수도 있습
니다. 우선 암시적인 방법부터 알아보죠. 클래스 정의6) 안에 함수를 바로 정의해 넣으면 컴
파일러는 그 함수를 인라인 힘수 후보로 찍습니다.

class Person
{
public:
	...
	int age() const { return theAge; }	// 암시적인 인라인 요청: age는
	...									// 클래스 정의 내부에서 정의되었습니다.
private:
	int theAge;
};

이런 함수는 대개 멤버 함수이지만, 항목 46을 보시면 프렌드 함수도 클래스 내부에서 정의
될 수 있다는 내용이 나오니 참고하세요. 어쨌든 이런 경우에는 암시적으로 인라인 함수로
선언됩니다.

6)	'클래스 선언'이라고 해도 무방한 부분이다. 일반적으로 클래스 선언은 class foo{}; 
	부분이고[대개 헤더(선언)파일에 위치] 클래스 정의는 foo::bar() 등의 멤버 함수 
	본문을 만드는 것[대개 구현(정의) 파일에 위치]이라고 알고 있기 때문에, 이질감이 
	느껴질 수 있다. 사실 C++의 클래스는 멤버 함수 선언 외에도 멤버 데이터 및(인라인) 
	함수 본문 등의 구현 세부사항이 들어갈 수 있으며, 대개 이런 형태가 많이 쓰이기 때문에 
	class declaration이란 말보다는 class definition이란 말을 원저자가 강조해서 
	표현했다고 봐 주기 바란다. 이번 장의 이후 항목에서도 이런 의미로 class declaration
	자리에 class definition이 오고 있음을 알려 둔다.-옮긴이 


인라인 힘수를 선언하는 적인 방법은 함수 정의 에 inli ne 키워드를 붙이는 것입니다. 
한 예로, 표준 라이브러리의 max 템플릿(<algorithm>에 있습니다)은 대개 다음과 같
이 구현되어 있어요.

template<typename T>	// 명시적인 인라인 요청
inline const T& std::max(const T& a, const T& b)
{ return a < b ? b:a ; }	// std::max 앞에 "inline"이 붙어 있습니다.

max가 템플릿이라는 점 때문에 '인라인 함수와 템플릿은 대개 헤더 파일 안에 정의한다'라
는 이야기가 생각나기도 합니다. 이 점을 오해해서 함수 템플릿은 반드시 인라인 함수이어
야 한다고 결론 내리시는 화끈한 분들이 있는데요. 맞지도 않을 뿐더러 이렇게 알고 사시다
간 나중에 뒤통수를 맞을 수도 있습니다. 그러니까 지금 잘 따라오세요.

인라인 함수는 대체적으로 헤더 파일에 들어 있어야 하는 게 맞습니다. 왜냐하면 대부분의
빌드 환경에서 인라인을 컴파일 도중에 수행하기 때문입니다. 인라인 함수 호출을 그 함수의
본문으로 바꿔치기하려면, 일단 컴파일러는 그 함수가 어떤 형태인지 알고 있어야 하거든요.
[링크 도중에 인라인을 수행하는 빌드 환경도 있긴 있습니다. 몇몇 경우엔 런타임에 하는 것들도-
예를 들면 닷넷 공통 언어 내부구조(Common Language Infrastructure: CLI)에 기반한 
닷넷 관리(managed) 환경들- 있고요. 하지만 이들은 예외일 뿐, 규칙에 들어가진 않습니다. 
대부분의 C++프로그램에서 함수 인라인은 컴파일 타임에 진행되는 작업입니다].

템플릿 역시, 대체적으로 헤더 파일에 들어 있어야 맞습니다. 템플릿이 사용되는 부분에서
해당 템플릿을 인스턴스로 만들려면 그것이 어떻게 생겼는지를 컴파일러가 알아야 하기 때
문입니다(인라인 함수와 마찬가지로 이 부분도 모두 그런 것은 아닙니다. 어떤 빌드 환경은 
링크 도중에 템플릿 인스턴스화를 수행하기도 하거든요. 그렇지만 대세는 컴파일 타임 인스턴
스화입니다).

그런데 템플릿 인스턴스화는 인라인과 완전히 별개로, 하등의 관련이 없습니다. 어떤 템플릿
을 만들고 있는데 이 템플릿으로부터 만들어지는 모든 함수가 인라인 함수였으면 싶은 경우
에 그 템플릿에 inline을 붙여 선언하는 것이고, 그게 끝이라고요. 위에서 보신 std::
max가 바로 이 경우입니다. 만들고 있는 함수 템플릿이 굳이 인라인될 이유가 없다면 그
템플릿을 인라인 함수로 선언하지 않아도 됩니다(명시적이든 암시적이든 말입니다). 인라인은
분명 비용을 동반하는 동작입니다. 아무렇지도 않게 일어나도록 내버려 둬도 괜찮은 성질의
것이 아니라는 거예요. 인라인이 끌고 오는 비용이 바로 코드 비대화(템플릿을 만들 경우에
더욱 각별히 신경 써야 합니다. 항목 44 참조)라는 점은 이미 앞에서도 이야기한 바 있지만, 
이것 말고도 지불해야 하는 비용이 또 있으니 큰일 났습니다. 이에 대해서는 잠시 후에 알아보
도록하죠.

비용 문제도 문제이지만, 하던 이야기는 마무리 지읍시다. "inline은 컴파일러 선에서 무
시할 수 있는 요청이다"라는 이야기를 계속 하고 있었던 것, 기억하시죠? 대부분의 컴파일
러의 경우, 아무리 인라인 함수로 선언되어 있어도 자신이 보기에 복잡한 함수는 절대로 인
라인 확장의 대상에 넣지 않는데다가(루프가 들어 있다거나 재귀 함수인 경우가 이런 예입
니다), 정말 간단한 함수라 할지라도 가상 함수 호출 같은 것은 절대로 인라인해 주지 않습
니다. 사실 두 번째 부분은 그다지 놀랄 일도 아닌 것이, virtual의 의미가 "어떤 함수를 
호출 할지 결정하는 작업을 실행 중에 한다"라는 뜻이고 inline의 의미가 "함수 호출 위치에
호출된 함수를 끼워 넣는 작업을 프로그램 실행 전에 한다"라는 뜻이니 말이 안 되는 것도
아닙니다. 주어진 시점에 호출할 함수가 무엇이 될지를 컴파일러도 알 수 없다면 어쩔 수
없는 거잖아요. 이럴 땐 컴파일러가 함수 본문을 인라인하지 않더라도 짜증내면 안 됩니다.

이러쿵저러쿵 이야기하다 보니 이런 결론이 나옵니다. 인라인 함수가 실제로 인라인되느냐
안 되느냐의 여부는 전적으로 개발자가 사용히는 빌드 환경에 달렸다는 것이죠. 그 중에서도
칼자루를 쥐고 있는 쪽은 컴파일러이겠지요. 한 가지 다행스러운 사실은, 여러분이 요청한
함수에 대한 인라인이 실패했을 경우에 경고 메시지를 내주는 진단 수준 설정 기능이 대부
분의 컴파일러에 들어 있다는 점입니다(자세한 내용은 항목 53에서 참조하세요).

인라인 함수가 아니면 당장 내일부터 해가 서쪽에서 떠야 할 정도로 완벽한 인라인 조건을
갖추었는데도, 컴파일러가 인라인 함수의 본문에 대해 코드를 만드는 경우가 있습니다. 예를
들어 어떤 인라인 함수의 주소를 취하는 코드가 있으면, 컴파일러는 이 코드를 위해 아웃라
인 함수 본문을 만들 수밖에 없을 것입니다. 있지도 않은 함수에 대해 어떻게 포인터를 가
지고 오겠어요? 게다개 인라인 함수로 선언된 함수를 함수 포인터를 통해 호출하는 경우도
대개 인라인되지 않는답니다. 종합해 보면, 확실한 인라인 함수도 '어떻게 호출하느냐에 따
라 인라인되기도 하고 안 되기도 한디는 이야기입니다.

inline void f() { ... }	// 이 f의 호출은 컴파일러가 반드시 인라인해 준다고
						// 가정합시다.
void (*pf)() = f;		// pf는 f를 가리키는 함수 포인터입니다.
...
f();					// 이 호출은 인라인 될것입니다. "평범한" 함수 호출
						// 이니까요.
pf();					// 이 호출은 인라인되지 않을 것입니다. 함수 포인터를
						// 통해 호출되고 있으니까요.

인라인되지 않는 인라인 함수는 여러분이 함수 포인터를 전혀 사용하지 않아도 여러분 주변
을 떠돌며 괴롭힐 수 있습니다. 프로그래머에게만 함수 포인터가 필요하다고 생각하시면 안
된다니까요. 컴파일러가 (인라인으로 선언된) 생성자 및 소멸자에 대해 아웃라인 함수 본문을 
만들 수도 있고 말이죠. 어떤 배열의 원소가 객체일 경우가 대표적인 예인데, 배열을 구성하
는 객체들을 생성하고 시킬 때 생성자/소멸자의 함수 포인터를 얻어내려면 함수 본문이
반드시 필요합니다.

이야기가 나왔으니 말인데, 생성자와 소멸자는 인라인하기에 그리 좋지 않은 함수입니다. 
대충 훑어보고 말할 수 있는 정도보다 사실 더 안 좋습니다. 예를 하나 들어 보죠. 아래의
Derived 클래스에 들어 있는 생성자를 보고 가만히 생각해 보세요.

class Base
{
public:
	...
private:
	std::string bm1, bm2;
};

class Derived: public Base
{
public:
	Derived(){}
	...
private:
	std::string dm1, dm2, dm3;	// Derived의 멤버1, 멤버2, 멤버3
};

Derived의 생성자는 생김새부터 인라인하기에 딱 좋아 보이는 인상입니다. 아무 코드도 
안 들어 있으니까요. 하지만 여러분은 여러분 눈에 속은 입니다.

C++는 객체가 생성되고 소멸될 때 일어나는 일들에 대해 여러 가지 보장을 준비해 놓았습
니다. 예를 들자면 아주 쉽게 들 수 있습니다. 여러분이 new를 하면 이때 동적으로 만들어
지는 객체를 생성자가 자동으로 초기화해 주는 것도 그렇고요. delete를 하면 이에 대응
되는 소멸자가 호출되는 것도 C++가 깔아둔 보장입니다. 어떤 객체를 여러분이 생성하면
그 객체의 기본 클래스 부분과 그 객체의 데이터 멤버들이 자동으로 생성되며, 그 객체가
소멸될 때 이에 반대되는 순서로 소멸 과정이 저절로 이루어지는 것도 마찬가지죠. 또한
C++는 객체가 생성되는 도중에 예외가 던져지더라도 이미 생성이 완료된 부분만큼은 여러
분 손길 없이도 말끔히 소멸되도록 보장합니다. 하지만 지금 말씀드린 시나리오에서 잊으면
안 되는 부분이 있습니다. 바로 C++는 '무엇을' 해야 하는지는 정해 두었지만 그것을 
'어떻게' 해야 하는지는 정하지 않았다는 점입니다. 이 부분은 전적으로 컴파일러 구현자에게 
달려 있지만, 어쨌든 이런 일들이 자기들 스스로 일어나지 않는다는 점만은 명확히 알아두셔
야 하겠습니다. 즉, 여러분 눈에 보이지 않지만 이런 일을 가능하게 하는 어떤 코드가 여러
분의 프로그램에 포함되어야 하고, 이 코드(다시 말해 컴파일러가 만들어서 컴파일 도중에 
여러분의 소스 코드에 삽입하는 코드)가 소스 코드 어딘가에 들어가 있어야 한다는 결론이 
나오는 것입니다. 때에 따라서는 바로 그 장소가 생성자와 소멸자일 수도 있는 것이고요 
그러니까, 비어 있다고 생각되던 Derived 생성자는 사실 어떤 구현환경에서는 다음과 같은 
코드로 만들어질 것이라고 상상해 볼 수 있습니다.

Derived::Derived()		// "비어 있는" Derived 생성자가 실제로 구현된다면
{						// 이런 모습일지도 모른다고 꾸며 본 개념적인 코드
	Base::Base();		// Base 부분을 초기화 합니다.
	try { dm1.std::string::string(); }// dm1의 생성을 시도합니다.
	catch(...)			// 생성 도중에 dm1에서 예외를 던지면, 
	{
		Base::~Base();	// 기본 클래스 부분을 소멸시키고
		throw;			// 그 예외를 전파합니다(다시 던집니다).
	}

	try { dm2.std::string::string(); }// dm2의 생성을 시도합니다.
	catch(...)			// 생성 도중에 dm2에서 예외를 던지면, 
	{
		dm1.std::string::~string();
		Base::~Base();	// 기본 클래스 부분을 소멸시키고
		throw;			// 그 예외를 전파합니다.
	}

	try { dm3.std::string::string(); }// dm3의 생성을 시도합니다.
	catch(...)			// 생성 도중에 dm3에서 예외를 던지면, 
	{
		dm2.std::string::~string();
		dm1.std::string::~string();
		Base::~Base();	// 기본 클래스 부분을 소멸시키고
		throw;			// 그 예외를 전파합니다.
	}
}

솔직히 말해서 진짜 컴파일러가 실제로 만들어내는 코드도 이렇다고 보기는 힘듭니다. 진짜
컴파일러의 경우에는 예외 처리를 위처럼 무식하게 하지 않기 때문입니다. 그렇다고는 해도
Derived의 '텅 빈' 생성자가 실제로 어떤 동작을 하는지에 대한 사항은 정확하게 나와 있
으니 잘 봐 두도록 하세요. 여기서 컴파일러가 어떤 세련된 방법으로 예외를 처리하도록 구
현됐는지는 사실 중요하지 않습니다. 어쨌든 Derived 클래스의 생성자는 최소한 자신의
데이터 멤버와 기본 클래스 부분에 대해 생성자를 호출해 주어야 하고, 이들 생성자를 호출
해야 하기 때문에(이 녀석들도 인라인될 수 있습니다) 인라인이 사뭇 난감해지는 거라고요.

Base 생성자의 경우에 대해서도 똑같이 생각하면 됩니다. 그러니까 Base 생성자가 인라
인되면, 이 함수에 삽입되어 있던 코드들도 전부 Derived 생성자에 끼어들어가야 합니다.
(Base 생성자를 Derived 생성자가 호출하니까요) 그리고 string 생성자마저도 어쩌다가
인라인되면, Derived 생성자는 똑같은 함수 본문을 다섯 개나 갖게 되는 것입니다. 뭐겠어
요? Derived 객체가 갖는 다섯 개의 string 데이터 멤버에 대한 생성자죠(이 중 두 개
는 Base로부터 물려받은 것이고, 세 개는 Derived 안에서 선언한 것이고요) . 이제 대충 
감이 오실 겁니다. Derived 생성자를 인라인해야 하나 말아야 하나를 고민히는 것은 절대로 
밥 먹고 할 일 없어서가 아니라고요. Derived 소멸자의 경우에도 사정은 비슷합니다. 어떻게
하든 Derived 생성자가 초기화시킨 객체가 제대로 소멸되도록 만들 의무는 Derived 소
멸자에게 있으니까요.

라이브러리를 설계하는 분이라면 함수를 inline으로 선언할 때 그 영향에 대해 많은 고민
을 해야 합니다. 시용자의 눈에 뻔히 보이는 인라인 함수에 대해서는 라이브러리 차원에서
바이너리 업그레이드를 제공할 수 없기 때문입니다. 어떤 라이브러리에 f라는 인라인 함수
가 있고, 이 라이브러리를 쓰는 사용자가 f의 본문을 컴파일해서 응용프로그램을 만들었다
고 가정해 보세요. 나중에 이 라이브러리 개발자가 f의 내부를 바꾸겠다고 결정했다면, f를
썼던 사용자들은 슬프지만 죄다 각자의 소스를 다시 컴파일해야 할 것입니다. 반대로 f가
인라인 함수가 아닌 보통 함수라고 하면, f가 바뀌었을 때 시용자들은 링크만 다시 해 주면
끝납니다. 다시 링크하는 게 다시 컴파일하는 것보다 더 성가시다고 하실 분은 분명 없을
거예요. 게다가 f를 제공하는 라이브러리가 동적 링크 방식을 취하고 있으면, 사용자 쪽에
서논 '어, 그냥 바뀌었네?'라고 생각할 정도로 개발 작업이 완벽하게 투명해질 것입니다.

그러고 보니 인라인 함수도 참 따질 게 많네요. 프로그램을 개발하기 위해서는 이번에 공부
한 것들을 전부 머리 속에서 따져 보고 가는 게 중요하겠지만, 실제로 코딩하는 사람의 입
장에서 보면 한 가지 사실 때문에 다른 나머지가 별로 크게 다가오지 않습니다. 그 사실이
란, 대부분의 디버거가 무척이나 곤란해 하는 비호감 대상이 바로 인라인 함수라는 점입니
다. 뭐 대단한 일급비밀을 떠벌린 것도 아닙니다. 있지도 않은 함수에 중단점을 걸수 있으
면 그야말로 진정한 용사라고 불려야 맞지 않겠습니끼? 물론 어떤 빌드 환경은 인라인 함수
의 디버깅을 어떻게든 지원해 주긴 하지만, 대다수의 환경에서는 디버그 빌드에 대해 인라
인을 비활성화해 주는 정도만으로 황송할 따름입니다.

사정이 이렇다 보니, 어떤 함수를 인라인으로 선언해야 하고 또 어떤 것을 선언하지 말아야
하는지에 대한 기본 전략이 턱 하니 나오게 됩니다. 우선, 아무것도 인라인하지 마세요. 아
니면 꼭 인라인해야 하는 함수(항목 46 참조) 혹은 정말 단순한 함수(이번 항목 처음에 나온
Person::age 같은 함수가 여기에 해당됩니다)에 한해서만 인라인 함수로 선언하는 것으로
시작하십시오. 인라인을 주의해서 사용하는 버릇을 들여서, 디버깅하고 싶은 부분에서 여러
분의 디버거를 제대로 쓸 수 있도록 만드시고, 정말 필요한 위치에 인라인 함수를 놓도록
하세요. 수동 최적화인 셈이지요. 인라인이 좋다고 해서, 동서고금의 경험에서 얻어진 불멸
의 법칙인 '80-20 법칙'까지 잊어버리면 안 됩니다. 정말 중요한 법칙이랍니다. 이 법칙은 
제품의 성능을 올릴 수 있는 20%의 코드를 찾아내어야 하는 소프트웨어 개발자인 여러분의 
전의를 태워 주는 '스팀팩'이기 때문입니다. 그리고 가장 중요한 것은 함수입니다. 출시의 
그날이 오기 전에는 함수를 인라인하든 배배 꼬든 어떤 일도 할 수 있겠지만, 함수 자체가 
똑바로 만들어져 있지 않으면 나중에 비싼 밥 먹고 삽질했다는 말밖엔 나오지 않을 것입니다.

이것만은 잊지 말자!
*	함수 인라인은 작고, 자주 호출되는 함수에 대해서만 하는 것으로 합시다. 이렇게
	하면 디버깅 및 라이브러리의 바이너리 업그레이드가 용이해지고 자칫 생길 수 있는 
	코드 비대화 현상이 최소화되며, 프로그램의 속력이 더 빨라질 수 있는 여지가 최고로 
	많아집니다.

*	함수 템플릿이 대개 헤더 파일에 들어간다는 일반적인 부분만 빼서 이들을 inline으
	로 선언하면 안 됩니다.