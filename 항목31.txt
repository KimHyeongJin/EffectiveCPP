항목 31: 파일 사이의 컴파일 의존성을 최대로 줄이자

연말에 여러분은 한두 달 전쯤 접었던 C++ 프로그램을 다시 작업하기로 결심합니다. 
프로그램 소스 파일과는 완전히 담 쌓고 유투브 동영상과 호형호제하며 보내던 나날이었
지만, 깔끔히 마무리하지 못했던 클래스 하나가 줄곧 마음에 걸렸던 것도 사실이었습니다. 
정신 차린 그날 바로 그 클래스를 아주 살짝 손보았습니다, 인터페이스도 아니고, 구현부
에 있는 코드 몇 줄인데다가, 외부에 노출되지도 않는 부분이었죠. 이제 수정을 마친 후 
프로그램을 다시 빌드하기로 합니다. 기껏해야 몇 초 안 걸릴 것 같습니다. 어쨌든 클래스 
하나만 바뀌었을 뿐이니까요. '빌드' 도구 튼을 클릭하고(아니면 make를 쳤을 수도 있
고요. 사실 같은 동작을 수행하기만 하면 어떤 것도 상관없죠) 기다려 보는데, 느낌이 
이상합니다. 자기네들도 몰라서 서로 싸우는 대학원 조교들 보면서 멍청히 시험점수 깎이는 
걸 보고만 있는 기분이랄까요. 아 글쎄, 건들지도 않은 다른 동네들까지 몽땅 다시 컴파일
되고 다시 링크되더란 말입니다. 여러분은 이런 일이 생길 때 버럭 짜증만 내고 끝내시진 
않나요?

문제의 핵심은 C++가 인터페이스와 구현을 깔끔하게 분리하는 일에 별로 일가견이 없다는
데 있습니다. C++의 클래스 정의(class definition)는 클래스 인터페이스만 지정하는 
것이 아니라 구현 세부사항까지 상당히 많이 지정하고 있거든요. 이런 예는 어지간한 경우
가 아니면 정말 쉽게 접할 수 있습니다.

class Person
{
public:
	Person(const std::string& name, 
			const Date& birthday, 
			const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
private:
	std::string theName;	// 구현 세부사항
	Date theBirthDate;		// 구현 세부사항
	Address theAddress;		// 구현 세부사항
};

위의 코드만 가지고 Person 클래스가 컴파일될 수 있을까요? 천만에요 Person의 구현
세부사항에 속하는 것들, 다시 말해 string, Date, Address가 어떻게 정의됐는지를 
모르면 컴파일 자체가 불기능합니다. 결국 이 정의된 정보를 가져 와야 하고, 이때 쓰는
것이 #include 지시자이죠. 따라서 Person 클래스를 정의하는 파일을 보면 대개 아래
와 비슷한 코드를 발견하게 되는 것입니다.

#include <string>
#include "date.h"
#include "address.h"

유감스럽지만 이 녀석들이 바로 골칫덩이입니다. 위의 #include 문은 Person을 정의한
파일과 위의 헤더 파일들 사이에 컴파일 의존성(compilation dependency)이란 것을 
엮어 버립니다. 그러면 위의 헤더 파일 셋 중 하나라도 바뀌는 것은 물론이고 이들과 또 
엮여 있는 헤더 파일들이 바뀌기만 해도, Person 클래스를 정의한 파일은 코 꿰이듯 
컴파일러에게 끌려가야 합니다. 심지어 Person을 사용하는 다른 파일까지 몽땅 다시 
컴파일되어야 한다니까요. 꼬리에 꼬리를 무는 이런 식의 컴파일 의존성이 있으면 프로젝
트가 말도 못 할정도로 고통스러워집니다.7)

7)	한 줄 바꾸고 나서 몇 십분 기다리기만 서너 번 해 보면 바로 알 수 있다.
	인생의 패배자는 다른게 아니다.-옮긴이

어째서 C++는 구현 세부사항이 클래스 정의문 안에 들어가는 것을 내버려 두어 왔는지, 
심히 불만스러운 분들도 계실 줄 압니다. 그러니까, Person 클래스를 정의할 때 구현 
세부사항을 따로 떼어서 지정하는 식으로 하면 안 되냐는 거죠. 아래처럼 말입니다.

namespace std
{
	class string;		// 전방 선언(곧 뒤에서 확인하시겠지만 틀린 겁니다.)
}

class Date;		// 전방 선언
class Address;	// 전방 선언

class Person
{
public:
	Person(const std::string& name, 
		const Date& birthday, 
		const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
};

이런 코드가 된다면 Person 사용자는 Person 클래스의 인터페이스가 바뀌었을 때만 컴
파일을 다시 하면 되니 얼마나 좋겠습니까. 희망사항이란 점이 슬플 따름이죠.

아이디어만 놓고 보면 기특하기 이를 데 없습니다만 문제가 두 가지나 있습니다. 첫 번째,
string은 사실 클래스가 아니라 typedef로 정의한 타입동의어입니다(basic_string<
char>를 typedef 한 것이죠). 그러니 string에 대한 전방 선언이 맞을 리가 없죠. 제대로
전방 선언을 하려면 템플릿을 추가로 끌고 들어와야 하기 때문에 더 복잡합니다. 그렇긴 해
도 여러분 입장에서는 표준 라이브러리의 일부를 직접 선언하려 들지는 않을 테니 뭐 그리
대수롭진 않을 것입니다. #include로 헤더만 잘 포함시켜 놓으면 그걸로 끝이잖아요. 표
준 라이브러리 헤더는 어지간한 경우만 아니면 컴파일 시 병목요인이 되진 않습니다. 특히
여러분이 쓰시는 빌드 환경이 사전 컴파일 헤더(precompiled header)를 쓸 수 있는 환경이
면 더 그렇습니다. 표준 헤더를 구문분석하는 단계가 진짜로 문제가 되면, 인터페이스 설계
를 고치는 방법밖에는 없습니다. 표준 라이브러리의 구성요소 중에 원치 않는 #include
가 생기게 하는 것들을 시용하지 않게끔 여러분이 직접 손을 봐야 한다고요.

필요한 요소들을 모두 전방 선언할 때의 두 번째 문제는(첫 번째 것보다 훨씬 중요합니다), 
컴파일러가 컴파일 도중에 객체들의 크기를 전부 알아야 한다는 데 있습니다. 아래의 예제를
가지고 설명해드릴 테니 잘 보세요.int main(){	int x;	Person p(params);	// Person 하나를 정의합니다.	...}