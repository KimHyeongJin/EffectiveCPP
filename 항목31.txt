항목 31: 파일 사이의 컴파일 의존성을 최대로 줄이자

연말에 여러분은 한두 달 전쯤 접었던 C++ 프로그램을 다시 작업하기로 결심합니다. 
프로그램 소스 파일과는 완전히 담 쌓고 유투브 동영상과 호형호제하며 보내던 나날이었
지만, 깔끔히 마무리하지 못했던 클래스 하나가 줄곧 마음에 걸렸던 것도 사실이었습니다. 
정신 차린 그날 바로 그 클래스를 아주 살짝 손보았습니다, 인터페이스도 아니고, 구현부
에 있는 코드 몇 줄인데다가, 외부에 노출되지도 않는 부분이었죠. 이제 수정을 마친 후 
프로그램을 다시 빌드하기로 합니다. 기껏해야 몇 초 안 걸릴 것 같습니다. 어쨌든 클래스 
하나만 바뀌었을 뿐이니까요. '빌드' 도구 튼을 클릭하고(아니면 make를 쳤을 수도 있
고요. 사실 같은 동작을 수행하기만 하면 어떤 것도 상관없죠) 기다려 보는데, 느낌이 
이상합니다. 자기네들도 몰라서 서로 싸우는 대학원 조교들 보면서 멍청히 시험점수 깎이는 
걸 보고만 있는 기분이랄까요. 아 글쎄, 건들지도 않은 다른 동네들까지 몽땅 다시 컴파일
되고 다시 링크되더란 말입니다. 여러분은 이런 일이 생길 때 버럭 짜증만 내고 끝내시진 
않나요?

문제의 핵심은 C++가 인터페이스와 구현을 깔끔하게 분리하는 일에 별로 일가견이 없다는
데 있습니다. 

C++의 클래스 정의(class definition)는 클래스 인터페이스만 지정하는 
것이 아니라 구현 세부사항까지 상당히 많이 지정하고 있거든요. 

이런 예는 어지간한 경우가 아니면 정말 쉽게 접할 수 있습니다.

class Person
{
public:
	Person(const std::string& name, 
			const Date& birthday, 
			const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
private:
	std::string theName;	// 구현 세부사항
	Date theBirthDate;		// 구현 세부사항
	Address theAddress;		// 구현 세부사항
};

위의 코드만 가지고 Person 클래스가 컴파일될 수 있을까요? 천만에요 Person의 구현
세부사항에 속하는 것들, 다시 말해 string, Date, Address가 어떻게 정의됐는지를 
모르면 컴파일 자체가 불기능합니다. 결국 이 정의된 정보를 가져 와야 하고, 이때 쓰는
것이 #include 지시자이죠. 따라서 Person 클래스를 정의하는 파일을 보면 대개 아래
와 비슷한 코드를 발견하게 되는 것입니다.

#include <string>
#include "date.h"
#include "address.h"

유감스럽지만 이 녀석들이 바로 골칫덩이입니다. 위의 #include 문은 Person을 정의한
파일과 위의 헤더 파일들 사이에 컴파일 의존성(compilation dependency)이란 것을 
엮어 버립니다. 그러면 위의 헤더 파일 셋 중 하나라도 바뀌는 것은 물론이고 이들과 또 
엮여 있는 헤더 파일들이 바뀌기만 해도, Person 클래스를 정의한 파일은 코 꿰이듯 
컴파일러에게 끌려가야 합니다. 심지어 Person을 사용하는 다른 파일까지 몽땅 다시 
컴파일되어야 한다니까요. 꼬리에 꼬리를 무는 이런 식의 컴파일 의존성이 있으면 프로젝
트가 말도 못 할정도로 고통스러워집니다.7)

7)	한 줄 바꾸고 나서 몇 십분 기다리기만 서너 번 해 보면 바로 알 수 있다.
	인생의 패배자는 다른게 아니다.-옮긴이

어째서 C++는 구현 세부사항이 클래스 정의문 안에 들어가는 것을 내버려 두어 왔는지, 
심히 불만스러운 분들도 계실 줄 압니다. 그러니까, Person 클래스를 정의할 때 구현 
세부사항을 따로 떼어서 지정하는 식으로 하면 안 되냐는 거죠. 아래처럼 말입니다.

namespace std
{
	class string;		// 전방 선언(곧 뒤에서 확인하시겠지만 틀린 겁니다.)
}

class Date;		// 전방 선언
class Address;	// 전방 선언

class Person
{
public:
	Person(const std::string& name, 
		const Date& birthday, 
		const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
};

이런 코드가 된다면 Person 사용자는 Person 클래스의 인터페이스가 바뀌었을 때만 컴
파일을 다시 하면 되니 얼마나 좋겠습니까. 희망사항이란 점이 슬플 따름이죠.

아이디어만 놓고 보면 기특하기 이를 데 없습니다만 문제가 두 가지나 있습니다. 

*	첫 번째, string은 사실 클래스가 아니라 typedef로 정의한 타입동의어입니다
	(basic_string<char>를 typedef 한 것이죠).
	
*	두 번째 문제는(첫 번째 것보다 훨씬 중요합니다), 컴파일러가 컴파일 도중에 
	객체들의 크기를 전부 알아야 한다는 데 있습니다.

그러니 string에 대한 전방 선언이 맞을 리가 없죠. 제대로 전방 선언을 하려면 템플릿
을 추가로 끌고 들어와야 하기 때문에 더 복잡합니다. 그렇긴 해도 여러분 입장에서는 
표준 라이브러리의 일부를 직접 선언하려 들지는 않을 테니 뭐 그리 대수롭진 않을 것입
니다. #include로 헤더만 잘 포함시켜 놓으면 그걸로 끝이잖아요. 표준 라이브러리 헤
더는 어지간한 경우만 아니면 컴파일 시 병목요인이 되진 않습니다. 특히 여러분이 쓰시
는 빌드 환경이 사전 컴파일 헤더(precompiled header)를 쓸 수 있는 환경이면 더 
그렇습니다. 표준 헤더를 구문분석하는 단계가 진짜로 문제가 되면, 인터페이스 설계
를 고치는 방법밖에는 없습니다. 표준 라이브러리의 구성요소 중에 원치 않는 #include
가 생기게 하는 것들을 시용하지 않게끔 여러분이 직접 손을 봐야 한다고요.

필요한 요소들을 모두 전방 선언할 때의 두 번째 문제는(첫 번째 것보다 훨씬 중요합니다), 
컴파일러가 컴파일 도중에 객체들의 크기를 전부 알아야 한다는 데 있습니다.
아래의 예제를 가지고 설명해드릴 테니 잘 보세요.

int main()
{
	int x;
	Person p(params);	// Person 하나를 정의합니다.
	...
}

컴파일러는 x의 정의문을 만나면 일단 int 하나를 담을 충분한 공간을 할당해야(대개 스택
에) 한다는 것을 알고 있습니다. 여기까지는 아무 문제가 없습니다. 영장류의 사고수준을 
가진 자가 만든 컴파일러라면 int의 크기가 얼마나 되는지 모르진 않을 테니까요. 자 이제
그 컴파일러가 x의 정의문을 만납니다. 역시 Person 하나를 담을 공간을 할당해야 한다는
것은 알고 있지만, 대체 Person 객체 하나의 크기가 얼마인지를 컴파일러가 무슨 수로 알
아낸다고 생각하세요? 이 Person 클래스가 정의된 정보를 보는 수밖엔 뾰족한 방법이 없
습니다. 그런데 만약 클래스 정의에서 구현 세부사항을 빠뜨려도 적법하다고 C++ 명세서에
적혀 있었다면, 컴파일러는 자신이 할당할 공간을 정확히 파악할 수 있을까요?

스몰토크(Smalltalk) 및 자바의 경우로 눈을 돌려보면 지금의 고민은 고민거리조차 안 
됩니다. 이들 언어에서는 객체가 정의될 때 컴파일러가 그 객체의 포인터를 담을 공간만 할당하
거든요. 다시 말하자면 위의 코드는 아래와 같이 쓰인 것으로 보인다는 것입니다.

int main()
{
	int x;
	Person* p;	// Person 포인터를 정의합니다.
	...
}

물론 이 코드도 적법한 C++ 코드입니다. 제대로 돌아간다는 이야기죠 그러니까 '포인터 뒤
에 실제 객체 구현부 숨기기' 놀이를 직접 C++를 가지고도 하실 수 있습니다. 말이 나온
김에 Person 클래스에 대해 이렇게 하는 방법 한 가지를 알아보도록 합시다. 우선 주어진 
클래스를 두 클래스로 쪼개십시오. 한쪽은 인터페이스만 제공하고, 또 한쪽은 그 인터페이스
의 구현을 맡도록 만드는 것입니다. 구현을 맡은 클래스의 이름이 PersonImpl이라고 하
면, Person 클래스는 다음과 같이 정의할 수 있을 거예요.

#include <string>	// 표준 라이브러리 구성요소는 전방 선언을 하면 안됩니다.

#include <memory>	// tr1::shared_ptr을 위한 헤더입니다.

class PersonImpl;	// Person의 구현 클래스에 대한 전방 선언

// Person 클래스 안에서 사용하는 것들에 대한 전방 선언
class Date;			
class Address;

class Person
{
public:
	Person(const std::string& name, 
		const Date& birthday, 
		const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
private:
	// 구현 클래스 객체에 대한 포인터 std::tr1::shared_ptr에
	// 대한 이야기는 항목 13에서 확인하세요.
	std::tr1::shared_ptr<PersonImpl> pImpl;
};

위의 코드를 보면 주 클래스(Person)에 들어 있는 데이터 멤버라고는 구현 클래스(Person-
Impl)에 대한 포인터(tr1::shared_ptr입니다. 항목 13 참조)뿐입니다. 이런 설계는 거의
패턴으로 굳어져 있을 정도여서 

pimpl 관용구("pointer to implementation")

라는 이름도 있는데, 이때 포인터의 이름은 대개 pImpl이라고 는 것이 일반적입니다. 위에
서도 그렇게 했죠.

어쨌든 이렇게 설계해 두면, Person의 사용자는 생일, 주소, 이름 등의 자질구레한 세부사
항과 완전히 갈라서게 됩니다. Person 클래스에 대한 구현 클래스 부분은 생각만 있으면
마음대로 고칠 수 있지만, 그래도 Person의 사용자 쪽에서는 컴파일을 다시 할 필요가 없
습니다. 게다가 Person이 어떻게 구현되어 있는지를 들여다볼 수 없기 때문에, 구현 부
사항에 어떻게든 직접 발을 걸치는 코드를 작성할 여지가 사라집니다. 그야말로 인터페이스
와 구현이 뼈와 살이 분리되듯 떨어지는 것이죠.

이렇게 인터페이스와 구현을 둘로 나누는 열쇠는 
'정의부에 대한 의존성(dependences on definitions)'을 
선언부에 대한 의존성(dependncies on declarations)'으로 바꾸어 놓는 데있습니다.

이게 바로 컴파일 의존성을 최소화하는 핵심 원리이죠. 
즉, 헤더 파일을 만들 때는 실용적으로 의미를 갖는 한 자체조달(self-sufficient)
(예를 들어 유틸성 함수가 필요하다면 다른 헤더파일에 이미 정의되어 있는 함수를 사
용하기 위해 헤더파일을 #include 하지 않고 자체적으로 정의해서 사용하자?)
형태로 만드시고, 정 안 되면 다른파일에 대해 의존성을 갖도록 하되 정의부가 아닌 선언
부에 대해 의존성을 갖도록 만드는 것입니다. 매우 간결한 전략이지만 이 외의 나머지 전
략들은 이것을 축으로 해서 흘러가게 되어 있습니다. 자, 그럼 정리해 볼까요?

*	객체 참조자 및 포인터로 충분한 경우에는 객체를 직접 쓰지 않습니다.
	어떤 타입에 대한 참조자 및 포인터를 정의할 때는 그 타입의 선언부만 필요합니다. 
	반면, 어떤 타입의 객체를 정의할 때는 그 타입의 정의(구현부)가 준비되어 있어야 
	합니다.
	
*	할 수 있으면 클래스 정의(구현부) 대신 클래스 선언에 최대한 의존하도록 만듭니다. 
	어떤 클래스를 사용하는 함수를 선언할 때는 그 클래스의 정의를 가져오지 않아도 됩
	니다. 심지어 그 클래스 객체를 값으로 전달하거나 반환하더라도 클래스 정의가 필요
	없습니다.(클래스 정의 대신 클래스 선언에 의존하도록 만들자)

	class Date;		// 클래스 선언
	// 함수를 선언 할 때 사용하는 Date 클래스 정의를 가져오지 않아도된다.
	Date today();	// 좋습니다. Date 클래스의 정으를 가져오지 않아도 됩니다.
	void clearAppointments(Date d);// Date 클래스의 정으를 가져오지 않아도 
									// 됩니다.

물론 '값에 의한 전달 방식은 좋은 방법이라고 보긴 힘들지만(항목 20 참조), 피치 못할
사정 때문에 써야 할 경우도 있을 텐데, 이런 경우에도 불필요한 컴파일 의존성을 끌고
들어오는게 아무런 변명거리도 되지 못한다는 것입니다.

Date를 정의하지 않고도 today와 clearAppointments 힘수를 선언할 수 있다는
데 놀라는 분도 있겠지만, 보기만큼 이상한 것도 아닙니다. 누군가가 이들 함수를 호출한
다면 호출하기 전에 Date의 정의가 파악되어야 하겠죠. 그렇다면, 어째서 아무도 호출
할 것 같지 않은 함수를 이렇게까지 애써서 선언하려는 걸까요? 웃기죠? 모르시는 말씀.

호출하는 사람이 아무도 없어서가 아니라, 호출하는 사람이 모두가 아니기 때문입니다!!

수십 개의 함수를 선언해 둔 여러분의 멋진 라이브러리를 쓰는 다른 사용자들이 전부 그
라이브러리의 함수들을 빠짐없이 불러 주리라고 생각진 않으시겠죠? 제품을 만들려면 클
래스 정의를 제공하는 일을 어딘가에서 해야 하겠지만, 함수 선언이 되어 있는 여러분(라
이브러리)의 헤더 파일 쪽에 그 부담을 주지 않고 실제 함수 호출이 일어나는 시용자의
소스 파일 쪽에 전가하는 방법을 사용한 것입니다. 이렇게 하면 설제로 쓰지도 않을 타
입 정의에 대해 사용자가 의존성을 끌어오는 거추장스러움을 막을 수 있지요.

*	선언부와 정의부에 대해 별도의 헤더 파일을 제공합니다. 
	"클래스를 둘로 쪼개자"라는 지침을 제대로 쓸 수 있도록 하려면 헤더 파일이 
	짝으로 있어야 합니다. 하나는 선언부를 위한 헤더 파일이고, 또 하나는 정의부를 
	위한 헤더 파일이겠지요. 당연한 이야기이겠지만 이 두 파일은 관리도 짝 단위로 
	해야 합니다. 한쪽에서 어떤 선언이 바뀌면 다른 쪽도 똑같이 바꾸어야 한다는 
	거죠. 그렇기 때문에, 라이브러리 사용자 쪽에서는 전방 선언 대신에 선언부 
	헤더 파일을 항상 #include 해야 할 것이고, 라이브러리 제작자 쪽에서는 헤더 
	파일 두 개를 짝지어 제공하는 일을 잊으면 안 됩니다. 그러니까 예를 들어, 
	Date의 사용자가 today 함수와 clearAppointments 함수를 선언하고 싶다고 
	해서 위의 코드에 나온 대로 Date를 직접 전방 선언하면 난감해진다는 뜻입니다. 
	그렇게 하지 말고, Date 클래스에 대한 선언부 헤더를 #include 해야 합니다.
	아래를 보세요.

	#include "datefwd.h"	// Date 클래스를 선언하고 있는(그러나 정의하
							// 진 않은) 헤더 파일
	Date today();			// 앞에서 본 것과 똑같은 함수 선언들
	void clearAppointments(Date d);

	선언부만 들어 있는 헤더 파일의 이름이 "datefwd.h"입니다. 사실 이 이름은 표준
	C++ 라이브러리의 <iosfwd> 헤더(항목 54 참조)를 보고 따온 것입니다. <iosfwd>
	는 C++에서 지원하는 iostream 관련 함수 및 클래스들의 선언부만으로 구성된 헤
	더입니다. 각각의 정의부는 일정한 분류에 따라 여러 개의 헤더에 나뉘어 있는데,
	<sstream>, <streambuf>, <fstream>, <iostream> 등입니다.

	<iosfwd> 파일을 잘 알아두면 유익한 이유는 하나 더 있습니다. 이번 항목의 내용이
	템플릿이 아닌 파일뿐만 아니라 템플릿에도 들어맞는다는 사실을 확인하기에 딱 좋다는
	점입니다. 대다수의 빌드 환경에서 템플릿 정의가 대개 헤더 파일에 있다는 설명을 항
	목 30에서 드린 바 있었지만, 몇몇 빌드 환경에서는 헤더가 아닌 파일에 템플릿 정의가
	포함된 경우도 더러 있는 것이 사실입니다. 그러니까 선언부 전용 헤더를 제공하자는
	이야기가 템플릿에 대해서도 의미가 없진 않은 거죠. <iosfwd>는 바로 그런 헤더의
	대표인 셈입니다.

	이 나왔으니 말인데, 사실 C++에서는 템플릿 선언과 템플릿 정의를 분리할 수 있도
	록 하는 기능을 export라는 키워드로 제공하고 있습니다. 문제는 현재 이 키워드를
	제대로 지원하는 컴파일러가 별로 없다는 것이고, export를 현장에서 쓰는 예가 너무
	드물다는 점이 더 암울합니다. 이런 사정을 고려할 때, export 키워드가 효과적인
	C++ 프로그래멍에 어떻게 쓰일 수 있을지에 대해 이야기하기에는 아직 시기상조인 듯
	하다는 생각이 드네요.
여기서 보신 pimpl 관용구를 사용하는 Person 같은 클래스를 가리켜 핸들 클래스(handle
class)라고 합니다. 이번 항목의 Person 클래스만 보고 '이런게 대체 뭘 할 수 있담?'
하면서 의문을 갖는 독자가 계실까봐 활용 방법을 하나 알려드리겠습니다. 핸들 클래스에서 
어떤 함수를 호출하게 되어 있다면, 핸들 클래스에 대응되는 구현 클래스 쪽으로 그 함수 
호출을 전달해서 구현 클래스가 실제 작업을 수행하게 만드세요. 예제를 보고 싶으신
분들을 위해 Person 클래스의 멤버 함수 중 두 를 다음과 같이 구현해 보겠습니다.

#include "Person.h"	// Person 클래스를 구현하고 있는 중이기 때문에, 이 Person
					// 의 클래스 정의를 #include해야 합니다.

#include "PersonImpl.h"	// 이와 동시에 PersonImpl의 클래스 정의도 #include
						// 해야 하는데, 이렇게 하지 않으면 멤버 함수를 호출할
						// 수 없습니다. 잘 보시면 PersonImpl의 멤버 함수는
						// Person의 멤버 함수와 일대일로 대응되고 있음을 알
						// 수 있습니다. 인터페이스가 똑같습니다.

Person::Person(const std::string& name, const Date& birthday, 
				const Address& addr)
				:pImpl(new PersonImpl(name, birthday, addr)){}

std::string Person::name() const
{
	return pImpl->name();
}
	