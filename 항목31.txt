항목 31: 파일 사이의 컴파일 의존성을 최대로 줄이자

연말에 여러분은 한두 달 전쯤 접었던 C++ 프로그램을 다시 작업하기로 결심합니다. 
프로그램 소스 파일과는 완전히 담 쌓고 유투브 동영상과 호형호제하며 보내던 나날이었
지만, 깔끔히 마무리하지 못했던 클래스 하나가 줄곧 마음에 걸렸던 것도 사실이었습니다. 
정신 차린 그날 바로 그 클래스를 아주 살짝 손보았습니다, 인터페이스도 아니고, 구현부
에 있는 코드 몇 줄인데다가, 외부에 노출되지도 않는 부분이었죠. 이제 수정을 마친 후 
프로그램을 다시 빌드하기로 합니다. 기껏해야 몇 초 안 걸릴 것 같습니다. 어쨌든 클래스 
하나만 바뀌었을 뿐이니까요. '빌드' 도구 튼을 클릭하고(아니면 make를 쳤을 수도 있
고요. 사실 같은 동작을 수행하기만 하면 어떤 것도 상관없죠) 기다려 보는데, 느낌이 
이상합니다. 자기네들도 몰라서 서로 싸우는 대학원 조교들 보면서 멍청히 시험점수 깎이는 
걸 보고만 있는 기분이랄까요. 아 글쎄, 건들지도 않은 다른 동네들까지 몽땅 다시 컴파일
되고 다시 링크되더란 말입니다. 여러분은 이런 일이 생길 때 버럭 짜증만 내고 끝내시진 
않나요?

문제의 핵심은 C++가 인터페이스와 구현을 깔끔하게 분리하는 일에 별로 일가견이 없다는
데 있습니다. C++의 클래스 정의(class definition)는 클래스 인터페이스만 지정하는 
것이 아니라 구현 세부사항까지 상당히 많이 지정하고 있거든요. 이런 예는 어지간한 경우
가 아니면 정말 쉽게 접할 수 있습니다.

class Person
{
public:
	Person(const std::string& name, 
			const Date& birthday, 
			const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
private:
	std::string theName;	// 구현 세부사항
	Date theBirthDate;		// 구현 세부사항
	Address theAddress;		// 구현 세부사항
};

위의 코드만 가지고 Person 클래스가 컴파일될 수 있을까요? 천만에요 Person의 구현
세부사항에 속하는 것들, 다시 말해 string, Date, Address가 어떻게 정의됐는지를 
모르면 컴파일 자체가 불기능합니다. 결국 이 정의된 정보를 가져 와야 하고, 이때 쓰는
것이 #include 지시자이죠. 따라서 Person 클래스를 정의하는 파일을 보면 대개 아래
와 비슷한 코드를 발견하게 되는 것입니다.

#include <string>
#include "date.h"
#include "address.h"

유감스럽지만 이 녀석들이 바로 골칫덩이입니다. 위의 #include 문은 Person을 정의한
파일과 위의 헤더 파일들 사이에 컴파일 의존성(compilation dependency)이란 것을 
엮어 버립니다. 그러면 위의 헤더 파일 셋 중 하나라도 바뀌는 것은 물론이고 이들과 또 
엮여 있는 헤더 파일들이 바뀌기만 해도, Person 클래스를 정의한 파일은 코 꿰이듯 
컴파일러에게 끌려가야 합니다. 심지어 Person을 사용하는 다른 파일까지 몽땅 다시 
컴파일되어야 한다니까요. 꼬리에 꼬리를 무는 이런 식의 컴파일 의존성이 있으면 프로젝
트가 말도 못 할정도로 고통스러워집니다.7)

7)	한 줄 바꾸고 나서 몇 십분 기다리기만 서너 번 해 보면 바로 알 수 있다.
	인생의 패배자는 다른게 아니다.-옮긴이

어째서 C++는 구현 세부사항이 클래스 정의문 안에 들어가는 것을 내버려 두어 왔는지, 
심히 불만스러운 분들도 계실 줄 압니다. 그러니까, Person 클래스를 정의할 때 구현 
세부사항을 따로 떼어서 지정하는 식으로 하면 안 되냐는 거죠. 아래처럼 말입니다.

namespace std
{
	class string;		// 전방 선언(곧 뒤에서 확인하시겠지만 틀린 겁니다.)
}

class Date;		// 전방 선언
class Address;	// 전방 선언

class Person
{
public:
	Person(const std::string& name, 
		const Date& birthday, 
		const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
};

이런 코드가 된다면 Person 사용자는 Person 클래스의 인터페이스가 바뀌었을 때만 컴
파일을 다시 하면 되니 얼마나 좋겠습니까. 희망사항이란 점이 슬플 따름이죠.

아이디어만 놓고 보면 기특하기 이를 데 없습니다만 문제가 두 가지나 있습니다. 

*	첫 번째, string은 사실 클래스가 아니라 typedef로 정의한 타입동의어입니다
	(basic_string<char>를 typedef 한 것이죠).
	
*	두 번째 문제는(첫 번째 것보다 훨씬 중요합니다), 컴파일러가 컴파일 도중에 
	객체들의 크기를 전부 알아야 한다는 데 있습니다.

그러니 string에 대한 전방 선언이 맞을 리가 없죠. 제대로 전방 선언을 하려면 템플릿
을 추가로 끌고 들어와야 하기 때문에 더 복잡합니다. 그렇긴 해도 여러분 입장에서는 
표준 라이브러리의 일부를 직접 선언하려 들지는 않을 테니 뭐 그리 대수롭진 않을 것입
니다. #include로 헤더만 잘 포함시켜 놓으면 그걸로 끝이잖아요. 표준 라이브러리 헤
더는 어지간한 경우만 아니면 컴파일 시 병목요인이 되진 않습니다. 특히 여러분이 쓰시
는 빌드 환경이 사전 컴파일 헤더(precompiled header)를 쓸 수 있는 환경이면 더 
그렇습니다. 표준 헤더를 구문분석하는 단계가 진짜로 문제가 되면, 인터페이스 설계
를 고치는 방법밖에는 없습니다. 표준 라이브러리의 구성요소 중에 원치 않는 #include
가 생기게 하는 것들을 시용하지 않게끔 여러분이 직접 손을 봐야 한다고요.

필요한 요소들을 모두 전방 선언할 때의 두 번째 문제는(첫 번째 것보다 훨씬 중요합니다), 
컴파일러가 컴파일 도중에 객체들의 크기를 전부 알아야 한다는 데 있습니다.
아래의 예제를 가지고 설명해드릴 테니 잘 보세요.

int main()
{
	int x;
	Person p(params);	// Person 하나를 정의합니다.
	...
}

컴파일러는 x의 정의문을 만나면 일단 int 하나를 담을 충분한 공간을 할당해야(대개 스택
에) 한다는 것을 알고 있습니다. 여기까지는 아무 문제가 없습니다. 영장류의 사고수준을 
가진 자가 만든 컴파일러라면 int의 크기가 얼마나 되는지 모르진 않을 테니까요. 자 이제
그 컴파일러가 x의 정의문을 만납니다. 역시 Person 하나를 담을 공간을 할당해야 한다는
것은 알고 있지만, 대체 Person 객체 하나의 크기가 얼마인지를 컴파일러가 무슨 수로 알
아낸다고 생각하세요? 이 Person 클래스가 정의된 정보를 보는 수밖엔 뾰족한 방법이 없
습니다. 그런데 만약 클래스 정의에서 구현 세부사항을 빠뜨려도 적법하다고 C++ 명세서에
적혀 있었다면, 컴파일러는 지신이 할당할 공간을 정확히 파악할 수 있을까요?

스몰토크(Smalltalk) 및 자바의 경우로 눈을 돌려보면 지금의 고민은 고민거리조차 안 
됩니다. 이들 언어에서는 객체가 정의될 때 컴파일러가 그 객체의 포인터를 담을 공간만 할당하
거든요. 다시 말하자면 위의 코드는 아래와 같이 쓰인 것으로 보인다는 것입니다.

int main()
{
	int x;
	Person* p;	// Person 포인터를 정의합니다.
	...
}

물론 이 코드도 적법한 C++ 코드입니다. 제대로 돌아간다는 이야기죠 그러니까 '포인터 뒤
에 실제 객체 구현부 숨기기' 놀이를 직접 C++를 가지고도 하실 수 있습니다. 말이 나온
김에 Person 클래스에 대해 이렇게 하는 방법 한 가지를 아보도록 합시다. 우선 주어진 
클래스를 두 클래스로 쪼개십시오. 한쪽은 인터페이스만 제공하고, 또 한쪽은 그 인터페이스
의 구현을 맡도록 만드는 것입니다. 구현을 맡은 클래스의 이름이 PersonImpl이라고 하
면, Person 클래스는 다음과 같이 정의할 수 있을 거예요.

#include <string>	// 표준 라이브러리 구성요소는 전방 선언을 하면 안됩니다.

#include <memory>	// tr1::shared_ptr을 위한 헤더입니다.

class PersonImpl;	// Person의 구현 클래스에 대한 전방 선언

// Person 클래스 안에서 사용하는 것들에 대한 전방 선언
class Date;			
class Address;

class Person
{
public:
	Person(const std::string& name, 
		const Date& birthday, 
		const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
private:
	// 구현 클래스 객체에 대한 포인터 std::tr1::shared_ptr에
	// 대한 이야기는 항목 13에서 확인하세요.
	std::tr1::shared_ptr<PersonImpl> pImpl;
};

위의 코드를 보면 주 클래스(Person)에 들어 있는 데이터 멤버라고는 구현 클래스(Person-
Impl)에 대한 포인터(tr1::shared_ptr입니다. 항목 13 참조)뿐입니다. 이런 설계는 거의
패턴으로 굳어져 있을 정도여서 

pimpl 관용구("pointer to implementation")

라는 이름도 있는데, 이때 포인터의 이름은 대개 pImpl이라고 는 것이 일반적입니다. 위에
서도 그렇게 했죠.

어쨌든 이렇게 설계해 두면, Person의 사용자는 생일, 주소, 이름 등의 자질구레한 세부사
항과 완전히 갈라서게 됩니다. Person 클래스에 대한 구현 클래스 부분은 생각만 있으면
마음대로 고칠 수 있지만, 그래도 Person의 사용자 쪽에서는 컴파일을 다시 할 필요가 없
습니다. 게다가 Person이 어떻게 구현되어 있는지를 들여다볼 수 없기 때문에, 구현 부
사항에 어떻게든 직접 발을 걸치는 코드를 작성할 여지가 사라집니다. 그야말로 인터페이스
와 구현이 뼈와 살이 분리되듯 떨어지는 것이죠.

이렇게 인터페이스와 구현을 둘로 나누는 열쇠는 '정의부에 대한 의존성(dependences on
definitions)'을 선언부에 대한 의존성(dependncies on declarations)'으로 바꾸어 
놓는 데있습니다. 이게 바로 컴파일 의존성을 최소화하는 핵심 원리이죠. 즉, 헤더 파일을 
만들 때는 실용적으로 의미를 갖는 한 자체조달(self-sufficient) 형태로 만드시고, 
정 안 되면 다른파일에 대해 의존성을 갖도록 하되 정의부가 아닌 선언부에 대해 의존성을 
갖도록 만드는 것입니다. 매우 간결한 전략이지만 이 외의 나머지 전략들은 이것을 축으로 
해서 흘러가게 되어 있습니다. 자, 그럼 정리해 볼까요?

*	객체 참조자 및 포인터로 충분한 경우에는 객체를 직접 쓰지 않습니다. 
	어떤 타입에 대한 참조자 및 포인터를 정의할 때는 그 타입의 선언부만 필요합니다. 
	반면, 어떤 타입의 객체를 정의할 때는 그 타입의 정의가 준비되어 있어야 합니다.

*	할 수 있으면 클래스 정의 대신 클래스 선언에 최대한 의존하도록 만듭니다. 
	어떤 클래스를 사용하는 함수를 선언할 때는 그 클래스의 정의를 가져오지 않아도 됩
	니다. 심지어 그 클래스 객체를 값으로 전달하거나 반환하더라도 클래스 정의가 필요
	없습니다.
	(클래스 정의 대신 클래스 선언에 의존하도록 만들자????)