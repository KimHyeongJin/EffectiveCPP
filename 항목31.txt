항목 31: 파일 사이의 컴파일 의존성을 최대로 줄이자

연말에 여러분은 한두 달 전쯤 접었던 C++ 프로그램을 다시 작업하기로 결심합니다. 
프로그램 소스 파일과는 완전히 담 쌓고 유투브 동영상과 호형호제하며 보내던 나날이었
지만, 깔끔히 마무리하지 못했던 클래스 하나가 줄곧 마음에 걸렸던 것도 사실이었습니다. 
정신 차린 그날 바로 그 클래스를 아주 살짝 손보았습니다, 인터페이스도 아니고, 구현부
에 있는 코드 몇 줄인데다가, 외부에 노출되지도 않는 부분이었죠. 이제 수정을 마친 후 
프로그램을 다시 빌드하기로 합니다. 기껏해야 몇 초 안 걸릴 것 같습니다. 어쨌든 클래스 
하나만 바뀌었을 뿐이니까요. '빌드' 도구 튼을 클릭하고(아니면 make를 쳤을 수도 있
고요. 사실 같은 동작을 수행하기만 하면 어떤 것도 상관없죠) 기다려 보는데, 느낌이 
이상합니다. 자기네들도 몰라서 서로 싸우는 대학원 조교들 보면서 멍청히 시험점수 깎이는 
걸 보고만 있는 기분이랄까요. 아 글쎄, 건들지도 않은 다른 동네들까지 몽땅 다시 컴파일
되고 다시 링크되더란 말입니다. 여러분은 이런 일이 생길 때 버럭 짜증만 내고 끝내시진 
않나요?

문제의 핵심은 C++가 인터페이스와 구현을 깔끔하게 분리하는 일에 별로 일가견이 없다는
데 있습니다. 

C++의 클래스 정의(class definition)는 클래스 인터페이스만 지정하는 
것이 아니라 구현 세부사항까지 상당히 많이 지정하고 있거든요. 

이런 예는 어지간한 경우가 아니면 정말 쉽게 접할 수 있습니다.

class Person
{
public:
	Person(const std::string& name, 
			const Date& birthday, 
			const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
private:
	std::string theName;	// 구현 세부사항
	Date theBirthDate;		// 구현 세부사항
	Address theAddress;		// 구현 세부사항
};

위의 코드만 가지고 Person 클래스가 컴파일될 수 있을까요? 천만에요 Person의 구현
세부사항에 속하는 것들, 다시 말해 string, Date, Address가 어떻게 정의됐는지를 
모르면 컴파일 자체가 불기능합니다. 결국 이 정의된 정보를 가져 와야 하고, 이때 쓰는
것이 #include 지시자이죠. 따라서 Person 클래스를 정의하는 파일을 보면 대개 아래
와 비슷한 코드를 발견하게 되는 것입니다.

#include <string>
#include "date.h"
#include "address.h"

유감스럽지만 이 녀석들이 바로 골칫덩이입니다. 위의 #include 문은 Person을 정의한
파일과 위의 헤더 파일들 사이에 컴파일 의존성(compilation dependency)이란 것을 
엮어 버립니다. 그러면 위의 헤더 파일 셋 중 하나라도 바뀌는 것은 물론이고 이들과 또 
엮여 있는 헤더 파일들이 바뀌기만 해도, Person 클래스를 정의한 파일은 코 꿰이듯 
컴파일러에게 끌려가야 합니다. 심지어 Person을 사용하는 다른 파일까지 몽땅 다시 
컴파일되어야 한다니까요. 꼬리에 꼬리를 무는 이런 식의 컴파일 의존성이 있으면 프로젝
트가 말도 못 할정도로 고통스러워집니다.7)

7)	한 줄 바꾸고 나서 몇 십분 기다리기만 서너 번 해 보면 바로 알 수 있다.
	인생의 패배자는 다른게 아니다.-옮긴이

어째서 C++는 구현 세부사항이 클래스 정의문 안에 들어가는 것을 내버려 두어 왔는지, 
심히 불만스러운 분들도 계실 줄 압니다. 그러니까, Person 클래스를 정의할 때 구현 
세부사항을 따로 떼어서 지정하는 식으로 하면 안 되냐는 거죠. 아래처럼 말입니다.

namespace std
{
	class string;		// 전방 선언(곧 뒤에서 확인하시겠지만 틀린 겁니다.)
}

class Date;		// 전방 선언
class Address;	// 전방 선언

class Person
{
public:
	Person(const std::string& name, 
		const Date& birthday, 
		const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
};

이런 코드가 된다면 Person 사용자는 Person 클래스의 인터페이스가 바뀌었을 때만 컴
파일을 다시 하면 되니 얼마나 좋겠습니까. 희망사항이란 점이 슬플 따름이죠.

아이디어만 놓고 보면 기특하기 이를 데 없습니다만 문제가 두 가지나 있습니다. 

*	첫 번째, string은 사실 클래스가 아니라 typedef로 정의한 타입동의어입니다
	(basic_string<char>를 typedef 한 것이죠).
	
*	두 번째 문제는(첫 번째 것보다 훨씬 중요합니다), 컴파일러가 컴파일 도중에 
	객체들의 크기를 전부 알아야 한다는 데 있습니다.

그러니 string에 대한 전방 선언이 맞을 리가 없죠. 제대로 전방 선언을 하려면 템플릿
을 추가로 끌고 들어와야 하기 때문에 더 복잡합니다. 그렇긴 해도 여러분 입장에서는 
표준 라이브러리의 일부를 직접 선언하려 들지는 않을 테니 뭐 그리 대수롭진 않을 것입
니다. #include로 헤더만 잘 포함시켜 놓으면 그걸로 끝이잖아요. 표준 라이브러리 헤
더는 어지간한 경우만 아니면 컴파일 시 병목요인이 되진 않습니다. 특히 여러분이 쓰시
는 빌드 환경이 사전 컴파일 헤더(precompiled header)를 쓸 수 있는 환경이면 더 
그렇습니다. 표준 헤더를 구문분석하는 단계가 진짜로 문제가 되면, 인터페이스 설계
를 고치는 방법밖에는 없습니다. 표준 라이브러리의 구성요소 중에 원치 않는 #include
가 생기게 하는 것들을 시용하지 않게끔 여러분이 직접 손을 봐야 한다고요.

필요한 요소들을 모두 전방 선언할 때의 두 번째 문제는(첫 번째 것보다 훨씬 중요합니다), 
컴파일러가 컴파일 도중에 객체들의 크기를 전부 알아야 한다는 데 있습니다.
아래의 예제를 가지고 설명해드릴 테니 잘 보세요.

int main()
{
	int x;
	Person p(params);	// Person 하나를 정의합니다.
	...
}

컴파일러는 x의 정의문을 만나면 일단 int 하나를 담을 충분한 공간을 할당해야(대개 스택
에) 한다는 것을 알고 있습니다. 여기까지는 아무 문제가 없습니다. 영장류의 사고수준을 
가진 자가 만든 컴파일러라면 int의 크기가 얼마나 되는지 모르진 않을 테니까요. 자 이제
그 컴파일러가 x의 정의문을 만납니다. 역시 Person 하나를 담을 공간을 할당해야 한다는
것은 알고 있지만, 대체 Person 객체 하나의 크기가 얼마인지를 컴파일러가 무슨 수로 알
아낸다고 생각하세요? 이 Person 클래스가 정의된 정보를 보는 수밖엔 뾰족한 방법이 없
습니다. 그런데 만약 클래스 정의에서 구현 세부사항을 빠뜨려도 적법하다고 C++ 명세서에
적혀 있었다면, 컴파일러는 자신이 할당할 공간을 정확히 파악할 수 있을까요?

스몰토크(Smalltalk) 및 자바의 경우로 눈을 돌려보면 지금의 고민은 고민거리조차 안 
됩니다. 이들 언어에서는 객체가 정의될 때 컴파일러가 그 객체의 포인터를 담을 공간만 할당하
거든요. 다시 말하자면 위의 코드는 아래와 같이 쓰인 것으로 보인다는 것입니다.

int main()
{
	int x;
	Person* p;	// Person 포인터를 정의합니다.
	...
}

물론 이 코드도 적법한 C++ 코드입니다. 제대로 돌아간다는 이야기죠 그러니까 '포인터 뒤
에 실제 객체 구현부 숨기기' 놀이를 직접 C++를 가지고도 하실 수 있습니다. 말이 나온
김에 Person 클래스에 대해 이렇게 하는 방법 한 가지를 알아보도록 합시다. 우선 주어진 
클래스를 두 클래스로 쪼개십시오. 한쪽은 인터페이스만 제공하고, 또 한쪽은 그 인터페이스
의 구현을 맡도록 만드는 것입니다. 구현을 맡은 클래스의 이름이 PersonImpl이라고 하
면, Person 클래스는 다음과 같이 정의할 수 있을 거예요.

#include <string>	// 표준 라이브러리 구성요소는 전방 선언을 하면 안됩니다.

#include <memory>	// tr1::shared_ptr을 위한 헤더입니다.

class PersonImpl;	// Person의 구현 클래스에 대한 전방 선언

// Person 클래스 안에서 사용하는 것들에 대한 전방 선언
class Date;			
class Address;

class Person
{
public:
	Person(const std::string& name, 
		const Date& birthday, 
		const Address& addr);
	std::string name() const;
	std::string birthDate() const;
	std::string address() const;
	...
private:
	// 구현 클래스 객체에 대한 포인터 std::tr1::shared_ptr에
	// 대한 이야기는 항목 13에서 확인하세요.
	std::tr1::shared_ptr<PersonImpl> pImpl;
};

위의 코드를 보면 주 클래스(Person)에 들어 있는 데이터 멤버라고는 구현 클래스(Person-
Impl)에 대한 포인터(tr1::shared_ptr입니다. 항목 13 참조)뿐입니다. 이런 설계는 거의
패턴으로 굳어져 있을 정도여서 

pimpl 관용구("pointer to implementation")

라는 이름도 있는데, 이때 포인터의 이름은 대개 pImpl이라고 하는 것이 일반적입니다. 
위에서도 그렇게 했죠.

어쨌든 이렇게 설계해 두면, Person의 사용자는 생일, 주소, 이름 등의 자질구레한 세부사
항과 완전히 갈라서게 됩니다. Person 클래스에 대한 구현 클래스 부분은 생각만 있으면
마음대로 고칠 수 있지만, 그래도 Person의 사용자 쪽에서는 컴파일을 다시 할 필요가 없
습니다. 게다가 Person이 어떻게 구현되어 있는지를 들여다볼 수 없기 때문에, 구현 부
사항에 어떻게든 직접 발을 걸치는 코드를 작성할 여지가 사라집니다. 그야말로 인터페이스
와 구현이 뼈와 살이 분리되듯 떨어지는 것이죠.

이렇게 인터페이스와 구현을 둘로 나누는 열쇠는 
'정의부에 대한 의존성(dependences on definitions)'을 
선언부에 대한 의존성(dependncies on declarations)'으로 바꾸어 놓는 데있습니다.

이게 바로 컴파일 의존성을 최소화하는 핵심 원리이죠. 
즉, 헤더 파일을 만들 때는 실용적으로 의미를 갖는 한 자체조달(self-sufficient)
(예를 들어 유틸성 함수가 필요하다면 다른 헤더파일에 이미 정의되어 있는 함수를 사
용하기 위해 헤더파일을 #include 하지 않고 자체적으로 정의해서 사용하자?)
형태로 만드시고, 정 안 되면 다른파일에 대해 의존성을 갖도록 하되 정의부가 아닌 선언
부에 대해 의존성을 갖도록 만드는 것입니다. 매우 간결한 전략이지만 이 외의 나머지 전
략들은 이것을 축으로 해서 흘러가게 되어 있습니다. 자, 그럼 정리해 볼까요?

*	객체 참조자 및 포인터로 충분한 경우에는 객체를 직접 쓰지 않습니다.
	어떤 타입에 대한 참조자 및 포인터를 정의할 때는 그 타입의 선언부만 필요합니다. 
	반면, 어떤 타입의 객체를 정의할 때는 그 타입의 정의(구현부)가 준비되어 있어야 
	합니다.
	
*	할 수 있으면 클래스 정의(구현부) 대신 클래스 선언에 최대한 의존하도록 만듭니다. 
	어떤 클래스를 사용하는 함수를 선언할 때는 그 클래스의 정의를 가져오지 않아도 됩
	니다. 심지어 그 클래스 객체를 값으로 전달하거나 반환하더라도 클래스 정의가 필요
	없습니다.(클래스 정의 대신 클래스 선언에 의존하도록 만들자)

	class Date;		// 클래스 선언
	// 함수를 선언 할 때 사용하는 Date 클래스 정의를 가져오지 않아도된다.
	Date today();	// 좋습니다. Date 클래스의 정으를 가져오지 않아도 됩니다.
	void clearAppointments(Date d);// Date 클래스의 정으를 가져오지 않아도 
									// 됩니다.

물론 '값에 의한 전달 방식은 좋은 방법이라고 보긴 힘들지만(항목 20 참조), 피치 못할
사정 때문에 써야 할 경우도 있을 텐데, 이런 경우에도 불필요한 컴파일 의존성을 끌고
들어오는게 아무런 변명거리도 되지 못한다는 것입니다.

Date를 정의하지 않고도 today와 clearAppointments 힘수를 선언할 수 있다는
데 놀라는 분도 있겠지만, 보기만큼 이상한 것도 아닙니다. 누군가가 이들 함수를 호출한
다면 호출하기 전에 Date의 정의가 파악되어야 하겠죠. 그렇다면, 어째서 아무도 호출
할 것 같지 않은 함수를 이렇게까지 애써서 선언하려는 걸까요? 웃기죠? 모르시는 말씀.

호출하는 사람이 아무도 없어서가 아니라, 호출하는 사람이 모두가 아니기 때문입니다!!

수십 개의 함수를 선언해 둔 여러분의 멋진 라이브러리를 쓰는 다른 사용자들이 전부 그
라이브러리의 함수들을 빠짐없이 불러 주리라고 생각진 않으시겠죠? 제품을 만들려면 클
래스 정의를 제공하는 일을 어딘가에서 해야 하겠지만, 함수 선언이 되어 있는 여러분(라
이브러리)의 헤더 파일 쪽에 그 부담을 주지 않고 실제 함수 호출이 일어나는 시용자의
소스 파일 쪽에 전가하는 방법을 사용한 것입니다. 이렇게 하면 설제로 쓰지도 않을 타
입 정의에 대해 사용자가 의존성을 끌어오는 거추장스러움을 막을 수 있지요.

*	선언부와 정의부에 대해 별도의 헤더 파일을 제공합니다. 
	"클래스를 둘로 쪼개자"라는 지침을 제대로 쓸 수 있도록 하려면 헤더 파일이 
	짝으로 있어야 합니다. 하나는 선언부를 위한 헤더 파일이고, 또 하나는 정의부를 
	위한 헤더 파일이겠지요. 당연한 이야기이겠지만 이 두 파일은 관리도 짝 단위로 
	해야 합니다. 한쪽에서 어떤 선언이 바뀌면 다른 쪽도 똑같이 바꾸어야 한다는 
	거죠. 그렇기 때문에, 라이브러리 사용자 쪽에서는 전방 선언 대신에 선언부 
	헤더 파일을 항상 #include 해야 할 것이고, 라이브러리 제작자 쪽에서는 헤더 
	파일 두 개를 짝지어 제공하는 일을 잊으면 안 됩니다. 그러니까 예를 들어, 
	Date의 사용자가 today 함수와 clearAppointments 함수를 선언하고 싶다고 
	해서 위의 코드에 나온 대로 Date를 직접 전방 선언하면 난감해진다는 뜻입니다. 
	그렇게 하지 말고, Date 클래스에 대한 선언부 헤더를 #include 해야 합니다.
	아래를 보세요.

	#include "datefwd.h"	// Date 클래스를 선언하고 있는(그러나 정의하
							// 진 않은) 헤더 파일
	Date today();			// 앞에서 본 것과 똑같은 함수 선언들
	void clearAppointments(Date d);

	선언부만 들어 있는 헤더 파일의 이름이 "datefwd.h"입니다. 사실 이 이름은 표준
	C++ 라이브러리의 <iosfwd> 헤더(항목 54 참조)를 보고 따온 것입니다. <iosfwd>
	는 C++에서 지원하는 iostream 관련 함수 및 클래스들의 선언부만으로 구성된 헤
	더입니다. 각각의 정의부는 일정한 분류에 따라 여러 개의 헤더에 나뉘어 있는데,
	<sstream>, <streambuf>, <fstream>, <iostream> 등입니다.

	<iosfwd> 파일을 잘 알아두면 유익한 이유는 하나 더 있습니다. 이번 항목의 내용이
	템플릿이 아닌 파일뿐만 아니라 템플릿에도 들어맞는다는 사실을 확인하기에 딱 좋다는
	점입니다. 대다수의 빌드 환경에서 템플릿 정의가 대개 헤더 파일에 있다는 설명을 항
	목 30에서 드린 바 있었지만, 몇몇 빌드 환경에서는 헤더가 아닌 파일에 템플릿 정의가
	포함된 경우도 더러 있는 것이 사실입니다. 그러니까 선언부 전용 헤더를 제공하자는
	이야기가 템플릿에 대해서도 의미가 없진 않은 거죠. <iosfwd>는 바로 그런 헤더의
	대표인 셈입니다.

	이 나왔으니 말인데, 사실 C++에서는 템플릿 선언과 템플릿 정의를 분리할 수 있도
	록 하는 기능을 export라는 키워드로 제공하고 있습니다. 문제는 현재 이 키워드를
	제대로 지원하는 컴파일러가 별로 없다는 것이고, export를 현장에서 쓰는 예가 너무
	드물다는 점이 더 암울합니다. 이런 사정을 고려할 때, export 키워드가 효과적인
	C++ 프로그래멍에 어떻게 쓰일 수 있을지에 대해 이야기하기에는 아직 시기상조인 듯
	하다는 생각이 드네요.

여기서 보신 pimpl 관용구를 사용하는 Person 같은 클래스를 가리켜 핸들 클래스(handle
class)라고 합니다.

이번 항목의 Person 클래스만 보고 '이런게 대체 뭘 할 수 있담?'하면서 의문을 갖는 
독자가 계실까봐 활용 방법을 하나 알려드리겠습니다. 핸들 클래스에서 어떤 함수를 호출
하게 되어 있다면, 핸들 클래스에 대응되는 구현 클래스 쪽으로 그 함수 호출을 전달해서 
구현 클래스가 실제 작업을 수행하게 만드세요. 예제를 보고 싶으신 분들을 위해 Person 
클래스의 멤버 함수 중 두 개를 다음과 같이 구현해 보겠습니다.

#include "Person.h"	// Person 클래스를 구현하고 있는 중이기 때문에, 이 Person
					// 의 클래스 정의를 #include해야 합니다.

#include "PersonImpl.h"	// 이와 동시에 PersonImpl의 클래스 정의도 #include
						// 해야 하는데, 이렇게 하지 않으면 멤버 함수를 호출할
						// 수 없습니다. 잘 보시면 PersonImpl의 멤버 함수는
						// Person의 멤버 함수와 일대일로 대응되고 있음을 알
						// 수 있습니다. 인터페이스가 똑같습니다.

Person::Person(const std::string& name, const Date& birthday, 
				const Address& addr)
				:pImpl(new PersonImpl(name, birthday, addr)){}

std::string Person::name() const
{
	return pImpl->name();
}

Person 생성자가 어떻게 PersonImpl 생성자를 호출하는지를 놓치지 말고 보시기 바랍
니다(new를 사용하고 있죠? 항목 16 참조). 그리고 Person::name이 PersonImpl::name
을 호출하는 부분도 잘 보시고요. 진짜 중요한 부분입니다. Person은 핸들 클래스이지만
그렇다고 Person의 동작이 바뀐 것은 아닙니다. Person의 동작을 수행하는 방법이 바뀌
었을뿐이죠.

핸들 클래스 방법 대신에 다른 방법을 쓰고 싶다면 Person을 특수 형태의 추상 기본 클
래스 이른바 인터페이스 클래스(Interface class)로 만드는 방법도 생각해 볼 수 있겠습
니다. 어떤 기능을 나타내는 인터페이스를 추상 기본 클래스를 통해 마련해 놓고, 이 클래스로
부터 파생 클래스를 만들 수 있게 하자는 거죠(항목 34 참조). 파생이 목적이기 때문에 이런
클래스에는 데이터 멤버도 없고, 생성자도 없으며, 하나의 가상 소멸자(항목 7 참조)와 인터
페이스를 구성히는 순수 가상 함수만 들어 있습니다.

인터페이스 클래스는 자바 및 닷넷의 '인터페이스'와 사뭇 흡사하지만, C++는 자바 및 닷넷
이 인터페이스에 대해 제약을 가하는 것처럼 인터페이스 클래스에 제약을 가하지 않습니다.
이를테면 자바 혹은 닷넷의 인터페이스는 언어 차원에서 데이터 멤버나 함수 구현을 아예
가질 수 없지만, C++에는 이런 것들에 대한 제약이 없습니다. 한편으로는 C++가 좀더 융
통성이 있다고 볼 수 있는데, 가끔 이 점이 유용하게 쓰이기도 한답니다, 항목 36을 보시면
알겠지만 비가상 함수의 구현은 주어진 클래스 계통 내의 모든 클래스에 대해 똑같아야 합
니다. 따라서 비가상 함수는 인터페이스 클래스의 일부로서 구현해 두는 편이 이치에 딱 맞
는것이죠.

Person 클래스의 인터페이스 클래스는 다음과 같이 만들어 볼 수 있겠습니다.

class Person
{
public:
	virtual ~Person();
	virtual std::string name() const = 0;
	virtual std::string birthDate() const = 0;
	virtual std::string address() const = 0;
	...
};

이 클래스를 코드에 써먹으려면 Person에 대한 포인터 혹은 참조자로 프로그래밍하는 방
법밖에 없습니다. 순수 가상 함수를 포함한 클래스를 인스턴스로 만들기는 불가능하니까요
(단, Person의 파생 클래스는 인스턴스로 만들 수 있습니다. 좀더 읽어 보시면 나옵니다). 
그리고 인터페이스 클래스의 인터페이스가 수정되지 않는 한 사용자는 다시 컴파일할 필요가 
없습니다. 이 점은 핸들 클래스를 쓸 때와 마찬가지입니다.

또한 인터페이스 클래스를 사용하기 위해서는 객체 생성 수단이 최소한 하나는 있어야 합니
다. 대개 이 문제는 파생 클래스의 생성자 역할을 대신하는 어떤 함수를 만들어 놓고 이것
을 호출함으로써 해결하고는 합니다. 많은 분들께서 이런 함수를 가리켜 팩토리 함수(항목
13 참조) 혹은 가상 생성자(virtual constructor)라고 부르시더군요. 역할은 간단합니다. 
주어진 인터페이스 클래스의 인터페이스를 지원하는 객체를 동적으로 할당한 후, 그 객체의 
포인터(스마트 포인터가 바람직합니다. 항목 18 참조)를 반환하는 것입니다. 항상은 아니지만, 
이런 함수는 인터페이스 클래스 내부에 정적 멤버로 선언되는 경우가 많습니다.

class Person
{
public:
	...
	static std::tr1::shared_ptr<Person>	// 주어진 매개변수로 초기화되는 Person
		create(const std::string& name, // 객체를 새로 생성하고, 그것에 대한
		const Date& birthday,			// tr1::shared_ptr을 반환합니다. 반환
		const Address& addr);			// 포인터가 tr1::shared_ptr인 이유에
	...									// 대해서는 항목18을 참조
};

사용자 쪽에서는 다음과 같이 사용하면 됩니다.

std::string name;
Date dateOfBirth;
Address address;
...
// Person 인터페이스를 지원하는 객체 한 개를 생성합니다.
std::tr1::shared_ptr<Person> pp(Person::create(name, dateOfBirth, address));
...
// Person 인터페이스를 통해 그 객체를 사용
std::cout<<pp->name()<<" was born on"<<pp->birthDate()
				<<" and now lives at "<<pp->address();
...		// 위에서 생성한 객체는 pp가 유효범위를 벗어날 때 자동으로 삭제됩니다.
		// 이유는 항목 13에서 확인하세요.

여러분도 물론 생각하고 계시겠지만, 해당 인터페이스 클래스의 인터페이스를 지원하는 구체
클래스(concrete class)가 어디엔가 정의되어야 할 것이고 정말로 실행되는 생성자(구체 클래
스의 생성자)가 호출되어야 하는 것은 당연합니다. 실제로 이 부분은 위의 코드에서는 보이지
않는 어둠의 세계, 즉 가상 생성자의 구현부를 갖고 있는 파일 안에서 이루어집나다. 예를
들어 Person 클래스로부터 파생된 RealPerson이라는 구체 클래스가 있다면, 이 클래스는 
자신이 상속받은 가상 함수(순수 가상 함수)에 대한 구현부를 제공하는 식으로 만들어졌을
것입니다.

class RealPerson:public Person
{
public:
	RealPerson(const std::string& name, 
				const Date& birthday, 
				const Address& addr)
				:theName(name), 
				theBirthDate(birthday), 
				theAddress(addr){}

	virtual ~RealPerson(){}
	std::string name() const;	// 이들 멤버 함수에 대한 구현은 보이지
	std::string birthDate() const;	// 않지만, 어떻게 되어 있을지는 쉽게
	std::string address() const;	// 예상할 수 있다.
private:
	std::string theName;
	Date theBirthDate;
	Address theAddress;
};

이제 RealPerson은 준비되었고 남은 것은 Person::create 함수인데, 정말 간단하게
만들 수 있습나다.std::tr1::shared_ptr<Person> Person::create(const std::string& name, 											const Date& birthday, 											const Address addr){	return std::tr1::shared_ptr<Person>(new RealPerson(name, birthday, addr));}Person::create 함수를 현장 느낌에 좀더 가깝게 구현하고 싶다면 사용자가 원하는 대
로 다른 타입의 파생 클래스 객체를 생성할 수 있게끔 만들면 될 것입니다. 이를테면 매개
변수를 더 받도록 해서 그 매개변수의 값에 따라 타입을 다르게 한다든지, 아니면 파일 혹
은 데이터 베이스, 환경 변수 등의 외부 저장소로부터 데이터를 읽어서 그 데이터에 따라 타
입을 다르게 하는 방법 등이 있겠지요.

인터페이스 클래스를 구현하는 용도로 가장 많이 쓰이는 메커니즘이 두 가지 있는데, 여기
서 알아본 RealPerson 예제는 그 중 하나입니다. 다시 정리하면, 인터페이스 클래스
(Person)로부터 인터페이스 명세를 물려받게 만든 후에, 그 인터페이스에 들어 있는 함수
(가상 함수)를 구현하는 것이라고 말할 수 있겠습니다. 한편, 인터페이스 클래스를 구현하는
두 번째 방법은 다중 상속을 사용하는 것입니다. 이 부분은 항목 40에서 자세히 공부할 기
회를 마련해 두었으니 기대해 주세요.

결론적으로, 핸들 클래스와 인터페이스 클래스는 구현부로부터 인터페이스를 뚝 떼어 놓음으
로써 파일들 사이의 컴파일 의존성을 완화시키는 효과를 가져다줍니다. ...라고 말은 했지만,
왠지 곱게 듣지 않는 분들이 새우 눈을 뜨고 계시는군요. 뭔가 통수치는 이야기가 뒤따를
것 같다는 생각들을 하고 계시는 거겠죠. "이번에도 홀딱 빠져들 만한 말씀 감사합니다. 그
런데 비용이 얼마나 되죠?"라며 투덜투덜. 이분들께는 컴퓨터학과 학부 수업처럼 대답을 드
리겠습니다. 일단 실행 시간 비용이 들어가고요. 여기에 객체 한 개당 필요한 저장 공간이
추가로 늘어납니다.

핸들 클래스부터 찬찬히 따져 봅시다. 핸들 클래스의 멤버 함수를 호출하면 알맹이(구현부)
객체의 데이터까지 가기 위해 포인터(구현부 포인터)를 타야 합니다. 그러니까 한 번 접근할
때마다 요구되는 간접화 연산이 한 단계 더 증가하는 셈이죠. 둘째, 객체 하나씩을 저장하는
데 필요한 메모리 크기에 구현부 포인터의 크기가 더해지는 것도 필수입니다. 마지막으로,
구현부 포인터가 동적 할당된 구현부 객체를 가리키도록 어디선가 그 구현부 포인터의 초기
화가 일어나야 합니다(핸들 클래스의 생성자 안에서 말이죠). 결국 동적 메모리 할당(그리고 
필수적인 해제)에 따르는 연산 오버헤드는 물론이고, bad_alloc(메모리가 고갈) 예외와 맞부
딪힐 가능성까지 질질 끌려 다닙니다.

인터페이스 클래스의 경우에는 호출되는 함수가 전부 가상 함수라는 것이 약점입니다. 따라
서 함수 호출이 일어날 때마다 가상 테이블 점프에 따르는 비용이 소모됩니다(항목 7 참조).
게다가, 인터페이스 클래스에서 파생된 객체는 죄다 가상 테이블 포인터를 지니고 있어야
합니다(역시 항목 7 참조). 만약 가상 함수를 공급하는 쪽이 인터페이스 클래스밖에 없을 때
는, 이 가상 테이블 포인터도 객체 하나를 저장하는 데 필요한 메모리 크기를 늘리는 요인
이 됩니다.

마지막으로, 핸들 클래스와 인터페이스 클래스가 똑같이 갖고 있는 약점이 있습니다. 바로
인라인 함수의 도움을 제대로 끌어내기 힘들다는 점입니다. 인라인이 되게 만들려면 함수
본문을 대개 헤더 파일에 두어야 한다고 이미 항목 30에서 말씀드린 바 있는데요. 그렇지만
핸들 클래스와 인터페이스 클래스는 함수 본문과 같은 구현부를 사용자의 눈으로부터 차단
하는 데 중점을 둔 설계입니다. 인라인 함수와 친할리 없겠지요.

하지만 잘 들으세요. 지금까지 말씀드린 이런저런 부분에서 핸들 클래스와 인터페이스 클래
스가 비용 소모를 가져온다고 해서 '정말 구려서 못 쓰겠구나'라면서 접어 버리신다면 그것
만큼 어처구니없는 실수도 없습니다. 사실 가상 함수도 이런 면에서는 마찬가지일 텐데, 가
상 함수 없이 어떻게든 때우는게 가능하다고 생각하지는 않으시겠죠? 이런 기법들은 미래
를 대비한다는 느낌으로 대했으면 하는 바람입니다. 개발 도중에는 핸들 클래스 혹은 인터
페이스 클스를 사용해 주세요. 구현부가 바뀌었을 때 사용자에게 미칠 파급 효과를 최소
로 만드는 것이 좋습니다. 그러다가 제품을 출시해야 될 때 다시 고민을 하는 거죠. 핸들 클
래스와 인터페이스 클래스로 인해 실행 속력이나 파일 크기에서 많이 손해를 보게 되어, 클
래스 사이의 결합도를 높이는 방법밖에 없다는 결론이 나오는지 확인하세요. 핸들 클래스와
인터페이스 클래스를 통짜 구체 클래스로 바꾸는 일은 그때 하셔도 된단 말이죠.

이것만은 잊지 말자!

*	컴파일 의존성을 최소화하는 작업의 배경이 되는 가장 기본적인 아이디어는 '정의' 
	대신에 '선언'에 의존하게 만들자는 것입니다. 이 아이디어에 기반한 두 가지 접근 
	방법은 핸들 클래스와 인터페이스 클래스입니다.

*	라이브러리 헤더는 그 자체로 모든 것을 갖추어야 하며 선언부만 갖고 있는 형태여야
	합니다. 이 규칙은 템플릿이 쓰이거나 쓰이지 않거나 동일하게 적용합시다. 